<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Bio.Cluster._cluster</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://biopython.org">Biopython</a></th>
          </tr></table></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="Bio-module.html">Package&nbsp;Bio</a> ::
        <a href="Bio.Cluster-module.html">Package&nbsp;Cluster</a> ::
        Module&nbsp;_cluster
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="Bio.Cluster._cluster-module.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module _cluster</h1><p class="nomargin-top"></p>
C Clustering Library

<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Functions</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Functions"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">cdata, cmask</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="Bio.Cluster._cluster-module.html#clustercentroids" class="summary-sig-name">clustercentroids</a>(<span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">clusterid</span>,
        <span class="summary-sig-arg">method</span>,
        <span class="summary-sig-arg">transpose</span>)</span><br />
      The clustercentroids routine calculates the cluster centroids, given to
which cluster each element belongs. The centroid is defined as either
the mean or the median over all elements for each dimension.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">distance between two clusters</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="Bio.Cluster._cluster-module.html#clusterdistance" class="summary-sig-name">clusterdistance</a>(<span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">weight</span>,
        <span class="summary-sig-arg">index1</span>,
        <span class="summary-sig-arg">index2</span>,
        <span class="summary-sig-arg">dist</span>,
        <span class="summary-sig-arg">method</span>,
        <span class="summary-sig-arg">transpose</span>)</span><br />
      Arguments:</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">None</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="Bio.Cluster._cluster-module.html#distancematrix" class="summary-sig-name">distancematrix</a>(<span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">weight</span>,
        <span class="summary-sig-arg">transpose</span>,
        <span class="summary-sig-arg">dist</span>,
        <span class="summary-sig-arg">distancematrix</span>)</span><br />
      This function calculuates the distance matrix between the data values.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">None</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="Bio.Cluster._cluster-module.html#kcluster" class="summary-sig-name">kcluster</a>(<span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">nclusters</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">weight</span>,
        <span class="summary-sig-arg">transpose</span>,
        <span class="summary-sig-arg">npass</span>,
        <span class="summary-sig-arg">method</span>,
        <span class="summary-sig-arg">dist</span>,
        <span class="summary-sig-arg">clusterid</span>)</span><br />
      This function implements k-means clustering.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">error, nfound</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="Bio.Cluster._cluster-module.html#kmedoids" class="summary-sig-name">kmedoids</a>(<span class="summary-sig-arg">distance</span>,
        <span class="summary-sig-arg">nclusters</span>,
        <span class="summary-sig-arg">npass</span>,
        <span class="summary-sig-arg">clusterid</span>)</span><br />
      This function implements k-medoids clustering.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">None</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="Bio.Cluster._cluster-module.html#pca" class="summary-sig-name">pca</a>(<span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">columnmean</span>,
        <span class="summary-sig-arg">coordinates</span>,
        <span class="summary-sig-arg">pc</span>,
        <span class="summary-sig-arg">eigenvalues</span>)</span><br />
      This function calculates the principal component decomposition
of the values in data.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">None</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="Bio.Cluster._cluster-module.html#somcluster" class="summary-sig-name">somcluster</a>(<span class="summary-sig-arg">clusterid</span>,
        <span class="summary-sig-arg">celldata</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">weight</span>,
        <span class="summary-sig-arg">transpose</span>,
        <span class="summary-sig-arg">inittau</span>,
        <span class="summary-sig-arg">niter</span>,
        <span class="summary-sig-arg">dist</span>)</span><br />
      This function implements a self-organizing map on a rectangular grid.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">None</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="Bio.Cluster._cluster-module.html#treecluster" class="summary-sig-name">treecluster</a>(<span class="summary-sig-arg">tree</span>,
        <span class="summary-sig-arg">data</span>,
        <span class="summary-sig-arg">mask</span>,
        <span class="summary-sig-arg">weight</span>,
        <span class="summary-sig-arg">transpose</span>,
        <span class="summary-sig-arg">dist</span>,
        <span class="summary-sig-arg">method</span>,
        <span class="summary-sig-arg">distancematrix</span>)</span><br />
      This function implements the pairwise single, complete, centroid, and
average linkage hierarchical clustering methods.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">string</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="version"></a><span class="summary-sig-name">version</span>()</span><br />
      Return the version number of the C Clustering Library as a string.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Variables</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Variables"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__package__"></a><span class="summary-name">__package__</span> = <code title="None">None</code><br />
      hash(x)
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Function Details</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-FunctionDetails"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
</table>
<a name="clustercentroids"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">clustercentroids</span>(<span class="sig-arg">data</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">clusterid</span>,
        <span class="sig-arg">method</span>,
        <span class="sig-arg">transpose</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>The clustercentroids routine calculates the cluster centroids, given to
which cluster each element belongs. The centroid is defined as either
the mean or the median over all elements for each dimension.</p>
<dl class="rst-docutils">
<dt>Arguments:</dt>
<dd><ul class="rst-first rst-last rst-simple">
<li>data: nrows x ncols array containing the data values.</li>
<li>mask: nrows x ncols array of integers, showing which data are
missing. If mask[i,j]==0, then data[i,j] is missing.</li>
<li>clusterid: array containing the cluster number for each item.
The cluster number should be non-negative.</li>
<li>method: specifies whether the centroid is calculated from the
arithmetic mean (method == 'a', default) or the median
(method == 'm') over each dimension.</li>
<li>transpose: if equal to 0, row clusters are considered;
if equal to 1, column clusters are considered.</li>
<li>cdata: 2D array containing, upon return, the cluster centroids.
If transpose == 0, then the dimensions of cdata should be
nclusters x ncols.
If transpose == 1, then the dimensions of cdata should be
nrows x nclusters.</li>
<li>cmask: 2D array of integers describing, upon return,  which elements
in cdata, if any, are missing.</li>
</ul>
</dd>
</dl>
  <dl class="fields">
    <dt>Returns: cdata, cmask</dt>
  </dl>
</td></tr></table>
</div>
<a name="clusterdistance"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">clusterdistance</span>(<span class="sig-arg">data</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">weight</span>,
        <span class="sig-arg">index1</span>,
        <span class="sig-arg">index2</span>,
        <span class="sig-arg">dist</span>,
        <span class="sig-arg">method</span>,
        <span class="sig-arg">transpose</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Arguments:</p>
<blockquote>
<ul class="rst-simple">
<li>data: nrows x ncols array containing the data values.</li>
<li>mask: nrows x ncols array of integers, showing which data are
missing. If mask[i,j]==0, then data[i,j] is missing.</li>
<li>weight: the weights to be used when calculating distances</li>
<li>index1: 1D array identifying which items belong to the first
cluster.</li>
<li>index2: 1D array identifying which items belong to the second
cluster.</li>
<li>dist: specifies the distance function to be used:<ul>
<li>dist == 'e': Euclidean distance</li>
<li>dist == 'b': City Block distance</li>
<li>dist == 'c': Pearson correlation</li>
<li>dist == 'a': absolute value of the correlation</li>
<li>dist == 'u': uncentered correlation</li>
<li>dist == 'x': absolute uncentered correlation</li>
<li>dist == 's': Spearman's rank correlation</li>
<li>dist == 'k': Kendall's tau</li>
</ul>
</li>
<li>method: specifies how the distance between two clusters is defined:<ul>
<li>method == 'a': the distance between the arithmetic means of the
two clusters</li>
<li>method == 'm': the distance between the medians of the two
clusters</li>
<li>method == 's': the smallest pairwise distance between members
of the two clusters</li>
<li>method == 'x': the largest pairwise distance between members of
the two clusters</li>
<li>method == 'v': average of the pairwise distances between
members of the clusters</li>
</ul>
</li>
<li>transpose:<ul>
<li>if equal to 0: clusters of rows are considered;</li>
<li>if equal to 1: clusters of columns are considered.</li>
</ul>
</li>
</ul>
</blockquote>
  <dl class="fields">
    <dt>Returns: distance between two clusters</dt>
  </dl>
</td></tr></table>
</div>
<a name="distancematrix"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">distancematrix</span>(<span class="sig-arg">data</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">weight</span>,
        <span class="sig-arg">transpose</span>,
        <span class="sig-arg">dist</span>,
        <span class="sig-arg">distancematrix</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>This function calculuates the distance matrix between the data values.</p>
<p>Arguments:</p>
<blockquote>
<ul>
<li><p class="rst-first">data: nrows x ncols array containing the data values.</p>
</li>
<li><p class="rst-first">mask: nrows x ncols array of integers, showing which data are
missing. If mask[i,j]==0, then data[i,j] is missing.</p>
</li>
<li><p class="rst-first">weight: the weights to be used when calculating distances.</p>
</li>
<li><p class="rst-first">transpose: if equal to 0: the distances between rows are
calculated;
if equal to 1, the distances beteeen columns are calculated.</p>
</li>
<li><p class="rst-first">dist: specifies the distance function to be used:</p>
<ul class="rst-simple">
<li>dist == 'e': Euclidean distance</li>
<li>dist == 'b': City Block distance</li>
<li>dist == 'c': Pearson correlation</li>
<li>dist == 'a': absolute value of the correlation</li>
<li>dist == 'u': uncentered correlation</li>
<li>dist == 'x': absolute uncentered correlation</li>
<li>dist == 's': Spearman's rank correlation</li>
<li>dist == 'k': Kendall's tau</li>
</ul>
</li>
<li><p class="rst-first">distancematrix: Upon return, the distance matrix as a list of 1D
arrays. The number of columns in each row is equal to the row number
(i.e., len(distancematrix[i]) == i).
An example of the return value is:</p>
<blockquote>
<dl class="rst-docutils">
<dt>matrix = [[],</dt>
<dd><p class="rst-first rst-last">array([1.]),
array([7., 3.]),
array([4., 2., 6.])]</p>
</dd>
</dl>
</blockquote>
</li>
</ul>
</blockquote>
<p>This corresponds to the distance matrix:</p>
<blockquote>
[0. 1.      7.      4.]
[1. 0.      3.      2.]
[7. 3.      0.      6.]
[4. 2.      6.      0.]</blockquote>
  <dl class="fields">
    <dt>Returns: None</dt>
  </dl>
</td></tr></table>
</div>
<a name="kcluster"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">kcluster</span>(<span class="sig-arg">data</span>,
        <span class="sig-arg">nclusters</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">weight</span>,
        <span class="sig-arg">transpose</span>,
        <span class="sig-arg">npass</span>,
        <span class="sig-arg">method</span>,
        <span class="sig-arg">dist</span>,
        <span class="sig-arg">clusterid</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>This function implements k-means clustering.</p>
<p>Arguments:</p>
<blockquote>
<ul class="rst-simple">
<li>data: nrows x ncols array containing the data to be clustered</li>
<li>nclusters: number of clusters (the 'k' in k-means)</li>
<li>mask: nrows x ncols array of integers, showing which data are
missing. If mask[i,j] == 0, then data[i,j] is missing.</li>
<li>weight: the weights to be used when calculating distances</li>
<li>transpose:<ul>
<li>if equal to 0, rows are clustered;</li>
<li>if equal to 1, columns are clustered.</li>
</ul>
</li>
<li>npass: number of times the k-means clustering algorithm is
performed, each time with a different (random) initial
condition. If npass == 0, then the assignments in clusterid
are used as the initial condition.</li>
<li>method: specifies how the center of a cluster is found:<ul>
<li>method == 'a': arithmetic mean</li>
<li>method == 'm': median</li>
</ul>
</li>
<li>dist: specifies the distance function to be used:<ul>
<li>dist == 'e': Euclidean distance</li>
<li>dist == 'b': City Block distance</li>
<li>dist == 'c': Pearson correlation</li>
<li>dist == 'a': absolute value of the correlation</li>
<li>dist == 'u': uncentered correlation</li>
<li>dist == 'x': absolute uncentered correlation</li>
<li>dist == 's': Spearman's rank correlation</li>
<li>dist == 'k': Kendall's tau</li>
</ul>
</li>
<li>clusterid: array in which the final clustering solution will be
stored (output variable). If npass == 0, then clusterid is also used
as an input variable, containing the initial condition from which
the EM algorithm should start. In this case, the k-means algorithm
is fully deterministic.</li>
</ul>
</blockquote>
  <dl class="fields">
    <dt>Returns: None</dt>
  </dl>
</td></tr></table>
</div>
<a name="kmedoids"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">kmedoids</span>(<span class="sig-arg">distance</span>,
        <span class="sig-arg">nclusters</span>,
        <span class="sig-arg">npass</span>,
        <span class="sig-arg">clusterid</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>This function implements k-medoids clustering.</p>
<dl class="rst-docutils">
<dt>Arguments:</dt>
<dd><ul class="rst-first rst-last">
<li><p class="rst-first">distance: The distance matrix between the elements. There are three
ways in which you can pass a distance matrix:</p>
<ol class="rst-arabic simple">
<li>a 2D Numerical Python array (in which only the left-lower
part of the array will be accessed);</li>
<li>a 1D Numerical Python array containing the distances
consecutively;</li>
<li>a list of rows containing the lower-triangular part of
the distance matrix.</li>
</ol>
<p>Examples are:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>distance = array([[0.0, 1.1, 2.3],
<span class="py-more">... </span>                  [1.1, 0.0, 4.5],
<span class="py-more">... </span>                  [2.3, 4.5, 0.0]])
<span class="py-output">(option #1)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>distance = array([1.1, 2.3, 4.5])
<span class="py-output">(option #2)</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>distance = [array([]),
<span class="py-more">... </span>            array([1.1]),
<span class="py-more">... </span>            array([2.3, 4.5])]
<span class="py-output">(option #3)</span></pre>
</blockquote>
<p>These three correspond to the same distance matrix.</p>
</li>
<li><p class="rst-first">nclusters: number of clusters (the 'k' in k-medoids)</p>
</li>
<li><p class="rst-first">npass: number of times the k-medoids clustering algorithm is
performed, each time with a different (random) initial
condition. If npass == 0, then the assignments in clusterid
are used as the initial condition.</p>
</li>
<li><p class="rst-first">clusterid: array in which the final clustering solution will be
stored (output variable). If npass == 0, then clusterid is also used
as an input variable, containing the initial condition from which
the EM algorithm should start. In this case, the k-medoids algorithm
is fully deterministic.</p>
</li>
</ul>
</dd>
<dt>Return values:</dt>
<dd><ul class="rst-first rst-last rst-simple">
<li>error: the within-cluster sum of distances for the returned k-means
clustering solution;</li>
<li>nfound: the number of times this solution was found.</li>
</ul>
</dd>
</dl>
  <dl class="fields">
    <dt>Returns: error, nfound</dt>
  </dl>
</td></tr></table>
</div>
<a name="pca"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">pca</span>(<span class="sig-arg">data</span>,
        <span class="sig-arg">columnmean</span>,
        <span class="sig-arg">coordinates</span>,
        <span class="sig-arg">pc</span>,
        <span class="sig-arg">eigenvalues</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>This function calculates the principal component decomposition
of the values in data.</p>
<p>Arguments:</p>
<blockquote>
<ul class="rst-simple">
<li>data: nrows x ncols array containing the data values.</li>
<li><dl class="rst-first rst-docutils">
<dt>columnmean: array of size nrows) in which the mean of each column</dt>
<dd>will be sorted.</dd>
</dl>
</li>
<li><dl class="rst-first rst-docutils">
<dt>coordinates: nrows x nmin array in which the coordinates of the</dt>
<dd>data along the principal components will be stored;
nmin is min(nrows, ncols).</dd>
</dl>
</li>
<li><dl class="rst-first rst-docutils">
<dt>pc <span class="classifier-delimiter">:</span> <span class="rst-classifier">the principal components as an nmin x ncols array, where nmin</span></dt>
<dd>is min(nrows, ncols).</dd>
</dl>
</li>
<li><dl class="rst-first rst-docutils">
<dt>eigenvalues: array of size min(nrows, ncols), in which the</dt>
<dd>eigenvalues will be stored, sorted by the magnitude
of the eigenvalues, with the largest eigenvalues
appearing first.</dd>
</dl>
</li>
</ul>
</blockquote>
<p>Adding the column means to the dot product of the coordinates and the
principal components, i.e.</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>columnmean + dot(coordinates, pc)</pre>
</blockquote>
<p>recreates the data matrix.</p>
  <dl class="fields">
    <dt>Returns: None</dt>
  </dl>
</td></tr></table>
</div>
<a name="somcluster"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">somcluster</span>(<span class="sig-arg">clusterid</span>,
        <span class="sig-arg">celldata</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">weight</span>,
        <span class="sig-arg">transpose</span>,
        <span class="sig-arg">inittau</span>,
        <span class="sig-arg">niter</span>,
        <span class="sig-arg">dist</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>This function implements a self-organizing map on a rectangular grid.</p>
<dl class="rst-docutils">
<dt>Arguments:</dt>
<dd><ul class="rst-first rst-last rst-simple">
<li>clusterid: array with two columns, with the number of rows equal
to the number of items being clustered. Upon return, each row
in the array contains the x and y coordinates of the cell in the
the rectangular SOM grid to which the item was assigned.</li>
<li>celldata: array with dimensions nxgrid x nygrid x number of columns
if rows are being clustered, or nxgrid x nygrid x number of rows
if columns are being clustered, where nxgrid is the horizontal
dimension of the rectangular SOM map and nygrid is the vertical
dimension of the rectangular SOM map.
Upon return, each element [ix, iy] of this array contains the
data for the centroid of the cluster in the SOM grid cell with
coordinates [ix, iy].</li>
<li>data: nrows x ncols array containing the data to be clustered.</li>
<li>mask: nrows x ncols array of integers, showing which data are
missing. If mask[i,j]==0, then data[i,j] is missing.</li>
<li>weight: the weights to be used when calculating distances</li>
<li>transpose:<ul>
<li>if equal to 0, rows are clustered;</li>
<li>if equal to 1, columns are clustered.</li>
</ul>
</li>
<li>inittau: the initial value of tau (the neighborbood function)</li>
<li>niter: the number of iterations</li>
<li>dist: specifies the distance function to be used:<ul>
<li>dist == 'e': Euclidean distance</li>
<li>dist == 'b': City Block distance</li>
<li>dist == 'c': Pearson correlation</li>
<li>dist == 'a': absolute value of the correlation</li>
<li>dist == 'u': uncentered correlation</li>
<li>dist == 'x': absolute uncentered correlation</li>
<li>dist == 's': Spearman's rank correlation</li>
<li>dist == 'k': Kendall's tau</li>
</ul>
</li>
</ul>
</dd>
</dl>
  <dl class="fields">
    <dt>Returns: None</dt>
  </dl>
</td></tr></table>
</div>
<a name="treecluster"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">treecluster</span>(<span class="sig-arg">tree</span>,
        <span class="sig-arg">data</span>,
        <span class="sig-arg">mask</span>,
        <span class="sig-arg">weight</span>,
        <span class="sig-arg">transpose</span>,
        <span class="sig-arg">dist</span>,
        <span class="sig-arg">method</span>,
        <span class="sig-arg">distancematrix</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>This function implements the pairwise single, complete, centroid, and
average linkage hierarchical clustering methods.</p>
<dl class="rst-docutils">
<dt>Arguments:</dt>
<dd><ul class="rst-first rst-last">
<li><p class="rst-first">tree: an empty Tree object; its nodes will be filled by treecluster
to describe the hierarchical clustering result. See the description
of the Tree class for more information.</p>
</li>
<li><p class="rst-first">data: nrows x ncols array containing the data to be clustered.
Either data or distancematrix (see below) should be None.</p>
</li>
<li><p class="rst-first">mask: nrows x ncols array of integers, showing which data are
missing. If mask[i,j]==0, then data[i,j] is missing.</p>
</li>
<li><p class="rst-first">weight: the weights to be used when calculating distances.</p>
</li>
<li><p class="rst-first">transpose:</p>
<ul class="rst-simple">
<li>if equal to 0, rows are clustered;</li>
<li>if equal to 1, columns are clustered.</li>
</ul>
</li>
<li><p class="rst-first">dist: specifies the distance function to be used:</p>
<ul class="rst-simple">
<li>dist == 'e': Euclidean distance</li>
<li>dist == 'b': City Block distance</li>
<li>dist == 'c': Pearson correlation</li>
<li>dist == 'a': absolute value of the correlation</li>
<li>dist == 'u': uncentered correlation</li>
<li>dist == 'x': absolute uncentered correlation</li>
<li>dist == 's': Spearman's rank correlation</li>
<li>dist == 'k': Kendall's tau</li>
</ul>
</li>
<li><p class="rst-first">method: specifies which linkage method is used:</p>
<ul class="rst-simple">
<li>method == 's': Single pairwise linkage</li>
<li>method == 'm': Complete (maximum) pairwise linkage (default)</li>
<li>method == 'c': Centroid linkage</li>
<li>method == 'a': Average pairwise linkage</li>
</ul>
</li>
<li><p class="rst-first">distancematrix:  The distance matrix between the elements.
Either data (see above) or distancematrix should be None.
There are three ways in which you can pass a distance matrix:</p>
<ol class="rst-arabic simple">
<li>a 2D Numerical Python array (in which only the left-lower
part of the array will be accessed);</li>
<li>a 1D Numerical Python array containing the distances
consecutively;</li>
<li>a list of rows containing the lower-triangular part of
the distance matrix.</li>
</ol>
<p>Examples are:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>distance = array([[0.0, 1.1, 2.3],
<span class="py-more">... </span>                  [1.1, 0.0, 4.5],
<span class="py-more">... </span>                  [2.3, 4.5, 0.0]])
<span class="py-output"># option 1.</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>distance = array([1.1, 2.3, 4.5])
<span class="py-output"># option 2.</span>
<span class="py-output"></span><span class="py-prompt">&gt;&gt;&gt; </span>distance = [array([]),
<span class="py-more">... </span>            array([1.1]),
<span class="py-more">... </span>            array([2.3, 4.5])]
<span class="py-output"># option 3.</span></pre>
</blockquote>
<p>These three correspond to the same distance matrix.</p>
<p>PLEASE NOTE:
As the treecluster routine may shuffle the values in the
distance matrix as part of the clustering algorithm, be sure
to save this array in a different variable before calling
treecluster if you need it later.</p>
</li>
</ul>
</dd>
</dl>
<p>Either data or distancematrix should be None. If distancematrix is None,
the hierarchical clustering solution is calculated from the values in
the argument data. Instead if data is None, the hierarchical clustering
solution is calculated from the distance matrix.
Pairwise centroid-linkage clustering can be calculated only from the data
and not from the distance matrix.
Pairwise single-, maximum-, and average-linkage clustering can be calculated
from either the data or from the distance matrix.</p>
  <dl class="fields">
    <dt>Returns: None</dt>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Project homepage -->
      <th class="navbar" align="right" width="100%">
        <table border="0" cellpadding="0" cellspacing="0">
          <tr><th class="navbar" align="center"
            ><a class="navbar" target="_top" href="http://biopython.org">Biopython</a></th>
          </tr></table></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Tue Dec 18 15:56:14 2018
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
