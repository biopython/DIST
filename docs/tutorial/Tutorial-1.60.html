<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Biopython Tutorial and Cookbook
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -fix Tutorial.tex -->
<!--CUT DEF chapter 1 --><P>
<P ALIGN="center">
<IMG ALIGN="center" SRC="images/biopython.jpg" TITLE="Biopython Logo" ALT="[Biopython Logo]" width="1024" height="288" />
</p>
</P><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Biopython Tutorial and Cookbook</H1><H3 CLASS="titlerest">Jeff Chang, Brad Chapman, Iddo Friedberg, Thomas Hamelryck,<BR>
Michiel de Hoon, Peter Cock, Tiago Antao, Eric Talevich, Bartek Wilczy&#X144;ski</H3><H3 CLASS="titlerest">Last Update &#X2013; 25 June 2012 (Biopython 1.60)</H3></TD></TR>
</TABLE><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter&#XA0;1&#XA0;&#XA0;Introduction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1&#XA0;&#XA0;What is Biopython?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc3">1.2&#XA0;&#XA0;What can I find in the Biopython package</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.3&#XA0;&#XA0;Installing Biopython</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">1.4&#XA0;&#XA0;Frequently Asked Questions (FAQ)</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">Chapter&#XA0;2&#XA0;&#XA0;Quick Start &#X2013; What can you do with Biopython?</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc7">2.1&#XA0;&#XA0;General overview of what Biopython provides</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">2.2&#XA0;&#XA0;Working with sequences</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">2.3&#XA0;&#XA0;A usage example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">2.4&#XA0;&#XA0;Parsing sequence file formats</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc11">2.4.1&#XA0;&#XA0;Simple FASTA parsing example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">2.4.2&#XA0;&#XA0;Simple GenBank parsing example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">2.4.3&#XA0;&#XA0;I love parsing &#X2013; please don&#X2019;t stop talking about it!</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">2.5&#XA0;&#XA0;Connecting with biological databases</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">2.6&#XA0;&#XA0;What to do next</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">Chapter&#XA0;3&#XA0;&#XA0;Sequence objects</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc17">3.1&#XA0;&#XA0;Sequences and Alphabets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">3.2&#XA0;&#XA0;Sequences act like strings</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">3.3&#XA0;&#XA0;Slicing a sequence</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">3.4&#XA0;&#XA0;Turning Seq objects into strings</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">3.5&#XA0;&#XA0;Concatenating or adding sequences</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">3.6&#XA0;&#XA0;Changing case</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">3.7&#XA0;&#XA0;Nucleotide sequences and (reverse) complements</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">3.8&#XA0;&#XA0;Transcription</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">3.9&#XA0;&#XA0;Translation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">3.10&#XA0;&#XA0;Translation Tables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">3.11&#XA0;&#XA0;Comparing Seq objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">3.12&#XA0;&#XA0;MutableSeq objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">3.13&#XA0;&#XA0;UnknownSeq objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">3.14&#XA0;&#XA0;Working with directly strings</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">Chapter&#XA0;4&#XA0;&#XA0;Sequence Record objects</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc32">4.1&#XA0;&#XA0;The SeqRecord object</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">4.2&#XA0;&#XA0;Creating a SeqRecord</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc34">4.2.1&#XA0;&#XA0;SeqRecord objects from scratch</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">4.2.2&#XA0;&#XA0;SeqRecord objects from FASTA files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">4.2.3&#XA0;&#XA0;SeqRecord objects from GenBank files</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">4.3&#XA0;&#XA0;SeqFeature objects</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc38">4.3.1&#XA0;&#XA0;SeqFeatures themselves</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">4.3.2&#XA0;&#XA0;Locations</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">4.3.3&#XA0;&#XA0;Sequence</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">4.4&#XA0;&#XA0;Location testing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">4.5&#XA0;&#XA0;References</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">4.6&#XA0;&#XA0;The format method</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">4.7&#XA0;&#XA0;Slicing a SeqRecord</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">4.8&#XA0;&#XA0;Adding SeqRecord objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">4.9&#XA0;&#XA0;Reverse-complementing SeqRecord objects</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">Chapter&#XA0;5&#XA0;&#XA0;Sequence Input/Output</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc48">5.1&#XA0;&#XA0;Parsing or Reading Sequences</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc49">5.1.1&#XA0;&#XA0;Reading Sequence Files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">5.1.2&#XA0;&#XA0;Iterating over the records in a sequence file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">5.1.3&#XA0;&#XA0;Getting a list of the records in a sequence file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">5.1.4&#XA0;&#XA0;Extracting data</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">5.2&#XA0;&#XA0;Parsing sequences from compressed files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">5.3&#XA0;&#XA0;Parsing sequences from the net</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc55">5.3.1&#XA0;&#XA0;Parsing GenBank records from the net</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">5.3.2&#XA0;&#XA0;Parsing SwissProt sequences from the net</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">5.4&#XA0;&#XA0;Sequence files as Dictionaries</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc58">5.4.1&#XA0;&#XA0;Sequence files as Dictionaries &#X2013; In memory</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">5.4.2&#XA0;&#XA0;Sequence files as Dictionaries &#X2013; Indexed files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">5.4.3&#XA0;&#XA0;Sequence files as Dictionaries &#X2013; Database indexed files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">5.4.4&#XA0;&#XA0;Indexing compressed files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">5.4.5&#XA0;&#XA0;Discussion</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">5.5&#XA0;&#XA0;Writing Sequence Files</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc64">5.5.1&#XA0;&#XA0;Round trips</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">5.5.2&#XA0;&#XA0;Converting between sequence file formats</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">5.5.3&#XA0;&#XA0;Converting a file of sequences to their reverse complements</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">5.5.4&#XA0;&#XA0;Getting your SeqRecord objects as formatted strings</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">Chapter&#XA0;6&#XA0;&#XA0;Multiple Sequence Alignment objects</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc69">6.1&#XA0;&#XA0;Parsing or Reading Sequence Alignments</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc70">6.1.1&#XA0;&#XA0;Single Alignments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">6.1.2&#XA0;&#XA0;Multiple Alignments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">6.1.3&#XA0;&#XA0;Ambiguous Alignments</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">6.2&#XA0;&#XA0;Writing Alignments</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc74">6.2.1&#XA0;&#XA0;Converting between sequence alignment file formats</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">6.2.2&#XA0;&#XA0;Getting your alignment objects as formatted strings</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">6.3&#XA0;&#XA0;Manipulating Alignments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc77">6.4&#XA0;&#XA0;Alignment Tools</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc78">6.4.1&#XA0;&#XA0;ClustalW</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">6.4.2&#XA0;&#XA0;MUSCLE</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">6.4.3&#XA0;&#XA0;MUSCLE using stdout</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">6.4.4&#XA0;&#XA0;MUSCLE using stdin and stdout</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">6.4.5&#XA0;&#XA0;EMBOSS needle and water</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">Chapter&#XA0;7&#XA0;&#XA0;BLAST</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc84">7.1&#XA0;&#XA0;Running BLAST over the Internet</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">7.2&#XA0;&#XA0;Running BLAST locally</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc86">7.2.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">7.2.2&#XA0;&#XA0;Standalone NCBI &#X201C;legacy&#X201D; BLAST</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc88">7.2.3&#XA0;&#XA0;Standalone NCBI BLAST+</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">7.2.4&#XA0;&#XA0;WU-BLAST and AB-BLAST</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">7.3&#XA0;&#XA0;Parsing BLAST output</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">7.4&#XA0;&#XA0;The BLAST record class</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">7.5&#XA0;&#XA0;Deprecated BLAST parsers</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc93">7.5.1&#XA0;&#XA0;Parsing plain-text BLAST output</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">7.5.2&#XA0;&#XA0;Parsing a plain-text BLAST file full of BLAST runs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">7.5.3&#XA0;&#XA0;Finding a bad record somewhere in a huge plain-text BLAST file</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">7.6&#XA0;&#XA0;Dealing with PSI-BLAST</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">7.7&#XA0;&#XA0;Dealing with RPS-BLAST</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">Chapter&#XA0;8&#XA0;&#XA0;Accessing NCBI&#X2019;s Entrez databases</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc99">8.1&#XA0;&#XA0;Entrez Guidelines</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">8.2&#XA0;&#XA0;EInfo: Obtaining information about the Entrez databases</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">8.3&#XA0;&#XA0;ESearch: Searching the Entrez databases</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">8.4&#XA0;&#XA0;EPost: Uploading a list of identifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">8.5&#XA0;&#XA0;ESummary: Retrieving summaries from primary IDs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc104">8.6&#XA0;&#XA0;EFetch: Downloading full records from Entrez</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">8.7&#XA0;&#XA0;ELink: Searching for related items in NCBI Entrez</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">8.8&#XA0;&#XA0;EGQuery: Global Query - counts for search terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">8.9&#XA0;&#XA0;ESpell: Obtaining spelling suggestions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">8.10&#XA0;&#XA0;Parsing huge Entrez XML files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc109">8.11&#XA0;&#XA0;Handling errors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">8.12&#XA0;&#XA0;Specialized parsers</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc111">8.12.1&#XA0;&#XA0;Parsing Medline records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">8.12.2&#XA0;&#XA0;Parsing GEO records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">8.12.3&#XA0;&#XA0;Parsing UniGene records</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">8.13&#XA0;&#XA0;Using a proxy</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">8.14&#XA0;&#XA0;Examples</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc116">8.14.1&#XA0;&#XA0;PubMed and Medline</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">8.14.2&#XA0;&#XA0;Searching, downloading, and parsing Entrez Nucleotide records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">8.14.3&#XA0;&#XA0;Searching, downloading, and parsing GenBank records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">8.14.4&#XA0;&#XA0;Finding the lineage of an organism</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc120">8.15&#XA0;&#XA0;Using the history and WebEnv</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc121">8.15.1&#XA0;&#XA0;Searching for and downloading sequences using the history</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">8.15.2&#XA0;&#XA0;Searching for and downloading abstracts using the history</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">8.15.3&#XA0;&#XA0;Searching for citations</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc124">Chapter&#XA0;9&#XA0;&#XA0;Swiss-Prot and ExPASy</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc125">9.1&#XA0;&#XA0;Parsing Swiss-Prot files</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc126">9.1.1&#XA0;&#XA0;Parsing Swiss-Prot records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc127">9.1.2&#XA0;&#XA0;Parsing the Swiss-Prot keyword and category list</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc128">9.2&#XA0;&#XA0;Parsing Prosite records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">9.3&#XA0;&#XA0;Parsing Prosite documentation records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">9.4&#XA0;&#XA0;Parsing Enzyme records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc131">9.5&#XA0;&#XA0;Accessing the ExPASy server</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc132">9.5.1&#XA0;&#XA0;Retrieving a Swiss-Prot record</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc133">9.5.2&#XA0;&#XA0;Searching Swiss-Prot</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc134">9.5.3&#XA0;&#XA0;Retrieving Prosite and Prosite documentation records</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc135">9.6&#XA0;&#XA0;Scanning the Prosite database</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc136">Chapter&#XA0;10&#XA0;&#XA0;Going 3D: The PDB module</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc137">10.1&#XA0;&#XA0;Structure representation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc138">10.1.1&#XA0;&#XA0;Structure</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc139">10.1.2&#XA0;&#XA0;Model</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc140">10.1.3&#XA0;&#XA0;Chain</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc141">10.1.4&#XA0;&#XA0;Residue</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc142">10.1.5&#XA0;&#XA0;Atom</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc143">10.2&#XA0;&#XA0;Disorder</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc144">10.2.1&#XA0;&#XA0;General approach</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc145">10.2.2&#XA0;&#XA0;Disordered atoms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc146">10.2.3&#XA0;&#XA0;Disordered residues</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc147">10.3&#XA0;&#XA0;Hetero residues</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc148">10.3.1&#XA0;&#XA0;Associated problems</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc149">10.3.2&#XA0;&#XA0;Water residues</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc150">10.3.3&#XA0;&#XA0;Other hetero residues</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc151">10.4&#XA0;&#XA0;Some random usage examples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc152">10.5&#XA0;&#XA0;Common problems in PDB files</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc153">10.5.1&#XA0;&#XA0;Examples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc154">10.5.2&#XA0;&#XA0;Automatic correction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc155">10.5.3&#XA0;&#XA0;Fatal errors</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc156">10.6&#XA0;&#XA0;Other features</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc157">Chapter&#XA0;11&#XA0;&#XA0;Bio.PopGen: Population genetics</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc158">11.1&#XA0;&#XA0;GenePop</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc159">11.2&#XA0;&#XA0;Coalescent simulation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc160">11.2.1&#XA0;&#XA0;Creating scenarios</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc161">11.2.2&#XA0;&#XA0;Running SIMCOAL2</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc162">11.3&#XA0;&#XA0;Other applications</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc163">11.3.1&#XA0;&#XA0;FDist: Detecting selection and molecular adaptation</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc164">11.4&#XA0;&#XA0;Future Developments</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc165">Chapter&#XA0;12&#XA0;&#XA0;Phylogenetics with Bio.Phylo</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc166">12.1&#XA0;&#XA0;Demo: What&#X2019;s in a Tree?</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc167">12.1.1&#XA0;&#XA0;Coloring branches within a tree</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc168">12.2&#XA0;&#XA0;I/O functions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc169">12.3&#XA0;&#XA0;View and export trees</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc170">12.4&#XA0;&#XA0;Using Tree and Clade objects</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc171">12.4.1&#XA0;&#XA0;Search and traversal methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc172">12.4.2&#XA0;&#XA0;Information methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc173">12.4.3&#XA0;&#XA0;Modification methods</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc174">12.4.4&#XA0;&#XA0;Features of PhyloXML trees</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc175">12.5&#XA0;&#XA0;Running external applications</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc176">12.6&#XA0;&#XA0;PAML integration</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc177">12.7&#XA0;&#XA0;Future plans</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc178">Chapter&#XA0;13&#XA0;&#XA0;Sequence motif analysis using Bio.Motif</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc179">13.1&#XA0;&#XA0;Motif objects</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc180">13.1.1&#XA0;&#XA0;Reading and writing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc181">13.1.2&#XA0;&#XA0;Searching for instances</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc182">13.1.3&#XA0;&#XA0;Comparing motifs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc183">13.2&#XA0;&#XA0;<EM>De novo</EM> motif finding</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc184">13.2.1&#XA0;&#XA0;MEME</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc185">13.2.2&#XA0;&#XA0;AlignAce</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc186">13.3&#XA0;&#XA0;Useful links </A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc187">Chapter&#XA0;14&#XA0;&#XA0;Supervised learning methods</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc188">14.1&#XA0;&#XA0;The Logistic Regression Model</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc189">14.1.1&#XA0;&#XA0;Background and Purpose</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc190">14.1.2&#XA0;&#XA0;Training the logistic regression model</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc191">14.1.3&#XA0;&#XA0;Using the logistic regression model for classification</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc192">14.1.4&#XA0;&#XA0;Logistic Regression, Linear Discriminant Analysis, and Support Vector Machines</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc193">14.2&#XA0;&#XA0;<I>k</I>-Nearest Neighbors</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc194">14.2.1&#XA0;&#XA0;Background and purpose</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc195">14.2.2&#XA0;&#XA0;Initializing a <I>k</I>-nearest neighbors model</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc196">14.2.3&#XA0;&#XA0;Using a <I>k</I>-nearest neighbors model for classification</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc197">14.3&#XA0;&#XA0;Na&#XEF;ve Bayes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc198">14.4&#XA0;&#XA0;Maximum Entropy</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc199">14.5&#XA0;&#XA0;Markov Models</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc200">Chapter&#XA0;15&#XA0;&#XA0;Graphics including GenomeDiagram</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc201">15.1&#XA0;&#XA0;GenomeDiagram</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc202">15.1.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc203">15.1.2&#XA0;&#XA0;Diagrams, tracks, feature-sets and features</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc204">15.1.3&#XA0;&#XA0;A top down example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc205">15.1.4&#XA0;&#XA0;A bottom up example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc206">15.1.5&#XA0;&#XA0;Features without a SeqFeature</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc207">15.1.6&#XA0;&#XA0;Feature captions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc208">15.1.7&#XA0;&#XA0;Feature sigils</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc209">15.1.8&#XA0;&#XA0;A nice example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc210">15.1.9&#XA0;&#XA0;Multiple tracks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc211">15.1.10&#XA0;&#XA0;Cross-Links between tracks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc212">15.1.11&#XA0;&#XA0;Further options</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc213">15.1.12&#XA0;&#XA0;Converting old code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc214">15.2&#XA0;&#XA0;Chromosomes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc215">15.2.1&#XA0;&#XA0;Simple Chromosomes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc216">15.2.2&#XA0;&#XA0;Annotated Chromosomes</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc217">Chapter&#XA0;16&#XA0;&#XA0;Cookbook &#X2013; Cool things to do with it</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc218">16.1&#XA0;&#XA0;Working with sequence files</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc219">16.1.1&#XA0;&#XA0;Filtering a sequence file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc220">16.1.2&#XA0;&#XA0;Producing randomised genomes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc221">16.1.3&#XA0;&#XA0;Translating a FASTA file of CDS entries</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc222">16.1.4&#XA0;&#XA0;Making the sequences in a FASTA file upper case</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc223">16.1.5&#XA0;&#XA0;Sorting a sequence file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc224">16.1.6&#XA0;&#XA0;Simple quality filtering for FASTQ files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc225">16.1.7&#XA0;&#XA0;Trimming off primer sequences</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc226">16.1.8&#XA0;&#XA0;Trimming off adaptor sequences</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc227">16.1.9&#XA0;&#XA0;Converting FASTQ files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc228">16.1.10&#XA0;&#XA0;Converting FASTA and QUAL files into FASTQ files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc229">16.1.11&#XA0;&#XA0;Indexing a FASTQ file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc230">16.1.12&#XA0;&#XA0;Converting SFF files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc231">16.1.13&#XA0;&#XA0;Identifying open reading frames</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc232">16.2&#XA0;&#XA0;Sequence parsing plus simple plots</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc233">16.2.1&#XA0;&#XA0;Histogram of sequence lengths</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc234">16.2.2&#XA0;&#XA0;Plot of sequence GC%</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc235">16.2.3&#XA0;&#XA0;Nucleotide dot plots</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc236">16.2.4&#XA0;&#XA0;Plotting the quality scores of sequencing read data</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc237">16.3&#XA0;&#XA0;Dealing with alignments</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc238">16.3.1&#XA0;&#XA0;Calculating summary information</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc239">16.3.2&#XA0;&#XA0;Calculating a quick consensus sequence</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc240">16.3.3&#XA0;&#XA0;Position Specific Score Matrices</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc241">16.3.4&#XA0;&#XA0;Information Content</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc242">16.4&#XA0;&#XA0;Substitution Matrices</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc243">16.4.1&#XA0;&#XA0;Using common substitution matrices</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc244">16.4.2&#XA0;&#XA0;Creating your own substitution matrix from an alignment</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc245">16.5&#XA0;&#XA0;BioSQL &#X2013; storing sequences in a relational database</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc246">Chapter&#XA0;17&#XA0;&#XA0;The Biopython testing framework</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc247">17.1&#XA0;&#XA0;Running the tests</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc248">17.2&#XA0;&#XA0;Writing tests</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc249">17.2.1&#XA0;&#XA0;Writing a print-and-compare test</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc250">17.2.2&#XA0;&#XA0;Writing a unittest-based test</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc251">17.3&#XA0;&#XA0;Writing doctests</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc252">Chapter&#XA0;18&#XA0;&#XA0;Advanced</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc253">18.1&#XA0;&#XA0;Parser Design</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc254">18.2&#XA0;&#XA0;Substitution Matrices</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc255">18.2.1&#XA0;&#XA0;SubsMat</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc256">18.2.2&#XA0;&#XA0;FreqTable</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc257">Chapter&#XA0;19&#XA0;&#XA0;Where to go from here &#X2013; contributing to Biopython</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc258">19.1&#XA0;&#XA0;Bug Reports + Feature Requests</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc259">19.2&#XA0;&#XA0;Mailing lists and helping newcomers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc260">19.3&#XA0;&#XA0;Contributing Documentation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc261">19.4&#XA0;&#XA0;Contributing cookbook examples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc262">19.5&#XA0;&#XA0;Maintaining a distribution for a platform</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc263">19.6&#XA0;&#XA0;Contributing Unit Tests</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc264">19.7&#XA0;&#XA0;Contributing Code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc265">Chapter&#XA0;20&#XA0;&#XA0;Appendix: Useful stuff about Python</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc266">20.1&#XA0;&#XA0;What the heck is a handle?</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc267">20.1.1&#XA0;&#XA0;Creating a handle from a string</A>
</LI></UL>
</LI></UL>
</LI></UL><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter&#XA0;1</A>&#XA0;&#XA0;Introduction</H1><!--SEC END --><P>
<A NAME="chapter:introduction"></A></P><!--TOC section What is Biopython?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>&#XA0;&#XA0;What is Biopython?</H2><!--SEC END --><P>The Biopython Project is an international association of developers of freely available Python (<A HREF="http://www.python.org"><TT>http://www.python.org</TT></A>) tools for computational molecular biology. The web site <A HREF="http://www.biopython.org"><TT>http://www.biopython.org</TT></A> provides an online resource for modules, scripts, and web links for developers of Python-based software for life science research.</P><P>Basically, we just like to program in Python and want to make it as easy as possible to use Python for bioinformatics by creating high-quality, reusable modules and scripts.</P><!--TOC section What can I find in the Biopython package-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">1.2</A>&#XA0;&#XA0;What can I find in the Biopython package</H2><!--SEC END --><P>The main Biopython releases have lots of functionality, including:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The ability to parse bioinformatics files into Python utilizable data structures, including support for the following formats:<UL CLASS="itemize"><LI CLASS="li-itemize">
Blast output &#X2013; both from standalone and WWW Blast
</LI><LI CLASS="li-itemize">Clustalw
</LI><LI CLASS="li-itemize">FASTA
</LI><LI CLASS="li-itemize">GenBank
</LI><LI CLASS="li-itemize">PubMed and Medline
</LI><LI CLASS="li-itemize">ExPASy files, like Enzyme and Prosite
</LI><LI CLASS="li-itemize">SCOP, including &#X2018;dom&#X2019; and &#X2018;lin&#X2019; files
</LI><LI CLASS="li-itemize">UniGene
</LI><LI CLASS="li-itemize">SwissProt
</LI></UL></LI><LI CLASS="li-itemize">Files in the supported formats can be iterated over record by record or indexed and accessed via a Dictionary interface.</LI><LI CLASS="li-itemize">Code to deal with popular on-line bioinformatics destinations such as:<UL CLASS="itemize"><LI CLASS="li-itemize">
NCBI &#X2013; Blast, Entrez and PubMed services
</LI><LI CLASS="li-itemize">ExPASy &#X2013; Swiss-Prot and Prosite entries, as well as Prosite searches
</LI></UL></LI><LI CLASS="li-itemize">Interfaces to common bioinformatics programs such as:<UL CLASS="itemize"><LI CLASS="li-itemize">
Standalone Blast from NCBI
</LI><LI CLASS="li-itemize">Clustalw alignment program
</LI><LI CLASS="li-itemize">EMBOSS command line tools
</LI></UL></LI><LI CLASS="li-itemize">A standard sequence class that deals with sequences, ids on sequences, and sequence features.</LI><LI CLASS="li-itemize">Tools for performing common operations on sequences, such as translation, transcription and weight calculations.</LI><LI CLASS="li-itemize">Code to perform classification of data using k Nearest Neighbors, Naive Bayes or Support Vector Machines.</LI><LI CLASS="li-itemize">Code for dealing with alignments, including a standard way to create and deal with substitution matrices.</LI><LI CLASS="li-itemize">Code making it easy to split up parallelizable tasks into separate processes.</LI><LI CLASS="li-itemize">GUI-based programs to do basic sequence manipulations, translations, BLASTing, etc.</LI><LI CLASS="li-itemize">Extensive documentation and help with using the modules, including this file, on-line wiki documentation, the web site, and the mailing list.</LI><LI CLASS="li-itemize">Integration with BioSQL, a sequence database schema also supported by the BioPerl and BioJava projects.</LI></UL><P>We hope this gives you plenty of reasons to download and start using Biopython!</P><!--TOC section Installing Biopython-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">1.3</A>&#XA0;&#XA0;Installing Biopython</H2><!--SEC END --><P>All of the installation information for Biopython was separated from
this document to make it easier to keep updated.</P><P>The short version is go to our downloads page (<A HREF="http://biopython.org/wiki/Download"><TT>http://biopython.org/wiki/Download</TT></A>),
download and install the listed dependencies, then download and install Biopython.
For Windows we provide pre-compiled click-and-run installers, while for Unix and other
operating systems you must install from source as described in the included README file.
This is usually as simple as the standard commands:</P><PRE CLASS="verbatim">python setup.py build
python setup.py test
sudo python setup.py install
</PRE><P>(You can in fact skip the build and test, and go straight to the install &#X2013;
but its better to make sure everything seems to be working.)</P><P>The longer version of our installation instructions covers
installation of Python, Biopython dependencies and Biopython itself.
It is available in PDF
(<A HREF="http://biopython.org/DIST/docs/install/Installation.pdf"><TT>http://biopython.org/DIST/docs/install/Installation.pdf</TT></A>)
and HTML formats
(<A HREF="http://biopython.org/DIST/docs/install/Installation.html"><TT>http://biopython.org/DIST/docs/install/Installation.html</TT></A>).</P><!--TOC section Frequently Asked Questions (FAQ)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">1.4</A>&#XA0;&#XA0;Frequently Asked Questions (FAQ)</H2><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><EM>How do I cite Biopython in a scientific publication?</EM><BR>
 Please cite our application note, Cock <I>et al.</I> 2009,
<A HREF="http://dx.doi.org/10.1093/bioinformatics/btp163">doi:10.1093/bioinformatics/btp163</A>,
and/or one of the publications listed on our website describing specific modules within Biopython.</LI><LI CLASS="li-enumerate"><EM>How should I capitalize &#X201C;Biopython&#X201D;? Is &#X201C;BioPython&#X201D; OK?</EM><BR>
 The correct capitalization is &#X201C;Biopython&#X201D;, not &#X201C;BioPython&#X201D; (even though
that would have matched BioPerl, BioJava and BioRuby).</LI><LI CLASS="li-enumerate"><EM>How do I find out what version of Biopython I have installed?</EM><BR>
 Use this:
<PRE CLASS="verbatim">  &gt;&gt;&gt; import Bio
  &gt;&gt;&gt; print Bio.__version__
  ...
  </PRE>If the &#X201C;<CODE>import Bio</CODE>&#X201D; line fails, Biopython is not installed.
If the second line fails, your version is very out of date.
If the version string ends with a plus, you don&#X2019;t have an official
release, but a snapshot of the in development code. </LI><LI CLASS="li-enumerate"><EM>Where is the latest version of this document?</EM><BR>
 If you download a Biopython source code archive, it will include the
relevant version in both HTML and PDF formats. The latest published
version of this document (updated at each release) is online:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="http://biopython.org/DIST/docs/tutorial/Tutorial.html"><TT>http://biopython.org/DIST/docs/tutorial/Tutorial.html</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="http://biopython.org/DIST/docs/tutorial/Tutorial.pdf"><TT>http://biopython.org/DIST/docs/tutorial/Tutorial.pdf</TT></A>
</LI></UL>
If you are using the very latest unreleased code from our repository
you can find copies of the in-progress tutorial here:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="http://biopython.org/DIST/docs/tutorial/Tutorial-dev.html"><TT>http://biopython.org/DIST/docs/tutorial/Tutorial-dev.html</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="http://biopython.org/DIST/docs/tutorial/Tutorial-dev.pdf"><TT>http://biopython.org/DIST/docs/tutorial/Tutorial-dev.pdf</TT></A>
</LI></UL></LI><LI CLASS="li-enumerate"><EM>Which &#X201C;Numerical Python&#X201D; do I need?</EM><BR>
 For Biopython 1.48 or earlier, you needed the old Numeric module.
For Biopython 1.49 onwards, you need the newer NumPy instead.
Both Numeric and NumPy can be installed on the same machine fine.
See also: <A HREF="http://numpy.scipy.org/"><TT>http://numpy.scipy.org/</TT></A></LI><LI CLASS="li-enumerate"><EM>Why is the</EM> <CODE>Seq</CODE> <EM>object missing the (back) transcription &amp; translation methods described in this Tutorial?</EM><BR>
 You need Biopython 1.49 or later. Alternatively, use the <CODE>Bio.Seq</CODE> module functions described in Section&#XA0;<A HREF="#sec:seq-module-functions">3.14</A>.</LI><LI CLASS="li-enumerate"><EM>Why is the</EM> <CODE>Seq</CODE> <EM>object missing the upper &amp; lower methods described in this Tutorial?</EM><BR>
 You need Biopython 1.53 or later. Alternatively, use <CODE>str(my_seq).upper()</CODE> to get an upper case string.
If you need a Seq object, try <CODE>Seq(str(my_seq).upper())</CODE> but be careful about blindly re-using the same alphabet.</LI><LI CLASS="li-enumerate"><EM>Why does&#X2019;t the</EM> <CODE>Seq</CODE> <EM>object translation method support the</EM> <CODE>cds</CODE> <EM>option described in this Tutorial?</EM><BR>
 You need Biopython 1.51 or later.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.SeqIO</CODE> <EM>work? It imports fine but there is no parse function etc.</EM><BR>
 You need Biopython 1.43 or later. Older versions did contain some related code under the <CODE>Bio.SeqIO</CODE> name which has since been removed - and this is why the import &#X201C;works&#X201D;.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.SeqIO.read()</CODE> <EM>work? The module imports fine but there is no read function!</EM><BR>
 You need Biopython 1.45 or later. Or, use <TT>Bio.SeqIO.parse(...).next()</TT> instead.</LI><LI CLASS="li-enumerate"><EM>Why isn&#X2019;t</EM> <CODE>Bio.AlignIO</CODE> <EM>present? The module import fails!</EM><BR>
 You need Biopython 1.46 or later.</LI><LI CLASS="li-enumerate"><EM>What file formats do</EM> <CODE>Bio.SeqIO</CODE> <EM>and</EM> <CODE>Bio.AlignIO</CODE> <EM>read and write?</EM><BR>
 Check the built in docstrings (<TT>from Bio import SeqIO</TT>, then <TT>help(SeqIO)</TT>), or see <A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A> and <A HREF="http://biopython.org/wiki/AlignIO"><TT>http://biopython.org/wiki/AlignIO</TT></A> on the wiki for the latest listing.</LI><LI CLASS="li-enumerate"><EM>Why don&#X2019;t the </EM> <CODE>Bio.SeqIO</CODE> <EM>and</EM> <CODE>Bio.AlignIO</CODE> <EM>input functions let me provide a sequence alphabet?</EM><BR>
 You need Biopython 1.49 or later.</LI><LI CLASS="li-enumerate"><EM>Why won&#X2019;t the </EM> <CODE>Bio.SeqIO</CODE> <EM>and</EM> <CODE>Bio.AlignIO</CODE> <EM>functions</EM> <CODE>parse</CODE><EM>,</EM> <CODE>read</CODE> <EM>and</EM> <CODE>write</CODE> <EM>take filenames? They insist on handles!</EM><BR>
 You need Biopython 1.54 or later, or just use handles explicitly (see Section&#XA0;<A HREF="#sec:appendix-handles">20.1</A>).
It is especially important to remember to close output handles explicitly after writing your data.</LI><LI CLASS="li-enumerate"><EM>Why won&#X2019;t the </EM> <CODE>Bio.SeqIO.write()</CODE> <EM>and</EM> <CODE>Bio.AlignIO.write()</CODE> <EM>functions accept a single record or alignment? They insist on a list or iterator!</EM><BR>
 You need Biopython 1.54 or later, or just wrap the item with <CODE>[...]</CODE> to create a list of one element.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>str(...)</CODE> <EM>give me the full sequence of a</EM> <CODE>Seq</CODE> <EM>object?</EM><BR>
 You need Biopython 1.45 or later. Alternatively, rather than <CODE>str(my_seq)</CODE>, use <CODE>my_seq.tostring()</CODE> (which will also work on recent versions of Biopython).</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.Blast</CODE> <EM>work with the latest plain text NCBI blast output?</EM><BR>
 The NCBI keep tweaking the plain text output from the BLAST tools, and keeping our parser up to date is/was an ongoing struggle.
If you aren&#X2019;t using the latest version of Biopython, you could try upgrading.
However, we (and the NCBI) recommend you use the XML output instead, which is designed to be read by a computer program.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.Entrez.read()</CODE> <EM>work? The module imports fine but there is no read function!</EM><BR>
 You need Biopython 1.46 or later.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.Entrez.parse()</CODE> <EM>work? The module imports fine but there is no parse function!</EM><BR>
 You need Biopython 1.52 or later.</LI><LI CLASS="li-enumerate"><EM>Why has my script using</EM> <CODE>Bio.Entrez.efetch()</CODE> <EM>stopped working?</EM><BR>
 This could be due to NCBI changes in February 2012 introducing EFetch 2.0.
First, they changed the default return modes - you probably want to add <CODE>retmode="text"</CODE> to
your call.
Second, they are now stricter about how to provide a list of IDs &#X2013; Biopython 1.59 onwards
turns a list into a comma separated string automatically.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.PDB.MMCIFParser</CODE> <EM>work? I see an import error about</EM> <CODE>MMCIFlex</CODE><BR>
 From Biopython 1.42 to 1.59, the underlying <CODE>Bio.PDB.mmCIF.MMCIFlex</CODE> module
was not installed by default. It required a third party tool called flex
(fast lexical analyzer generator). This should work with Biopython 1.60 onwards.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.Blast.NCBIWWW.qblast()</CODE> <EM>give the same results as the NCBI BLAST website?</EM><BR>
 You need to specify the same options &#X2013; the NCBI often adjust the default settings on the website,
and they do not match the QBLAST defaults anymore. Check things like the gap penalties and expectation threshold.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.Blast.NCBIXML.read()</CODE> <EM>work? The module imports but there is no read function!</EM><BR>
 You need Biopython 1.50 or later. Or, use <TT>Bio.Blast.NCBIXML.parse(...).next()</TT> instead.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t my</EM> <CODE>SeqRecord</CODE> <EM>object have a</EM> <CODE>letter_annotations</CODE> <EM>attribute?</EM><BR>
 Per-letter-annotation support was added in Biopython 1.50.</LI><LI CLASS="li-enumerate"><EM>Why can&#X2019;t I slice my</EM> <CODE>SeqRecord</CODE> <EM>to get a sub-record?</EM><BR>
 You need Biopython 1.50 or later.</LI><LI CLASS="li-enumerate"><EM>Why can&#X2019;t I add</EM> <CODE>SeqRecord</CODE> <EM>objects together?</EM><BR>
 You need Biopython 1.53 or later.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.SeqIO.convert()</CODE> <EM>or</EM> <CODE>Bio.AlignIO.convert()</CODE> <EM>work? The modules import fine but there is no convert function!</EM><BR>
 You need Biopython 1.52 or later. Alternatively, combine the <CODE>parse</CODE> and <CODE>write</CODE>
functions as described in this tutorial (see Sections&#XA0;<A HREF="#sec:SeqIO-conversion">5.5.2</A> and&#XA0;<A HREF="#sec:converting-alignments">6.2.1</A>).</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.SeqIO.index()</CODE> <EM>work? The module imports fine but there is no index function!</EM><BR>
 You need Biopython 1.52 or later.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.SeqIO.index_db()</CODE> <EM>work? The module imports fine but there is no </EM><EM><TT>index_db</TT></EM><EM> function!</EM><BR>
 You need Biopython 1.57 or later (and a Python with SQLite3 support).</LI><LI CLASS="li-enumerate"><EM>Where is the</EM> <CODE>MultipleSeqAlignment</CODE> <EM>object? The</EM> <CODE>Bio.Align</CODE> <EM>module imports fine but this class isn&#X2019;t there!</EM><BR>
 You need Biopython 1.54 or later. Alternatively, the older <CODE>Bio.Align.Generic.Alignment</CODE> class supports some of its functionality, but using this is now discouraged.</LI><LI CLASS="li-enumerate"><EM>Why can&#X2019;t I run command line tools directly from the application wrappers?</EM><BR>
 You need Biopython 1.55 or later. Alternatively, use the Python <CODE>subprocess</CODE> module directly.</LI><LI CLASS="li-enumerate"><EM>I looked in a directory for code, but I couldn&#X2019;t find the code that does something. Where&#X2019;s it hidden?</EM><BR>
 One thing to know is that we put code in <CODE>__init__.py</CODE> files. If you are not used to looking for code in this file this can be confusing. The reason we do this is to make the imports easier for users. For instance, instead of having to do a &#X201C;repetitive&#X201D; import like <CODE>from Bio.GenBank import GenBank</CODE>, you can just use <CODE>from Bio import GenBank</CODE>.</LI><LI CLASS="li-enumerate"><EM>Why does the code from CVS seem out of date?</EM><BR>
 In late September 2009, just after the release of Biopython 1.52, we switched from using CVS to git, a distributed version control system. The old CVS server will remain available as a static and read only backup, but if you want to grab the latest code, you&#X2019;ll need to use git instead. See our website for more details.
</LI></OL><P>For more general questions, the Python FAQ pages <A HREF="http://www.python.org/doc/faq/"><TT>http://www.python.org/doc/faq/</TT></A> may be useful.</P><!--TOC chapter Quick Start &#X2013; What can you do with Biopython?-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc6">Chapter&#XA0;2</A>&#XA0;&#XA0;Quick Start &#X2013; What can you do with Biopython?</H1><!--SEC END --><P>
<A NAME="chapter:quick-start"></A></P><P>This section is designed to get you started quickly with Biopython, and to give a general overview of what is available and how to use it. All of the examples in this section assume that you have some general working knowledge of Python, and that you have successfully installed Biopython on your system. If you think you need to brush up on your Python, the main Python web site provides quite a bit of free documentation to get started with (<A HREF="http://www.python.org/doc/"><TT>http://www.python.org/doc/</TT></A>).</P><P>Since much biological work on the computer involves connecting with databases on the internet, some of the examples will also require a working internet connection in order to run.</P><P>Now that that is all out of the way, let&#X2019;s get into what we can do with Biopython.</P><!--TOC section General overview of what Biopython provides-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">2.1</A>&#XA0;&#XA0;General overview of what Biopython provides</H2><!--SEC END --><P>As mentioned in the introduction, Biopython is a set of libraries to provide the ability to deal with &#X201C;things&#X201D; of interest to biologists working on the computer. In general this means that you will need to have at least some programming experience (in Python, of course!) or at least an interest in learning to program. Biopython&#X2019;s job is to make your job easier as a programmer by supplying reusable libraries so that you can focus on answering your specific question of interest, instead of focusing on the internals of parsing a particular file format (of course, if you want to help by writing a parser that doesn&#X2019;t exist and contributing it to Biopython, please go ahead!). So Biopython&#X2019;s job is to make you happy!</P><P>One thing to note about Biopython is that it often provides multiple ways of &#X201C;doing the same thing.&#X201D; Things have improved in recent releases, but this can still be frustrating as in Python there should ideally be one right way to do something. However, this can also be a real benefit because it gives you lots of flexibility and control over the libraries. The tutorial helps to show you the common or easy ways to do things so that you can just make things work. To learn more about the alternative possibilities, look in the Cookbook (Chapter&#XA0;<A HREF="#chapter:cookbook">16</A>, this has some cools tricks and tips), the Advanced section (Chapter&#XA0;<A HREF="#chapter:advanced">18</A>), the built in &#X201C;docstrings&#X201D; (via the Python help command, or the <A HREF="http://biopython.org/DIST/docs/api/">API documentation</A>) or ultimately the code itself.</P><!--TOC section Working with sequences-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">2.2</A>&#XA0;&#XA0;Working with sequences</H2><!--SEC END --><P>
<A NAME="sec:sequences"></A></P><P>Disputably (of course!), the central object in bioinformatics is the sequence. Thus, we&#X2019;ll start with a quick introduction to the Biopython mechanisms for dealing with sequences, the <CODE>Seq</CODE> object, which we&#X2019;ll discuss in more detail in Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A>.</P><P>Most of the time when we think about sequences we have in my mind a string of letters like &#X2018;<CODE>AGTACACTGGT</CODE>&#X2019;. You can create such <CODE>Seq</CODE> object with this sequence as follows - the &#X201C;&gt;&gt;&gt;&#X201D; represents the Python prompt followed by what you would type in:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; my_seq = Seq("AGTACACTGGT")
&gt;&gt;&gt; my_seq
Seq('AGTACACTGGT', Alphabet())
&gt;&gt;&gt; print my_seq
AGTACACTGGT
&gt;&gt;&gt; my_seq.alphabet
Alphabet()
</PRE><P>What we have here is a sequence object with a <EM>generic</EM> alphabet - reflecting the fact we have <EM>not</EM> specified if this is a DNA or protein sequence (okay, a protein with a lot of Alanines, Glycines, Cysteines and Threonines!). We&#X2019;ll talk more about alphabets in Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A>.</P><P>In addition to having an alphabet, the <CODE>Seq</CODE> object differs from the Python string in the methods it supports. You can&#X2019;t do this with a plain string:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq
Seq('AGTACACTGGT', Alphabet())
&gt;&gt;&gt; my_seq.complement()
Seq('TCATGTGACCA', Alphabet())
&gt;&gt;&gt; my_seq.reverse_complement()
Seq('ACCAGTGTACT', Alphabet())
</PRE><P>The next most important class is the <CODE>SeqRecord</CODE> or Sequence Record. This holds a sequence (as a <CODE>Seq</CODE> object) with additional annotation including an identifier, name and description. The <CODE>Bio.SeqIO</CODE> module for reading and writing sequence file formats works with <CODE>SeqRecord</CODE> objects, which will be introduced below and covered in more detail by Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>.</P><P>This covers the basic features and uses of the Biopython sequence class.
Now that you&#X2019;ve got some idea of what it is like to interact with the Biopython libraries, it&#X2019;s time to delve into the fun, fun world of dealing with biological file formats!</P><!--TOC section A usage example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">2.3</A>&#XA0;&#XA0;A usage example</H2><!--SEC END --><P>
<A NAME="sec:orchids"></A></P><P>Before we jump right into parsers and everything else to do with Biopython, let&#X2019;s set up an example to motivate everything we do and make life more interesting. After all, if there wasn&#X2019;t any biology in this tutorial, why would you want you read it?</P><P>Since I love plants, I think we&#X2019;re just going to have to have a plant based example (sorry to all the fans of other organisms out there!). Having just completed a recent trip to our local greenhouse, we&#X2019;ve suddenly developed an incredible obsession with Lady Slipper Orchids (if you wonder why, have a look at some <A HREF="http://www.flickr.com/search/?q=lady+slipper+orchid&s=int&z=t">Lady Slipper Orchids photos on Flickr</A>, or try a <A HREF="http://images.google.com/images?q=lady%20slipper%20orchid">Google Image Search</A>).</P><P>Of course, orchids are not only beautiful to look at, they are also extremely interesting for people studying evolution and systematics. So let&#X2019;s suppose we&#X2019;re thinking about writing a funding proposal to do a molecular study of Lady Slipper evolution, and would like to see what kind of research has already been done and how we can add to that.</P><P>After a little bit of reading up we discover that the Lady Slipper Orchids are in the Orchidaceae family and the Cypripedioideae sub-family and are made up of 5 genera: <EM>Cypripedium</EM>, <EM>Paphiopedilum</EM>, <EM>Phragmipedium</EM>, <EM>Selenipedium</EM> and <EM>Mexipedium</EM>.</P><P>That gives us enough to get started delving for more information. So, let&#X2019;s look at how the Biopython tools can help us. We&#X2019;ll start with sequence parsing in Section&#XA0;<A HREF="#sec:sequence-parsing">2.4</A>, but the orchids will be back later on as well - for example we&#X2019;ll search PubMed for papers about orchids and extract sequence data from GenBank in Chapter&#XA0;<A HREF="#chapter:entrez">8</A>, extract data from Swiss-Prot from certain orchid proteins in Chapter&#XA0;<A HREF="#chapter:swiss_prot">9</A>, and work with ClustalW multiple sequence alignments of orchid proteins in Section&#XA0;<A HREF="#sec:align_clustal">6.4.1</A>.</P><!--TOC section Parsing sequence file formats-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">2.4</A>&#XA0;&#XA0;Parsing sequence file formats</H2><!--SEC END --><P>
<A NAME="sec:sequence-parsing"></A></P><P>A large part of much bioinformatics work involves dealing with the many types of file formats designed to hold biological data. These files are loaded with interesting biological data, and a special challenge is parsing these files into a format so that you can manipulate them with some kind of programming language. However the task of parsing these files can be frustrated by the fact that the formats can change quite regularly, and that formats may contain small subtleties which can break even the most well designed parsers.</P><P>We are now going to briefly introduce the <CODE>Bio.SeqIO</CODE> module &#X2013; you can find out more in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>. We&#X2019;ll start with an online search for our friends, the lady slipper orchids. To keep this introduction simple, we&#X2019;re just using the NCBI website by hand. Let&#X2019;s just take a look through the nucleotide databases at NCBI, using an Entrez online search (<A HREF="http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide"><TT>http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide</TT></A>) for everything mentioning the text Cypripedioideae (this is the subfamily of lady slipper orchids). </P><P>When this tutorial was originally written, this search gave us only 94 hits, which we saved as a FASTA formatted text file and as a GenBank formatted text file (files <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta"><TT>ls_orchid.fasta</TT></A> and <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk"><TT>ls_orchid.gbk</TT></A>, also included with the Biopython source code under <TT>docs/tutorial/examples/</TT>).</P><P>If you run the search today, you&#X2019;ll get hundreds of results! When following the tutorial, if you want to see the same list of genes, just download the two files above or copy them from <CODE>docs/examples/</CODE> in the Biopython source code. In Section&#XA0;<A HREF="#sec:connecting-with-biological-databases">2.5</A> we will look at how to do a search like this from within Python.</P><!--TOC subsection Simple FASTA parsing example-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">2.4.1</A>&#XA0;&#XA0;Simple FASTA parsing example</H3><!--SEC END --><P>
<A NAME="sec:fasta-parsing"></A></P><P>If you open the lady slipper orchids FASTA file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta"><TT>ls_orchid.fasta</TT></A> in your favourite text editor, you&#X2019;ll see that the file starts like this:</P><PRE CLASS="verbatim">&gt;gi|2765658|emb|Z78533.1|CIZ78533 C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA
CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAACGATCGAGTG
AATCCGGAGGACCGGTGTACTCAGCTCACCGGGGGCATTGCTCCCGTGGTGACCCTGATTTGTTGTTGGG
...
</PRE><P>It contains 94 records, each has a line starting with &#X201C;&gt;&#X201D; (greater-than symbol) followed by the sequence on one or more lines. Now try this in Python:</P><PRE CLASS="verbatim">from Bio import SeqIO
for seq_record in SeqIO.parse("ls_orchid.fasta", "fasta"):
    print seq_record.id
    print repr(seq_record.seq)
    print len(seq_record)
</PRE><P>You should get something like this on your screen:</P><PRE CLASS="verbatim">gi|2765658|emb|Z78533.1|CIZ78533
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', SingleLetterAlphabet())
740
...
gi|2765564|emb|Z78439.1|PBZ78439
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACT...GCC', SingleLetterAlphabet())
592
</PRE><P>Notice that the FASTA format does not specify the alphabet, so <CODE>Bio.SeqIO</CODE> has defaulted to the rather generic <CODE>SingleLetterAlphabet()</CODE> rather than something DNA specific.</P><!--TOC subsection Simple GenBank parsing example-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">2.4.2</A>&#XA0;&#XA0;Simple GenBank parsing example</H3><!--SEC END --><P>Now let&#X2019;s load the GenBank file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk"><TT>ls_orchid.gbk</TT></A> instead - notice that the code to do this is almost identical to the snippet used above for the FASTA file - the only difference is we change the filename and the format string:</P><PRE CLASS="verbatim">from Bio import SeqIO
for seq_record in SeqIO.parse("ls_orchid.gbk", "genbank"):
    print seq_record.id
    print repr(seq_record.seq)
    print len(seq_record)
</PRE><P>This should give:</P><PRE CLASS="verbatim">Z78533.1
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', IUPACAmbiguousDNA())
740
...
Z78439.1
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACT...GCC', IUPACAmbiguousDNA())
592
</PRE><P>This time <CODE>Bio.SeqIO</CODE> has been able to choose a sensible alphabet, IUPAC Ambiguous DNA. You&#X2019;ll also notice that a shorter string has been used as the <CODE>seq_record.id</CODE> in this case.</P><!--TOC subsection I love parsing &#X2013; please don&#X2019;t stop talking about it!-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">2.4.3</A>&#XA0;&#XA0;I love parsing &#X2013; please don&#X2019;t stop talking about it!</H3><!--SEC END --><P>Biopython has a lot of parsers, and each has its own little special niches based on the sequence format it is parsing and all of that. Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A> covers <CODE>Bio.SeqIO</CODE> in more detail, while Chapter&#XA0;<A HREF="#chapter:Bio.AlignIO">6</A> introduces <CODE>Bio.AlignIO</CODE> for sequence alignments.</P><P>While the most popular file formats have parsers integrated into <CODE>Bio.SeqIO</CODE> and/or <CODE>Bio.AlignIO</CODE>, for some of the rarer and unloved file formats there is either no parser at all, or an old parser which has not been linked in yet.
Please also check the wiki pages <A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A> and <A HREF="http://biopython.org/wiki/AlignIO"><TT>http://biopython.org/wiki/AlignIO</TT></A> for the latest information, or ask on the mailing list. The wiki pages should include an up to date list of supported file types, and some additional examples.</P><P>The next place to look for information about specific parsers and how to do cool things with them is in the Cookbook (Chapter&#XA0;<A HREF="#chapter:cookbook">16</A> of this Tutorial). If you don&#X2019;t find the information you are looking for, please consider helping out your poor overworked documentors and submitting a cookbook entry about it! (once you figure out how to do it, that is!)</P><!--TOC section Connecting with biological databases-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc14">2.5</A>&#XA0;&#XA0;Connecting with biological databases</H2><!--SEC END --><P>
<A NAME="sec:connecting-with-biological-databases"></A></P><P>One of the very common things that you need to do in bioinformatics is extract information from biological databases. It can be quite tedious to access these databases manually, especially if you have a lot of repetitive work to do. Biopython attempts to save you time and energy by making some on-line databases available from Python scripts. Currently, Biopython has code to extract information from the following databases:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="http://www.ncbi.nlm.nih.gov/Entrez/">Entrez</A> (and <A HREF="http://www.ncbi.nlm.nih.gov/PubMed/">PubMed</A>) from the NCBI &#X2013; See Chapter&#XA0;<A HREF="#chapter:entrez">8</A>.
</LI><LI CLASS="li-itemize"><A HREF="http://www.expasy.org/">ExPASy</A> &#X2013; See Chapter&#XA0;<A HREF="#chapter:swiss_prot">9</A>.
</LI><LI CLASS="li-itemize"><A HREF="http://scop.mrc-lmb.cam.ac.uk/scop/">SCOP</A> &#X2013; See the <CODE>Bio.SCOP.search()</CODE> function.
</LI></UL><P>The code in these modules basically makes it easy to write Python code that interact with the CGI scripts on these pages, so that you can get results in an easy to deal with format. In some cases, the results can be tightly integrated with the Biopython parsers to make it even easier to extract information.</P><!--TOC section What to do next-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc15">2.6</A>&#XA0;&#XA0;What to do next</H2><!--SEC END --><P>Now that you&#X2019;ve made it this far, you hopefully have a good understanding of the basics of Biopython and are ready to start using it for doing useful work. The best thing to do now is finish reading this tutorial, and then if you want start snooping around in the source code, and looking at the automatically generated documentation.</P><P>Once you get a picture of what you want to do, and what libraries in Biopython will do it, you should take a peak at the Cookbook (Chapter&#XA0;<A HREF="#chapter:cookbook">16</A>), which may have example code to do something similar to what you want to do.</P><P>If you know what you want to do, but can&#X2019;t figure out how to do it, please feel free to post questions to the main Biopython list (see <A HREF="http://biopython.org/wiki/Mailing_lists"><TT>http://biopython.org/wiki/Mailing_lists</TT></A>). This will not only help us answer your question, it will also allow us to improve the documentation so it can help the next person do what you want to do.</P><P>Enjoy the code!</P><!--TOC chapter Sequence objects-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc16">Chapter&#XA0;3</A>&#XA0;&#XA0;Sequence objects</H1><!--SEC END --><P>
<A NAME="chapter:Bio.Seq"></A></P><P>Biological sequences are arguably the central object in Bioinformatics, and in this chapter we&#X2019;ll introduce the Biopython mechanism for dealing with sequences, the <CODE>Seq</CODE> object.
Chapter&#XA0;<A HREF="#chapter:SeqRecord">4</A> will introduce the related <CODE>SeqRecord</CODE> object, which combines the sequence information with any annotation, used again in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A> for Sequence Input/Output.</P><P>Sequences are essentially strings of letters like <CODE>AGTACACTGGT</CODE>, which seems very natural since this is the most common way that sequences are seen in biological file formats.</P><P>There are two important differences between <CODE>Seq</CODE> objects and standard Python strings.
First of all, they have different methods. Although the <CODE>Seq</CODE> object supports many of the same methods as a plain string, its <CODE>translate()</CODE> method differs by doing biological translation, and there are also additional biologically relevant methods like <CODE>reverse_complement()</CODE>.
Secondly, the <CODE>Seq</CODE> object has an important attribute, <CODE>alphabet</CODE>, which is an object describing what the individual characters making up the sequence string &#X201C;mean&#X201D;, and how they should be interpreted. For example, is <CODE>AGTACACTGGT</CODE> a DNA sequence, or just a protein sequence that happens to be rich in Alanines, Glycines, Cysteines
and Threonines?</P><!--TOC section Sequences and Alphabets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc17">3.1</A>&#XA0;&#XA0;Sequences and Alphabets</H2><!--SEC END --><P>The alphabet object is perhaps the important thing that makes the <CODE>Seq</CODE> object more than just a string. The currently available alphabets for Biopython are defined in the <CODE>Bio.Alphabet</CODE> module. We&#X2019;ll use the IUPAC alphabets (<A HREF="http://www.chem.qmw.ac.uk/iupac/"><TT>http://www.chem.qmw.ac.uk/iupac/</TT></A>) here to deal with some of our favorite objects: DNA, RNA and Proteins.</P><P><CODE>Bio.Alphabet.IUPAC</CODE> provides basic definitions for proteins, DNA and RNA, but additionally provides the ability to extend and customize the basic definitions. For instance, for proteins, there is a basic IUPACProtein class, but there is an additional ExtendedIUPACProtein class providing for the additional elements &#X201C;U&#X201D; (or &#X201C;Sec&#X201D; for selenocysteine) and &#X201C;O&#X201D; (or &#X201C;Pyl&#X201D; for pyrrolysine), plus the ambiguous symbols &#X201C;B&#X201D; (or &#X201C;Asx&#X201D; for asparagine or aspartic acid), &#X201C;Z&#X201D; (or &#X201C;Glx&#X201D; for glutamine or glutamic acid), &#X201C;J&#X201D; (or &#X201C;Xle&#X201D; for leucine isoleucine) and &#X201C;X&#X201D; (or &#X201C;Xxx&#X201D; for an unknown amino acid). For DNA you&#X2019;ve got choices of IUPACUnambiguousDNA, which provides for just the basic letters, IUPACAmbiguousDNA (which provides for ambiguity letters for every possible situation) and ExtendedIUPACDNA, which allows letters for modified bases. Similarly, RNA can be represented by IUPACAmbiguousRNA or IUPACUnambiguousRNA.</P><P>The advantages of having an alphabet class are two fold. First, this gives an idea of the type of information the Seq object contains. Secondly, this provides a means of constraining the information, as a means of type checking.</P><P>Now that we know what we are dealing with, let&#X2019;s look at how to utilize this class to do interesting work.
You can create an ambiguous sequence with the default generic alphabet like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; my_seq = Seq("AGTACACTGGT")
&gt;&gt;&gt; my_seq
Seq('AGTACACTGGT', Alphabet())
&gt;&gt;&gt; my_seq.alphabet
Alphabet()
</PRE><P>However, where possible you should specify the alphabet explicitly when creating your sequence objects - in this case an unambiguous DNA alphabet object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq("AGTACACTGGT", IUPAC.unambiguous_dna)
&gt;&gt;&gt; my_seq
Seq('AGTACACTGGT', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq.alphabet
IUPACUnambiguousDNA()
</PRE><P>Unless of course, this really is an amino acid sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_prot = Seq("AGTACACTGGT", IUPAC.protein)
&gt;&gt;&gt; my_prot
Seq('AGTACACTGGT', IUPACProtein())
&gt;&gt;&gt; my_prot.alphabet
IUPACProtein()
</PRE><!--TOC section Sequences act like strings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc18">3.2</A>&#XA0;&#XA0;Sequences act like strings</H2><!--SEC END --><P>In many ways, we can deal with Seq objects as if they were normal Python strings, for example getting the length, or iterating over the elements:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq("GATCG", IUPAC.unambiguous_dna)
&gt;&gt;&gt; for index, letter in enumerate(my_seq):
...     print index, letter
0 G
1 A
2 T
3 C
4 G
&gt;&gt;&gt; print len(my_seq)
5
</PRE><P>You can access elements of the sequence in the same way as for strings (but remember, Python counts from zero!):</P><PRE CLASS="verbatim">&gt;&gt;&gt; print my_seq[0] #first letter
G
&gt;&gt;&gt; print my_seq[2] #third letter
T
&gt;&gt;&gt; print my_seq[-1] #last letter
G
</PRE><P>The <CODE>Seq</CODE> object has a <CODE>.count()</CODE> method, just like a string.
Note that this means that like a Python string, this gives a
<EM>non-overlapping</EM> count:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; "AAAA".count("AA")
2
&gt;&gt;&gt; Seq("AAAA").count("AA")
2
</PRE><P>For some biological uses, you may actually want an overlapping count
(i.e. 3 in this trivial example). When searching for single letters, this
makes no difference:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPAC.unambiguous_dna)
&gt;&gt;&gt; len(my_seq)
32
&gt;&gt;&gt; my_seq.count("G")
9
&gt;&gt;&gt; 100 * float(my_seq.count("G") + my_seq.count("C")) / len(my_seq)
46.875
</PRE><P>While you could use the above snippet of code to calculate a GC%, note that the <CODE>Bio.SeqUtils</CODE> module has several GC functions already built. For example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; from Bio.SeqUtils import GC
&gt;&gt;&gt; my_seq = Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPAC.unambiguous_dna)
&gt;&gt;&gt; GC(my_seq)
46.875
</PRE><P>Note that using the <CODE>Bio.SeqUtils.GC()</CODE> function should automatically cope with mixed case sequences and the ambiguous nucleotide S which means G or C.</P><P>Also note that just like a normal Python string, the <CODE>Seq</CODE> object is in some ways &#X201C;read-only&#X201D;. If you need to edit your sequence, for example simulating a point mutation, look at the Section&#XA0;<A HREF="#sec:mutable-seq">3.12</A> below which talks about the <CODE>MutableSeq</CODE> object.</P><!--TOC section Slicing a sequence-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">3.3</A>&#XA0;&#XA0;Slicing a sequence</H2><!--SEC END --><P>A more complicated example, let&#X2019;s get a slice of the sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq("GATCGATGGGCCTATATAGGATCGAAAATCGC", IUPAC.unambiguous_dna)
&gt;&gt;&gt; my_seq[4:12]
Seq('GATGGGCC', IUPACUnambiguousDNA())
</PRE><P>Two things are interesting to note. First, this follows the normal conventions for Python strings. So the first element of the sequence is 0 (which is normal for computer science, but not so normal for biology). When you do a slice the first item is included (i.e.&#XA0;4 in this case) and the last is excluded (12 in this case), which is the way things work in Python, but of course not necessarily the way everyone in the world would expect. The main goal is to stay consistent with what Python does.</P><P>The second thing to notice is that the slice is performed on the sequence data string, but the new object produced is another <CODE>Seq</CODE> object which retains the alphabet information from the original <CODE>Seq</CODE> object.</P><P>Also like a Python string, you can do slices with a start, stop and <EM>stride</EM> (the step size, which defaults to one). For example, we can get the first, second and third codon positions of this DNA sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq[0::3]
Seq('GCTGTAGTAAG', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq[1::3]
Seq('AGGCATGCATC', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq[2::3]
Seq('TAGCTAAGAC', IUPACUnambiguousDNA())
</PRE><P>Another stride trick you might have seen with a Python string is the use of a -1 stride to reverse the string. You can do this with a <CODE>Seq</CODE> object too:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq[::-1]
Seq('CGCTAAAAGCTAGGATATATCCGGGTAGCTAG', IUPACUnambiguousDNA())
</PRE><!--TOC section Turning Seq objects into strings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc20">3.4</A>&#XA0;&#XA0;Turning Seq objects into strings</H2><!--SEC END --><P>
<A NAME="sec:seq-to-string"></A></P><P>If you really do just need a plain string, for example to write to a file, or insert into a database, then this is very easy to get:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; str(my_seq)
'GATCGATGGGCCTATATAGGATCGAAAATCGC'
</PRE><P>Since calling <CODE>str()</CODE> on a <CODE>Seq</CODE> object returns the full sequence as a string,
you often don&#X2019;t actually have to do this conversion explicitly.
Python does this automatically with a print statement:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print my_seq
GATCGATGGGCCTATATAGGATCGAAAATCGC
</PRE><P>You can also use the <CODE>Seq</CODE> object directly with a <CODE>%s</CODE> placeholder when using the Python string formatting or interpolation operator (<CODE>%</CODE>):
</P><PRE CLASS="verbatim">&gt;&gt;&gt; fasta_format_string = "&gt;Name\n%s\n" % my_seq
&gt;&gt;&gt; print fasta_format_string
&gt;Name
GATCGATGGGCCTATATAGGATCGAAAATCGC
&lt;BLANKLINE&gt;
</PRE><P>This line of code constructs a simple FASTA format record (without worrying about line wrapping).
Section&#XA0;<A HREF="#sec:SeqRecord-format">4.6</A> describes a neat way to get a FASTA formatted
string from a <CODE>SeqRecord</CODE> object, while the more general topic of reading and
writing FASTA format sequence files is covered in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>.</P><P><EM>NOTE:</EM> If you are using Biopython 1.44 or older, using <CODE>str(my_seq)</CODE>
will give just a truncated representation. Instead use <CODE>my_seq.tostring()</CODE>
(which is still available in the current Biopython releases for backwards compatibility):</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq.tostring()
'GATCGATGGGCCTATATAGGATCGAAAATCGC'
</PRE><!--TOC section Concatenating or adding sequences-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">3.5</A>&#XA0;&#XA0;Concatenating or adding sequences</H2><!--SEC END --><P>Naturally, you can in principle add any two Seq objects together - just like you can with Python strings to concatenate them. However, you can&#X2019;t add sequences with incompatible alphabets, such as a protein sequence and a DNA sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; protein_seq = Seq("EVRNAK", IUPAC.protein)
&gt;&gt;&gt; dna_seq = Seq("ACGT", IUPAC.unambiguous_dna)
&gt;&gt;&gt; protein_seq + dna_seq
Traceback (most recent call last):
...
TypeError: Incompatible alphabets IUPACProtein() and IUPACUnambiguousDNA()
</PRE><P>If you <EM>really</EM> wanted to do this, you&#X2019;d have to first give both sequences generic alphabets:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Alphabet import generic_alphabet
&gt;&gt;&gt; protein_seq.alphabet = generic_alphabet
&gt;&gt;&gt; dna_seq.alphabet = generic_alphabet
&gt;&gt;&gt; protein_seq + dna_seq
Seq('EVRNAKACGT', Alphabet())
</PRE><P>Here is an example of adding a generic nucleotide sequence to an unambiguous IUPAC DNA sequence, resulting in an ambiguous nucleotide sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import generic_nucleotide
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; nuc_seq = Seq("GATCGATGC", generic_nucleotide)
&gt;&gt;&gt; dna_seq = Seq("ACGT", IUPAC.unambiguous_dna)
&gt;&gt;&gt; nuc_seq
Seq('GATCGATGC', NucleotideAlphabet())
&gt;&gt;&gt; dna_seq
Seq('ACGT', IUPACUnambiguousDNA())
&gt;&gt;&gt; nuc_seq + dna_seq
Seq('GATCGATGCACGT', NucleotideAlphabet())
</PRE><!--TOC section Changing case-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc22">3.6</A>&#XA0;&#XA0;Changing case</H2><!--SEC END --><P>Python strings have very useful <CODE>upper</CODE> and <CODE>lower</CODE> methods for changing the case.
As of Biopython 1.53, the <CODE>Seq</CODE> object gained similar methods which are alphabet aware.
For example,</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import generic_dna
&gt;&gt;&gt; dna_seq = Seq("acgtACGT", generic_dna)
&gt;&gt;&gt; dna_seq
Seq('acgtACGT', DNAAlphabet())
&gt;&gt;&gt; dna_seq.upper()
Seq('ACGTACGT', DNAAlphabet())
&gt;&gt;&gt; dna_seq.lower()
Seq('acgtacgt', DNAAlphabet())
</PRE><P>These are useful for doing case insensitive matching:</P><PRE CLASS="verbatim">&gt;&gt;&gt; "GTAC" in dna_seq
False
&gt;&gt;&gt; "GTAC" in dna_seq.upper()
True
</PRE><P>Note that strictly speaking the IUPAC alphabets are for upper case
sequences only, thus:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; dna_seq = Seq("ACGT", IUPAC.unambiguous_dna)
&gt;&gt;&gt; dna_seq
Seq('ACGT', IUPACUnambiguousDNA())
&gt;&gt;&gt; dna_seq.lower()
Seq('acgt', DNAAlphabet())
</PRE><!--TOC section Nucleotide sequences and (reverse) complements-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc23">3.7</A>&#XA0;&#XA0;Nucleotide sequences and (reverse) complements</H2><!--SEC END --><P>
<A NAME="sec:seq-reverse-complement"></A></P><P>For nucleotide sequences, you can easily obtain the complement or reverse
complement of a <CODE>Seq</CODE> object using its built-in methods:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq("GATCGATGGGCCTATATAGGATCGAAAATCGC", IUPAC.unambiguous_dna)
&gt;&gt;&gt; my_seq
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq.complement()
Seq('CTAGCTACCCGGATATATCCTAGCTTTTAGCG', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq.reverse_complement()
Seq('GCGATTTTCGATCCTATATAGGCCCATCGATC', IUPACUnambiguousDNA())
</PRE><P>As mentioned earlier, an easy way to just reverse a <CODE>Seq</CODE> object (or a
Python string) is slice it with -1 step:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq[::-1]
Seq('CGCTAAAAGCTAGGATATATCCGGGTAGCTAG', IUPACUnambiguousDNA())
</PRE><P>In all of these operations, the alphabet property is maintained. This is very
useful in case you accidentally end up trying to do something weird like take
the (reverse)complement of a protein sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; protein_seq = Seq("EVRNAK", IUPAC.protein)
&gt;&gt;&gt; protein_seq.complement()
Traceback (most recent call last):
...
ValueError: Proteins do not have complements!
</PRE><P>The example in Section&#XA0;<A HREF="#sec:SeqIO-reverse-complement">5.5.3</A> combines the <CODE>Seq</CODE>
object&#X2019;s reverse complement method with <CODE>Bio.SeqIO</CODE> for sequence input/ouput.</P><!--TOC section Transcription-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">3.8</A>&#XA0;&#XA0;Transcription</H2><!--SEC END --><P>
Before talking about transcription, I want to try and clarify the strand issue.
Consider the following (made up) stretch of double stranded DNA which
encodes a short peptide:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>DNA coding strand (aka Crick strand, strand +1)</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>5&#X2019;</TD><TD ALIGN=center NOWRAP><TT>ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG</TT></TD><TD ALIGN=left NOWRAP>3&#X2019;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><TT>|||||||||||||||||||||||||||||||||||||||</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>3&#X2019;</TD><TD ALIGN=center NOWRAP><TT>TACCGGTAACATTACCCGGCGACTTTCCCACGGGCTATC</TT></TD><TD ALIGN=left NOWRAP>5&#X2019;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>DNA template strand (aka Watson strand, strand &#X2212;1)</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><FONT SIZE=5>|</FONT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>Transcription</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><FONT SIZE=5>&#X2193;</FONT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>5&#X2019;</TD><TD ALIGN=center NOWRAP><TT>AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG</TT></TD><TD ALIGN=left NOWRAP>3&#X2019;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>Single stranded messenger RNA</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
</TABLE><P>The actual biological transcription process works from the template strand, doing a reverse complement (TCAG &#X2192; CUGA) to give the mRNA. However, in Biopython and bioinformatics in general, we typically work directly with the coding strand because this means we can get the mRNA sequence just by switching T &#X2192; U.</P><P>Now let&#X2019;s actually get down to doing a transcription in Biopython. First, let&#X2019;s create <CODE>Seq</CODE> objects for the coding and template DNA strands:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; coding_dna = Seq("ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG", IUPAC.unambiguous_dna)
&gt;&gt;&gt; coding_dna
Seq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', IUPACUnambiguousDNA())
&gt;&gt;&gt; template_dna = coding_dna.reverse_complement()
&gt;&gt;&gt; template_dna
Seq('CTATCGGGCACCCTTTCAGCGGCCCATTACAATGGCCAT', IUPACUnambiguousDNA())
</PRE><P>These should match the figure above - remember by convention nucleotide sequences are normally read from the 5&#X2019; to 3&#X2019; direction, while in the figure the template strand is shown reversed.</P><P>Now let&#X2019;s transcribe the coding strand into the corresponding mRNA, using the <CODE>Seq</CODE> object&#X2019;s built in <CODE>transcribe</CODE> method:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; coding_dna
Seq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', IUPACUnambiguousDNA())
&gt;&gt;&gt; messenger_rna = coding_dna.transcribe()
&gt;&gt;&gt; messenger_rna
Seq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG', IUPACUnambiguousRNA())
</PRE><P>As you can see, all this does is switch T &#X2192; U, and adjust the alphabet.</P><P>If you do want to do a true biological transcription starting with the template strand, then this becomes a two-step process:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; template_dna.reverse_complement().transcribe()
Seq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG', IUPACUnambiguousRNA())
</PRE><P>The <CODE>Seq</CODE> object also includes a back-transcription method for going from the mRNA to the coding strand of the DNA. Again, this is a simple U &#X2192; T substitution and associated change of alphabet:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; messenger_rna = Seq("AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG", IUPAC.unambiguous_rna)
&gt;&gt;&gt; messenger_rna
Seq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG', IUPACUnambiguousRNA())
&gt;&gt;&gt; messenger_rna.back_transcribe()
Seq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', IUPACUnambiguousDNA())
</PRE><P><EM>Note:</EM> The <CODE>Seq</CODE> object&#X2019;s <CODE>transcribe</CODE> and <CODE>back_transcribe</CODE> methods
were added in Biopython 1.49. For older releases you would have to use the <CODE>Bio.Seq</CODE>
module&#X2019;s functions instead, see Section&#XA0;<A HREF="#sec:seq-module-functions">3.14</A>.</P><!--TOC section Translation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc25">3.9</A>&#XA0;&#XA0;Translation</H2><!--SEC END --><P>
<A NAME="sec:translation"></A>
Sticking with the same example discussed in the transcription section above,
now let&#X2019;s translate this mRNA into the corresponding protein sequence - again taking
advantage of one of the <CODE>Seq</CODE> object&#X2019;s biological methods:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; messenger_rna = Seq("AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG", IUPAC.unambiguous_rna)
&gt;&gt;&gt; messenger_rna
Seq('AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG', IUPACUnambiguousRNA())
&gt;&gt;&gt; messenger_rna.translate()
Seq('MAIVMGR*KGAR*', HasStopCodon(IUPACProtein(), '*'))
</PRE><P>You can also translate directly from the coding strand DNA sequence:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; coding_dna = Seq("ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG", IUPAC.unambiguous_dna)
&gt;&gt;&gt; coding_dna
Seq('ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG', IUPACUnambiguousDNA())
&gt;&gt;&gt; coding_dna.translate()
Seq('MAIVMGR*KGAR*', HasStopCodon(IUPACProtein(), '*'))
</PRE><P>You should notice in the above protein sequences that in addition to the end stop character, there is an internal stop as well. This was a deliberate choice of example, as it gives an excuse to talk about some optional arguments, including different translation tables (Genetic Codes).</P><P>The translation tables available in Biopython are based on those <A HREF="http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi">from the NCBI</A> (see the next section of this tutorial). By default, translation will use the <EM>standard</EM> genetic code (NCBI table id 1).
Suppose we are dealing with a mitochondrial sequence. We need to tell the translation function to use the relevant genetic code instead:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; coding_dna.translate(table="Vertebrate Mitochondrial")
Seq('MAIVMGRWKGAR*', HasStopCodon(IUPACProtein(), '*'))
</PRE><P>You can also specify the table using the NCBI table number which is shorter, and often included in the feature annotation of GenBank files:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; coding_dna.translate(table=2)
Seq('MAIVMGRWKGAR*', HasStopCodon(IUPACProtein(), '*'))
</PRE><P>Now, you may want to translate the nucleotides up to the first in frame stop codon,
and then stop (as happens in nature):
</P><PRE CLASS="verbatim">&gt;&gt;&gt; coding_dna.translate()
Seq('MAIVMGR*KGAR*', HasStopCodon(IUPACProtein(), '*'))
&gt;&gt;&gt; coding_dna.translate(to_stop=True)
Seq('MAIVMGR', IUPACProtein())
&gt;&gt;&gt; coding_dna.translate(table=2)
Seq('MAIVMGRWKGAR*', HasStopCodon(IUPACProtein(), '*'))
&gt;&gt;&gt; coding_dna.translate(table=2, to_stop=True)
Seq('MAIVMGRWKGAR', IUPACProtein())
</PRE><P>Notice that when you use the <CODE>to_stop</CODE> argument, the stop codon itself
is not translated - and the stop symbol is not included at the end of your protein
sequence.</P><P>You can even specify the stop symbol if you don&#X2019;t like the default asterisk:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; coding_dna.translate(table=2, stop_symbol="@")
Seq('MAIVMGRWKGAR@', HasStopCodon(IUPACProtein(), '@'))
</PRE><P>Now, suppose you have a complete coding sequence CDS, which is to say a
nucleotide sequence (e.g. mRNA &#X2013; after any splicing) which is a whole number
of codons (i.e. the length is a multiple of three), commences with a start
codon, ends with a stop codon, and has no internal in-frame stop codons.
In general, given a complete CDS, the default translate method will do what
you want (perhaps with the <CODE>to_stop</CODE> option). However, what if your
sequence uses a non-standard start codon? This happens a lot in bacteria &#X2013;
for example the gene yaaX in <TT>E. coli</TT> K12:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import generic_dna
&gt;&gt;&gt; gene = Seq("GTGAAAAAGATGCAATCTATCGTACTCGCACTTTCCCTGGTTCTGGTCGCTCCCATGGCA" + \
...            "GCACAGGCTGCGGAAATTACGTTAGTCCCGTCAGTAAAATTACAGATAGGCGATCGTGAT" + \
...            "AATCGTGGCTATTACTGGGATGGAGGTCACTGGCGCGACCACGGCTGGTGGAAACAACAT" + \
...            "TATGAATGGCGAGGCAATCGCTGGCACCTACACGGACCGCCGCCACCGCCGCGCCACCAT" + \
...            "AAGAAAGCTCCTCATGATCATCACGGCGGTCATGGTCCAGGCAAACATCACCGCTAA",
...            generic_dna)
&gt;&gt;&gt; gene.translate(table="Bacterial")
Seq('VKKMQSIVLALSLVLVAPMAAQAAEITLVPSVKLQIGDRDNRGYYWDGGHWRDH...HR*',
HasStopCodon(ExtendedIUPACProtein(), '*')
&gt;&gt;&gt; gene.translate(table="Bacterial", to_stop=True)
Seq('VKKMQSIVLALSLVLVAPMAAQAAEITLVPSVKLQIGDRDNRGYYWDGGHWRDH...HHR',
ExtendedIUPACProtein())
</PRE><P>In the bacterial genetic code <TT>GTG</TT> is a valid start codon,
and while it does <EM>normally</EM> encode Valine, if used as a start codon it
should be translated as methionine. This happens if you tell Biopython your
sequence is a complete CDS:</P><PRE CLASS="verbatim">&gt;&gt;&gt; gene.translate(table="Bacterial", cds=True)
Seq('MKKMQSIVLALSLVLVAPMAAQAAEITLVPSVKLQIGDRDNRGYYWDGGHWRDH...HHR',
ExtendedIUPACProtein())
</PRE><P>In addition to telling Biopython to translate an alternative start codon as
methionine, using this option also makes sure your sequence really is a valid
CDS (you&#X2019;ll get an exception if not).</P><P>The example in Section&#XA0;<A HREF="#sec:SeqIO-translate">16.1.3</A> combines the <CODE>Seq</CODE> object&#X2019;s
translate method with <CODE>Bio.SeqIO</CODE> for sequence input/ouput.</P><P><EM>Note:</EM> The <CODE>Seq</CODE> object&#X2019;s <CODE>translate</CODE> method is new in Biopython 1.49.
For older releases you would have to use the <CODE>Bio.Seq</CODE> module&#X2019;s <CODE>translate</CODE>
function instead, see Section&#XA0;<A HREF="#sec:seq-module-functions">3.14</A>. The <TT>cds</TT> option
was added in Biopython 1.51, and there is no simple way to do this with older versions
of Biopython.</P><!--TOC section Translation Tables-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">3.10</A>&#XA0;&#XA0;Translation Tables</H2><!--SEC END --><P>In the previous sections we talked about the <CODE>Seq</CODE> object translation method (and mentioned the equivalent function in the <CODE>Bio.Seq</CODE> module &#X2013; see
Section&#XA0;<A HREF="#sec:seq-module-functions">3.14</A>).
Internally these use codon table objects derived from the NCBI information at
<A HREF="ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt"><TT>ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt</TT></A>, also shown on
<A HREF="http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi"><TT>http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi</TT></A> in a much more readable layout.</P><P>As before, let&#X2019;s just focus on two choices: the Standard translation table, and the
translation table for Vertebrate Mitochondrial DNA. </P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Data import CodonTable
&gt;&gt;&gt; standard_table = CodonTable.unambiguous_dna_by_name["Standard"]
&gt;&gt;&gt; mito_table = CodonTable.unambiguous_dna_by_name["Vertebrate Mitochondrial"]
</PRE><P>Alternatively, these tables are labeled with ID numbers 1 and 2, respectively:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Data import CodonTable
&gt;&gt;&gt; standard_table = CodonTable.unambiguous_dna_by_id[1]
&gt;&gt;&gt; mito_table = CodonTable.unambiguous_dna_by_id[2]
</PRE><P>You can compare the actual tables visually by printing them:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print standard_table
Table 1 Standard, SGC0

  |  T      |  C      |  A      |  G      |
--+---------+---------+---------+---------+--
T | TTT F   | TCT S   | TAT Y   | TGT C   | T
T | TTC F   | TCC S   | TAC Y   | TGC C   | C
T | TTA L   | TCA S   | TAA Stop| TGA Stop| A
T | TTG L(s)| TCG S   | TAG Stop| TGG W   | G
--+---------+---------+---------+---------+--
C | CTT L   | CCT P   | CAT H   | CGT R   | T
C | CTC L   | CCC P   | CAC H   | CGC R   | C
C | CTA L   | CCA P   | CAA Q   | CGA R   | A
C | CTG L(s)| CCG P   | CAG Q   | CGG R   | G
--+---------+---------+---------+---------+--
A | ATT I   | ACT T   | AAT N   | AGT S   | T
A | ATC I   | ACC T   | AAC N   | AGC S   | C
A | ATA I   | ACA T   | AAA K   | AGA R   | A
A | ATG M(s)| ACG T   | AAG K   | AGG R   | G
--+---------+---------+---------+---------+--
G | GTT V   | GCT A   | GAT D   | GGT G   | T
G | GTC V   | GCC A   | GAC D   | GGC G   | C
G | GTA V   | GCA A   | GAA E   | GGA G   | A
G | GTG V   | GCG A   | GAG E   | GGG G   | G
--+---------+---------+---------+---------+--
</PRE><P>and:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print mito_table
Table 2 Vertebrate Mitochondrial, SGC1

  |  T      |  C      |  A      |  G      |
--+---------+---------+---------+---------+--
T | TTT F   | TCT S   | TAT Y   | TGT C   | T
T | TTC F   | TCC S   | TAC Y   | TGC C   | C
T | TTA L   | TCA S   | TAA Stop| TGA W   | A
T | TTG L   | TCG S   | TAG Stop| TGG W   | G
--+---------+---------+---------+---------+--
C | CTT L   | CCT P   | CAT H   | CGT R   | T
C | CTC L   | CCC P   | CAC H   | CGC R   | C
C | CTA L   | CCA P   | CAA Q   | CGA R   | A
C | CTG L   | CCG P   | CAG Q   | CGG R   | G
--+---------+---------+---------+---------+--
A | ATT I(s)| ACT T   | AAT N   | AGT S   | T
A | ATC I(s)| ACC T   | AAC N   | AGC S   | C
A | ATA M(s)| ACA T   | AAA K   | AGA Stop| A
A | ATG M(s)| ACG T   | AAG K   | AGG Stop| G
--+---------+---------+---------+---------+--
G | GTT V   | GCT A   | GAT D   | GGT G   | T
G | GTC V   | GCC A   | GAC D   | GGC G   | C
G | GTA V   | GCA A   | GAA E   | GGA G   | A
G | GTG V(s)| GCG A   | GAG E   | GGG G   | G
--+---------+---------+---------+---------+--
</PRE><P>You may find these following properties useful &#X2013; for example if you are trying
to do your own gene finding:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; mito_table.stop_codons
['TAA', 'TAG', 'AGA', 'AGG']
&gt;&gt;&gt; mito_table.start_codons
['ATT', 'ATC', 'ATA', 'ATG', 'GTG']
&gt;&gt;&gt; mito_table.forward_table["ACG"]
'T'
</PRE><!--TOC section Comparing Seq objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc27">3.11</A>&#XA0;&#XA0;Comparing Seq objects</H2><!--SEC END --><P>
<A NAME="sec:seq-comparison"></A></P><P>Sequence comparison is actually a very complicated topic, and there is no easy
way to decide if two sequences are equal. The basic problem is the meaning of
the letters in a sequence are context dependent - the letter &#X201C;A&#X201D; could be part
of a DNA, RNA or protein sequence. Biopython uses alphabet objects as part of
each <CODE>Seq</CODE> object to try and capture this information - so comparing two
<CODE>Seq</CODE> objects means considering both the sequence strings <EM>and</EM> the
alphabets.</P><P>For example, you might argue that the two DNA <CODE>Seq</CODE> objects
<TT>Seq("ACGT", IUPAC.unambiguous_dna)</TT> and
<TT>Seq("ACGT", IUPAC.ambiguous_dna)</TT> should be equal, even though
they do have different alphabets. Depending on the context this could be
important.</P><P>This gets worse &#X2013; suppose you think <TT>Seq("ACGT",
IUPAC.unambiguous_dna)</TT> and <TT>Seq("ACGT")</TT> (i.e. the default generic
alphabet) should be equal. Then, logically, <TT>Seq("ACGT", IUPAC.protein)</TT>
and <TT>Seq("ACGT")</TT> should also be equal. Now, in logic if <I>A</I>=<I>B</I> and
<I>B</I>=<I>C</I>, by transitivity we expect <I>A</I>=<I>C</I>. So for logical consistency we&#X2019;d
require <TT>Seq("ACGT", IUPAC.unambiguous_dna)</TT> and <TT>Seq("ACGT",
IUPAC.protein)</TT> to be equal &#X2013; which most people would agree is just not right.
This transitivity problem would also have implications for using <CODE>Seq</CODE>
objects as Python dictionary keys.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; seq1 = Seq("ACGT", IUPAC.unambiguous_dna)
&gt;&gt;&gt; seq2 = Seq("ACGT", IUPAC.unambiguous_dna)
</PRE><P>So, what does Biopython do? Well, the equality test is the default for Python
objects &#X2013; it tests to see if they are the same object in memory. This is a
very strict test:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; seq1 == seq2
False
&gt;&gt;&gt; seq1 == seq1
True
</PRE><P>If you actually want to do this, you can be more explicit by using the Python
<CODE>id</CODE> function,
</P><PRE CLASS="verbatim">&gt;&gt;&gt; id(seq1) == id(seq2)
False
&gt;&gt;&gt; id(seq1) == id(seq1)
True
</PRE><P>Now, in every day use, your sequences will probably all have the same
alphabet, or at least all be the same type of sequence (all DNA, all RNA, or
all protein). What you probably want is to just compare the sequences as
strings &#X2013; so do this explicitly:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; str(seq1) == str(seq2)
True
&gt;&gt;&gt; str(seq1) == str(seq1)
True
</PRE><P>As an extension to this, while you can use a Python dictionary with
<CODE>Seq</CODE> objects as keys, it is generally more useful to use the sequence a
string for the key. See also Section&#XA0;<A HREF="#sec:seq-to-string">3.4</A>.</P><!--TOC section MutableSeq objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">3.12</A>&#XA0;&#XA0;MutableSeq objects</H2><!--SEC END --><P>
<A NAME="sec:mutable-seq"></A></P><P>Just like the normal Python string, the <CODE>Seq</CODE> object is &#X201C;read only&#X201D;, or in Python terminology, immutable. Apart from wanting the <CODE>Seq</CODE> object to act like a string, this is also a useful default since in many biological applications you want to ensure you are not changing your sequence data:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq("GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA", IUPAC.unambiguous_dna)
</PRE><P>Observe what happens if you try to edit the sequence:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq[5] = "G"
Traceback (most recent call last):
...
TypeError: 'Seq' object does not support item assignment
</PRE><P>However, you can convert it into a mutable sequence (a <CODE>MutableSeq</CODE> object) and do pretty much anything you want with it:</P><PRE CLASS="verbatim">&gt;&gt;&gt; mutable_seq = my_seq.tomutable()
&gt;&gt;&gt; mutable_seq
MutableSeq('GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA', IUPACUnambiguousDNA())
</PRE><P>Alternatively, you can create a <CODE>MutableSeq</CODE> object directly from a string:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import MutableSeq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; mutable_seq = MutableSeq("GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA", IUPAC.unambiguous_dna)
</PRE><P>Either way will give you a sequence object which can be changed:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; mutable_seq
MutableSeq('GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq[5] = "C"
&gt;&gt;&gt; mutable_seq
MutableSeq('GCCATCGTAATGGGCCGCTGAAAGGGTGCCCGA', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq.remove("T")
&gt;&gt;&gt; mutable_seq
MutableSeq('GCCACGTAATGGGCCGCTGAAAGGGTGCCCGA', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq.reverse()
&gt;&gt;&gt; mutable_seq
MutableSeq('AGCCCGTGGGAAAGTCGCCGGGTAATGCACCG', IUPACUnambiguousDNA())
</PRE><P>Do note that unlike the <CODE>Seq</CODE> object, the <CODE>MutableSeq</CODE> object&#X2019;s methods like <CODE>reverse_complement()</CODE> and <CODE>reverse()</CODE> act in-situ!</P><P>An important technical difference between mutable and immutable objects in Python means that you can&#X2019;t use a <CODE>MutableSeq</CODE> object as a dictionary key, but you can use a Python string or a <CODE>Seq</CODE> object in this way.</P><P>Once you have finished editing your a <CODE>MutableSeq</CODE> object, it&#X2019;s easy to get back to a read-only <CODE>Seq</CODE> object should you need to:</P><PRE CLASS="verbatim">&gt;&gt;&gt; new_seq = mutable_seq.toseq()
&gt;&gt;&gt; new_seq
Seq('AGCCCGTGGGAAAGTCGCCGGGTAATGCACCG', IUPACUnambiguousDNA())
</PRE><P>You can also get a string from a <CODE>MutableSeq</CODE> object just like from a <CODE>Seq</CODE> object (Section&#XA0;<A HREF="#sec:seq-to-string">3.4</A>).</P><!--TOC section UnknownSeq objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">3.13</A>&#XA0;&#XA0;UnknownSeq objects</H2><!--SEC END --><P>
Biopython 1.50 introduced another basic sequence object, the <CODE>UnknownSeq</CODE> object.
This is a subclass of the basic <CODE>Seq</CODE> object and its purpose is to represent a
sequence where we know the length, but not the actual letters making it up.
You could of course use a normal <CODE>Seq</CODE> object in this situation, but it wastes
rather a lot of memory to hold a string of a million &#X201C;N&#X201D; characters when you could
just store a single letter &#X201C;N&#X201D; and the desired length as an integer.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import UnknownSeq
&gt;&gt;&gt; unk = UnknownSeq(20)
&gt;&gt;&gt; unk
UnknownSeq(20, alphabet = Alphabet(), character = '?')
&gt;&gt;&gt; print unk
????????????????????
&gt;&gt;&gt; len(unk)
20
</PRE><P>You can of course specify an alphabet, meaning for nucleotide sequences
the letter defaults to &#X201C;N&#X201D; and for proteins &#X201C;X&#X201D;, rather than just &#X201C;?&#X201D;.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import UnknownSeq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; unk_dna = UnknownSeq(20, alphabet=IUPAC.ambiguous_dna)
&gt;&gt;&gt; unk_dna
UnknownSeq(20, alphabet = IUPACAmbiguousDNA(), character = 'N')
&gt;&gt;&gt; print unk_dna
NNNNNNNNNNNNNNNNNNNN
</PRE><P>You can use all the usual <CODE>Seq</CODE> object methods too, note these give back
memory saving <CODE>UnknownSeq</CODE> objects where appropriate as you might expect:</P><PRE CLASS="verbatim">&gt;&gt;&gt; unk_dna
UnknownSeq(20, alphabet = IUPACAmbiguousDNA(), character = 'N')
&gt;&gt;&gt; unk_dna.complement()
UnknownSeq(20, alphabet = IUPACAmbiguousDNA(), character = 'N')
&gt;&gt;&gt; unk_dna.reverse_complement()
UnknownSeq(20, alphabet = IUPACAmbiguousDNA(), character = 'N')
&gt;&gt;&gt; unk_dna.transcribe()
UnknownSeq(20, alphabet = IUPACAmbiguousRNA(), character = 'N')
&gt;&gt;&gt; unk_protein = unk_dna.translate()
&gt;&gt;&gt; unk_protein
UnknownSeq(6, alphabet = ProteinAlphabet(), character = 'X')
&gt;&gt;&gt; print unk_protein
XXXXXX
&gt;&gt;&gt; len(unk_protein)
6
</PRE><P>You may be able to find a use for the <CODE>UnknownSeq</CODE> object in your own
code, but it is more likely that you will first come across them in a
<CODE>SeqRecord</CODE> object created by <CODE>Bio.SeqIO</CODE>
(see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>).
Some sequence file formats don&#X2019;t always include the actual sequence, for
example GenBank and EMBL files may include a list of features but for the
sequence just present the contig information. Alternatively, the QUAL files
used in sequencing work hold quality scores but they <EM>never</EM> contain a
sequence &#X2013; instead there is a partner FASTA file which <EM>does</EM> have the
sequence.</P><!--TOC section Working with directly strings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc30">3.14</A>&#XA0;&#XA0;Working with directly strings</H2><!--SEC END --><P>
<A NAME="sec:seq-module-functions"></A>
To close this chapter, for those you who <EM>really</EM> don&#X2019;t want to use the sequence
objects (or who prefer a functional programming style to an object orientated one),
there are module level functions in <CODE>Bio.Seq</CODE> will accept plain Python strings,
<CODE>Seq</CODE> objects (including <CODE>UnknownSeq</CODE> objects) or <CODE>MutableSeq</CODE> objects:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import reverse_complement, transcribe, back_transcribe, translate
&gt;&gt;&gt; my_string = "GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGTTAG"
&gt;&gt;&gt; reverse_complement(my_string)
'CTAACCAGCAGCACGACCACCCTTCCAACGACCCATAACAGC'
&gt;&gt;&gt; transcribe(my_string)
'GCUGUUAUGGGUCGUUGGAAGGGUGGUCGUGCUGCUGGUUAG'
&gt;&gt;&gt; back_transcribe(my_string)
'GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGTTAG'
&gt;&gt;&gt; translate(my_string)
'AVMGRWKGGRAAG*'
</PRE><P>You are, however, encouraged to work with <CODE>Seq</CODE> objects by default.</P><!--TOC chapter Sequence Record objects-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc31">Chapter&#XA0;4</A>&#XA0;&#XA0;Sequence Record objects</H1><!--SEC END --><P>
<A NAME="chapter:SeqRecord"></A></P><P>Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A> introduced the sequence classes. Immediately &#X201C;above&#X201D; the <CODE>Seq</CODE> class is the Sequence Record or <CODE>SeqRecord</CODE> class, defined in the <CODE>Bio.SeqRecord</CODE> module. This class allows higher level features such as identifiers and features to be associated with the sequence, and is used thoughout the sequence input/output interface <CODE>Bio.SeqIO</CODE> described fully in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>.</P><P>If you are only going to be working with simple data like FASTA files, you can probably skip this chapter
for now. If on the other hand you are going to be using richly annotated sequence data, say from GenBank
or EMBL files, this information is quite important.</P><P>While this chapter should cover most things to do with the <CODE>SeqRecord</CODE> object in this chapter, you may also want to read the <CODE>SeqRecord</CODE> wiki page (<A HREF="http://biopython.org/wiki/SeqRecord"><TT>http://biopython.org/wiki/SeqRecord</TT></A>), and the built in documentation (also <A HREF="http://biopython.org/DIST/docs/api/Bio.SeqRecord.SeqRecord-class.html">online</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.SeqRecord import SeqRecord
&gt;&gt;&gt; help(SeqRecord)
...
</PRE><!--TOC section The SeqRecord object-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc32">4.1</A>&#XA0;&#XA0;The SeqRecord object</H2><!--SEC END --><P>
<A NAME="sec:SeqRecord"></A></P><P>The <CODE>SeqRecord</CODE> (Sequence Record) class is defined in the <CODE>Bio.SeqRecord</CODE> module. This class allows higher level features such as identifiers and features to be associated with a sequence (see Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A>), and is the basic data type for the <CODE>Bio.SeqIO</CODE> sequence input/output interface (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>).</P><P>The <CODE>SeqRecord</CODE> class itself is quite simple, and offers the following information as attributes:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>seq</B></DT><DD CLASS="dd-description"> &#X2013; The sequence itself, typically a <CODE>Seq</CODE> object.</DD><DT CLASS="dt-description"><B>id</B></DT><DD CLASS="dd-description"> &#X2013; The primary ID used to identify the sequence &#X2013; a string. In most cases this is something like an accession number.</DD><DT CLASS="dt-description"><B>name</B></DT><DD CLASS="dd-description"> &#X2013; A &#X201C;common&#X201D; name/id for the sequence &#X2013; a string. In some cases this will be the same as the accession number, but it could also be a clone name. I think of this as being analagous to the LOCUS id in a GenBank record.</DD><DT CLASS="dt-description"><B>description</B></DT><DD CLASS="dd-description"> &#X2013; A human readable description or expressive name for the sequence &#X2013; a string.</DD><DT CLASS="dt-description"><B>letter_annotations</B></DT><DD CLASS="dd-description"> &#X2013; Holds per-letter-annotations using a (restricted) dictionary of additional information about the letters in the sequence. The keys are the name of the information, and the information is contained in the value as a Python sequence (i.e. a list, tuple or string) with the same length as the sequence itself. This is often used for quality scores (e.g. Section&#XA0;<A HREF="#sec:FASTQ-filtering-example">16.1.6</A>) or secondary structure information (e.g. from Stockholm/PFAM alignment files).</DD><DT CLASS="dt-description"><B>annotations</B></DT><DD CLASS="dd-description"> &#X2013; A dictionary of additional information about the sequence. The keys are the name of the information, and the information is contained in the value. This allows the addition of more &#X201C;unstructed&#X201D; information to the sequence.</DD><DT CLASS="dt-description"><B>features</B></DT><DD CLASS="dd-description"> &#X2013; A list of <CODE>SeqFeature</CODE> objects with more structured information about the features on a sequence (e.g. position of genes on a genome, or domains on a protein sequence). The structure of sequence features is described below in Section&#XA0;<A HREF="#sec:seq_features">4.3</A>.</DD><DT CLASS="dt-description"><B>dbxrefs</B></DT><DD CLASS="dd-description"> - A list of database cross-references as strings.
</DD></DL><!--TOC section Creating a SeqRecord-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc33">4.2</A>&#XA0;&#XA0;Creating a SeqRecord</H2><!--SEC END --><P>Using a <CODE>SeqRecord</CODE> object is not very complicated, since all of the
information is presented as attributes of the class. Usually you won&#X2019;t create
a <CODE>SeqRecord</CODE> &#X201C;by hand&#X201D;, but instead use <CODE>Bio.SeqIO</CODE> to read in a
sequence file for you (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A> and the examples
below). However, creating <CODE>SeqRecord</CODE> can be quite simple.</P><!--TOC subsection SeqRecord objects from scratch-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">4.2.1</A>&#XA0;&#XA0;SeqRecord objects from scratch</H3><!--SEC END --><P>To create a <CODE>SeqRecord</CODE> at a minimum you just need a <CODE>Seq</CODE> object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; simple_seq = Seq("GATC")
&gt;&gt;&gt; from Bio.SeqRecord import SeqRecord
&gt;&gt;&gt; simple_seq_r = SeqRecord(simple_seq)
</PRE><P>Additionally, you can also pass the id, name and description to the initialization function, but if not they will be set as strings indicating they are unknown, and can be modified subsequently:</P><PRE CLASS="verbatim">&gt;&gt;&gt; simple_seq_r.id
'&lt;unknown id&gt;'
&gt;&gt;&gt; simple_seq_r.id = "AC12345"
&gt;&gt;&gt; simple_seq_r.description = "Made up sequence I wish I could write a paper about"
&gt;&gt;&gt; print simple_seq_r.description
Made up sequence I wish I could write a paper about
&gt;&gt;&gt; simple_seq_r.seq
Seq('GATC', Alphabet())
</PRE><P>Including an identifier is very important if you want to output your <CODE>SeqRecord</CODE> to a file. You would normally include this when creating the object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; simple_seq = Seq("GATC")
&gt;&gt;&gt; from Bio.SeqRecord import SeqRecord
&gt;&gt;&gt; simple_seq_r = SeqRecord(simple_seq, id="AC12345")
</PRE><P>As mentioned above, the <CODE>SeqRecord</CODE> has an dictionary attribute <CODE>annotations</CODE>. This is used
for any miscellaneous annotations that doesn&#X2019;t fit under one of the other more specific attributes.
Adding annotations is easy, and just involves dealing directly with the annotation dictionary:</P><PRE CLASS="verbatim">&gt;&gt;&gt; simple_seq_r.annotations["evidence"] = "None. I just made it up."
&gt;&gt;&gt; print simple_seq_r.annotations
{'evidence': 'None. I just made it up.'}
&gt;&gt;&gt; print simple_seq_r.annotations["evidence"]
None. I just made it up.
</PRE><P>Working with per-letter-annotations is similar, <CODE>letter_annotations</CODE> is a
dictionary like attribute which will let you assign any Python sequence (i.e.
a string, list or tuple) which has the same length as the sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; simple_seq_r.letter_annotations["phred_quality"] = [40,40,38,30]
&gt;&gt;&gt; print simple_seq_r.letter_annotations
{'phred_quality': [40, 40, 38, 30]}
&gt;&gt;&gt; print simple_seq_r.letter_annotations["phred_quality"]
[40, 40, 38, 30]
</PRE><P>The <CODE>dbxrefs</CODE> and <CODE>features</CODE> attributes are just Python lists, and
should be used to store strings and <CODE>SeqFeature</CODE> objects (discussed later
in this chapter) respectively.</P><!--TOC subsection SeqRecord objects from FASTA files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc35">4.2.2</A>&#XA0;&#XA0;SeqRecord objects from FASTA files</H3><!--SEC END --><P>This example uses a fairly large FASTA file containing the whole sequence for <I>Yersinia pestis biovar Microtus</I> str. 91001 plasmid pPCP1, originally downloaded from the NCBI. This file is included with the Biopython unit tests under the GenBank folder, or online <A HREF="http://biopython.org/SRC/biopython/Tests/GenBank/NC_005816.fna"><TT>NC_005816.fna</TT></A> from our website.</P><P>The file starts like this - and you can check there is only one record present (i.e. only one line starting with a greater than symbol):</P><PRE CLASS="verbatim">&gt;gi|45478711|ref|NC_005816.1| Yersinia pestis biovar Microtus ... pPCP1, complete sequence
TGTAACGAACGGTGCAATAGTGATCCACACCCAACGCCTGAAATCAGATCCAGGGGGTAATCTGCTCTCC
...
</PRE><P>Back in Chapter&#XA0;<A HREF="#chapter:quick-start">2</A> you will have seen the function <CODE>Bio.SeqIO.parse(...)</CODE>
used to loop over all the records in a file as <CODE>SeqRecord</CODE> objects. The <CODE>Bio.SeqIO</CODE> module
has a sister function for use on files which contain just one record which we&#X2019;ll use here (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A> for details):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read("NC_005816.fna", "fasta")
&gt;&gt;&gt; record
SeqRecord(seq=Seq('TGTAACGAACGGTGCAATAGTGATCCACACCCAACGCCTGAAATCAGATCCAGG...CTG',
SingleLetterAlphabet()), id='gi|45478711|ref|NC_005816.1|', name='gi|45478711|ref|NC_005816.1|',
description='gi|45478711|ref|NC_005816.1| Yersinia pestis biovar Microtus ... sequence',
dbxrefs=[])
</PRE><P>Now, let&#X2019;s have a look at the key attributes of this <CODE>SeqRecord</CODE>
individually &#X2013; starting with the <CODE>seq</CODE> attribute which gives you a
<CODE>Seq</CODE> object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.seq
Seq('TGTAACGAACGGTGCAATAGTGATCCACACCCAACGCCTGAAATCAGATCCAGG...CTG', SingleLetterAlphabet())
</PRE><P>Here <CODE>Bio.SeqIO</CODE> has defaulted to a generic alphabet, rather
than guessing that this is DNA. If you know in advance what kind of sequence
your FASTA file contains, you can tell <CODE>Bio.SeqIO</CODE> which alphabet to use
(see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>).</P><P>Next, the identifiers and description:</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.id
'gi|45478711|ref|NC_005816.1|'
&gt;&gt;&gt; record.name
'gi|45478711|ref|NC_005816.1|'
&gt;&gt;&gt; record.description
'gi|45478711|ref|NC_005816.1| Yersinia pestis biovar Microtus ... pPCP1, complete sequence'
</PRE><P>As you can see above, the first word of the FASTA record&#X2019;s title line (after
removing the greater than symbol) is used for both the <CODE>id</CODE> and
<CODE>name</CODE> attributes. The whole title line (after removing the greater than
symbol) is used for the record description. This is deliberate, partly for
backwards compatibility reasons, but it also makes sense if you have a FASTA
file like this:</P><PRE CLASS="verbatim">&gt;Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1
TGTAACGAACGGTGCAATAGTGATCCACACCCAACGCCTGAAATCAGATCCAGGGGGTAATCTGCTCTCC
...
</PRE><P>Note that none of the other annotation attributes get populated when reading a
FASTA file:</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.dbxrefs
[]
&gt;&gt;&gt; record.annotations
{}
&gt;&gt;&gt; record.letter_annotations
{}
&gt;&gt;&gt; record.features
[]
</PRE><P>In this case our example FASTA file was from the NCBI, and they have a fairly well defined set of conventions for formatting their FASTA lines. This means it would be possible to parse this information and extract the GI number and accession for example. However, FASTA files from other sources vary, so this isn&#X2019;t possible in general.</P><!--TOC subsection SeqRecord objects from GenBank files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">4.2.3</A>&#XA0;&#XA0;SeqRecord objects from GenBank files</H3><!--SEC END --><P>As in the previous example, we&#X2019;re going to look at the whole sequence for <I>Yersinia pestis biovar Microtus</I> str. 91001 plasmid pPCP1, originally downloaded from the NCBI, but this time as a GenBank file.
Again, this file is included with the Biopython unit tests under the GenBank folder, or online <A HREF="http://biopython.org/SRC/biopython/Tests/GenBank/NC_005816.gb"><TT>NC_005816.gb</TT></A> from our website.</P><P>This file contains a single record (i.e. only one LOCUS line) and starts:
</P><PRE CLASS="verbatim">LOCUS       NC_005816               9609 bp    DNA     circular BCT 21-JUL-2008
DEFINITION  Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, complete
            sequence.
ACCESSION   NC_005816
VERSION     NC_005816.1  GI:45478711
PROJECT     GenomeProject:10638
...
</PRE><P>Again, we&#X2019;ll use <CODE>Bio.SeqIO</CODE> to read this file in, and the code is almost identical to that for used above for the FASTA file (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A> for details):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read("NC_005816.gb", "genbank")
&gt;&gt;&gt; record
SeqRecord(seq=Seq('TGTAACGAACGGTGCAATAGTGATCCACACCCAACGCCTGAAATCAGATCCAGG...CTG',
IUPACAmbiguousDNA()), id='NC_005816.1', name='NC_005816',
description='Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, complete sequence.',
dbxrefs=['Project:10638'])
</PRE><P>You should be able to spot some differences already! But taking the attributes individually,
the sequence string is the same as before, but this time <CODE>Bio.SeqIO</CODE> has been able to automatically assign a more specific alphabet (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A> for details):</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.seq
Seq('TGTAACGAACGGTGCAATAGTGATCCACACCCAACGCCTGAAATCAGATCCAGG...CTG', IUPACAmbiguousDNA())
</PRE><P>The <CODE>name</CODE> comes from the LOCUS line, while the <CODE>id</CODE> includes the version suffix.
The description comes from the DEFINITION line:</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.id
'NC_005816.1'
&gt;&gt;&gt; record.name
'NC_005816'
&gt;&gt;&gt; record.description
'Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, complete sequence.'
</PRE><P>GenBank files don&#X2019;t have any per-letter annotations:</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.letter_annotations
{}
</PRE><P>Most of the annotations information gets recorded in the <CODE>annotations</CODE> dictionary, for example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; len(record.annotations)
11
&gt;&gt;&gt; record.annotations["source"]
'Yersinia pestis biovar Microtus str. 91001'
</PRE><P>The <CODE>dbxrefs</CODE> list gets populated from any PROJECT or DBLINK lines:</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.dbxrefs
['Project:10638']
</PRE><P>Finally, and perhaps most interestingly, all the entries in the features table (e.g. the genes or CDS features) get recorded as <CODE>SeqFeature</CODE> objects in the <CODE>features</CODE> list.</P><PRE CLASS="verbatim">&gt;&gt;&gt; len(record.features)
29
</PRE><P>We&#X2019;ll talk about <CODE>SeqFeature</CODE> objects next, in
Section&#XA0;<A HREF="#sec:seq_features">4.3</A>.</P><!--TOC section SeqFeature objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">4.3</A>&#XA0;&#XA0;SeqFeature objects</H2><!--SEC END --><P>
<A NAME="sec:seq_features"></A></P><P>Sequence features are an essential part of describing a sequence. Once you get beyond the sequence itself, you need some way to organize and easily get at the more &#X201C;abstract&#X201D; information that is known about the sequence. While it is probably impossible to develop a general sequence feature class that will cover everything, the Biopython <CODE>SeqFeature</CODE> class attempts to encapsulate as much of the information about the sequence as possible. The design is heavily based on the GenBank/EMBL feature tables, so if you understand how they look, you&#X2019;ll probably have an easier time grasping the structure of the Biopython classes.</P><!--TOC subsection SeqFeatures themselves-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">4.3.1</A>&#XA0;&#XA0;SeqFeatures themselves</H3><!--SEC END --><P>The first level of dealing with sequence features is the <CODE>SeqFeature</CODE> class itself. This class has a number of attributes, so first we&#X2019;ll list them and their general features, and then work through an example to show how this applies to a real life example, a GenBank feature table. The attributes of a SeqFeature are:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>location</B></DT><DD CLASS="dd-description"> &#X2013; The location of the <CODE>SeqFeature</CODE> on the sequence that you are dealing with. The locations end-points may be fuzzy &#X2013; section&#XA0;<A HREF="#sec:locations">4.3.2</A> has a lot more description on how to deal with descriptions.</DD><DT CLASS="dt-description"><B>type</B></DT><DD CLASS="dd-description"> &#X2013; This is a textual description of the type of feature (for instance, this will be something like &#X2018;CDS&#X2019; or &#X2018;gene&#X2019;).</DD><DT CLASS="dt-description"><B>ref</B></DT><DD CLASS="dd-description"> &#X2013; A reference to a different sequence. Some times features may be &#X201C;on&#X201D; a particular sequence, but may need to refer to a different sequence, and this provides the reference (normally an accession number). A good example of this is a genomic sequence that has most of a coding sequence, but one of the exons is on a different accession. In this case, the feature would need to refer to this different accession for this missing exon. You are most likely to see this in contig GenBank files.</DD><DT CLASS="dt-description"><B>ref_db</B></DT><DD CLASS="dd-description"> &#X2013; This works along with <CODE>ref</CODE> to provide a cross sequence reference. If there is a reference, <CODE>ref_db</CODE> will be set as None if the reference is in the same database, and will be set to the name of the database otherwise.</DD><DT CLASS="dt-description"><B>strand</B></DT><DD CLASS="dd-description"> &#X2013; The strand on the sequence that the feature is located on. This may either be 1 for the top strand, &#X2212;1 for the bottom strand, or 0 or <TT>None</TT> for both strands (or if it doesn&#X2019;t matter). Keep in mind that this only really makes sense for double stranded DNA, and not for proteins or RNA.</DD><DT CLASS="dt-description"><B>qualifiers</B></DT><DD CLASS="dd-description"> &#X2013; This is a Python dictionary of additional information about the feature. The key is some kind of terse one-word description of what the information contained in the value is about, and the value is the actual information. For example, a common key for a qualifier might be &#X201C;evidence&#X201D; and the value might be &#X201C;computational (non-experimental).&#X201D; This is just a way to let the person who is looking at the feature know that it has not be experimentally (i.&#XA0;e.&#XA0;in a wet lab) confirmed. Note that other the value will be a list of strings (even when there is only one string). This is a reflection of the feature tables in GenBank/EMBL files.</DD><DT CLASS="dt-description"><B>sub_features</B></DT><DD CLASS="dd-description"> &#X2013; A very important feature of a feature is that it can have additional <CODE>sub_features</CODE> underneath it. This allows nesting of features, and helps us to deal with things such as the GenBank/EMBL feature lines in a (we hope) intuitive way.</DD></DL><P>To show an example of SeqFeatures in action, let&#X2019;s take a look at the following feature from a GenBank feature table:</P><PRE CLASS="verbatim">     mRNA            complement(join(&lt;49223..49300,49780..&gt;50208))
                     /gene="F28B23.12"
</PRE><P>To look at the easiest attributes of the <CODE>SeqFeature</CODE> first, if you got a <CODE>SeqFeature</CODE> object for this it would have it <CODE>type</CODE> of &#X2019;mRNA&#X2019;, a <CODE>strand</CODE> of -1 (due to the &#X2018;complement&#X2019;), and would have None for the <CODE>ref</CODE> and <CODE>ref_db</CODE> since there are no references to external databases. The <CODE>qualifiers</CODE> for this SeqFeature would be a Python dictionary that looked like <CODE>{'gene' : ['F28B23.12']}</CODE>.</P><P>Now let&#X2019;s look at the more tricky part, how the &#X2018;join&#X2019; in the location
line is handled. First, the location for the top level <CODE>SeqFeature</CODE> (the
one we are dealing with right now) is set as going from
<CODE>`&lt;49223' to `&gt;50208'</CODE> (see section&#XA0;<A HREF="#sec:locations">4.3.2</A> for
the nitty gritty on how fuzzy locations like this are handled).
So the location of the top level object is the entire span of the
feature. So, how do you get at the information in the &#X2018;join&#X2019;?
Well, that&#X2019;s where the <CODE>sub_features</CODE> go in.</P><P>The <CODE>sub_features</CODE> attribute will have a list with two <CODE>SeqFeature</CODE>
objects in it, and these contain the information in the join. Let&#X2019;s
look at <CODE>top_level_feature.sub_features[0]</CODE> (the first
<CODE>sub_feature</CODE>). This object is a <CODE>SeqFeature</CODE> object with a
<CODE>type</CODE> of &#X2018;<CODE>mRNA</CODE>,&#X2019; a <CODE>strand</CODE> of -1 (inherited
from the parent <CODE>SeqFeature</CODE>) and a location going from
<CODE>'&lt;49223' to '49300'</CODE>.</P><P>So, the <CODE>sub_features</CODE> allow you to get at the internal information if you want it (i.&#XA0;e.&#XA0;if you were trying to get only the exons out of a genomic sequence), or just to deal with the broad picture (i.&#XA0;e.&#XA0;you just want to know that the coding sequence for a gene lies in a region). Hopefully this structuring makes it easy and intuitive to get at the sometimes complex information that can be contained in a <CODE>SeqFeature</CODE>.</P><!--TOC subsection Locations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">4.3.2</A>&#XA0;&#XA0;Locations</H3><!--SEC END --><P>
<A NAME="sec:locations"></A></P><P>In the section on SeqFeatures above, we skipped over one of the more difficult parts of features, dealing with the locations. The reason this can be difficult is because of fuzziness of the positions in locations. Before we get into all of this, let&#X2019;s just define the vocabulary we&#X2019;ll use to talk about this. Basically there are two terms we&#X2019;ll use:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>position</B></DT><DD CLASS="dd-description"> &#X2013; This refers to a single position on a sequence,
which may be fuzzy or not. For instance, 5, 20, <CODE>&lt;100</CODE> and
<CODE>3^5</CODE> are all positions.</DD><DT CLASS="dt-description"><B>location</B></DT><DD CLASS="dd-description"> &#X2013; A location is two positions that defines a region of a sequence. For instance 5..20 (i.&#XA0;e.&#XA0;5 to 20) is a location.
</DD></DL><P>I just mention this because sometimes I get confused between the two.</P><P>The complication in dealing with locations comes in the positions themselves. In biology many times things aren&#X2019;t entirely certain (as much as us wet lab biologists try to make them certain!). For instance, you might do a dinucleotide priming experiment and discover that the start of mRNA transcript starts at one of two sites. This is very useful information, but the complication comes in how to represent this as a position. To help us deal with this, we have the concept of fuzzy positions. Basically there are five types of fuzzy positions, so we have five classes do deal with them:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>ExactPosition</B></DT><DD CLASS="dd-description"> &#X2013; As its name suggests, this class represents a position which is specified as exact along the sequence. This is represented as just a a number, and you can get the position by looking at the <CODE>position</CODE> attribute of the object.</DD><DT CLASS="dt-description"><B>BeforePosition</B></DT><DD CLASS="dd-description"> &#X2013; This class represents a fuzzy position
that occurs prior to some specified site. In GenBank/EMBL notation,
this is represented as something like <CODE>`&lt;13'</CODE>, signifying that
the real position is located somewhere less then 13. To get
the specified upper boundary, look at the <CODE>position</CODE>
attribute of the object.</DD><DT CLASS="dt-description"><B>AfterPosition</B></DT><DD CLASS="dd-description"> &#X2013; Contrary to <CODE>BeforePosition</CODE>, this
class represents a position that occurs after some specified site.
This is represented in GenBank as <CODE>`&gt;13'</CODE>, and like
<CODE>BeforePosition</CODE>, you get the boundary number by looking
at the <CODE>position</CODE> attribute of the object.</DD><DT CLASS="dt-description"><B>WithinPosition</B></DT><DD CLASS="dd-description"> &#X2013; This class models a position which occurs somewhere between two specified nucleotides. In GenBank/EMBL notation, this would be represented as &#X2018;(1.5)&#X2019;, to represent that the position is somewhere within the range 1 to 5. To get the information in this class you have to look at two attributes. The <CODE>position</CODE> attribute specifies the lower boundary of the range we are looking at, so in our example case this would be one. The <CODE>extension</CODE> attribute specifies the range to the higher boundary, so in this case it would be 4. So <CODE>object.position</CODE> is the lower boundary and <CODE>object.position + object.extension</CODE> is the upper boundary.</DD><DT CLASS="dt-description"><B>BetweenPosition</B></DT><DD CLASS="dd-description"> &#X2013; This class deals with a position that
occurs between two coordinates. For instance, you might have a
protein binding site that occurs between two nucleotides on a
sequence. This is represented as <CODE>`2^3'</CODE>, which indicates that
the real position happens between position 2 and 3. Getting
this information from the object is very similar to
<CODE>WithinPosition</CODE>, the <CODE>position</CODE> attribute specifies
the lower boundary (2, in this case) and the <CODE>extension</CODE>
indicates the range to the higher boundary (1 in this case).
</DD></DL><P>Now that we&#X2019;ve got all of the types of fuzzy positions we can have taken care of, we are ready to actually specify a location on a sequence. This is handled by the <CODE>FeatureLocation</CODE> class. An object of this type basically just holds the potentially fuzzy start and end positions of a feature. You can create a <CODE>FeatureLocation</CODE> object by creating the positions and passing them in:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqFeature
&gt;&gt;&gt; start_pos = SeqFeature.AfterPosition(5)
&gt;&gt;&gt; end_pos = SeqFeature.BetweenPosition(9, left=8, right=9)
&gt;&gt;&gt; my_location = SeqFeature.FeatureLocation(start_pos, end_pos)
</PRE><P>Note that the details of some of the fuzzy-locations changed in Biopython 1.59,
in particular for BetweenPosition and WithinPosition you must now make it explicit
which integer position should be used for slicing etc. For a start position this
is generally the lower (left) value, while for an end position this would generally
be the higher (right) value.</P><P>If you print out a <CODE>FeatureLocation</CODE> object, you can get a nice representation of the information:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print my_location
[&gt;5:(8^9)]
</PRE><P>We can access the fuzzy start and end positions using the start and end attributes of the location:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_location.start
AfterPosition(5)
&gt;&gt;&gt; print my_location.start
&gt;5
&gt;&gt;&gt; my_location.end
BetweenPosition(9, left=8, right=9)
&gt;&gt;&gt; print my_location.end
(8^9)
</PRE><P>If you don&#X2019;t want to deal with fuzzy positions and just want numbers,
they are actually subclasses of integers so should work like integers:</P><PRE CLASS="verbatim">&gt;&gt;&gt; int(my_location.start)
5
&gt;&gt;&gt; int(my_location.end)
9
</PRE><P>For compatibility with older versions of Biopython you can ask for the
<CODE>nofuzzy_start</CODE> and <CODE>nofuzzy_end</CODE> attributes of the location
which are plain integers:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_location.nofuzzy_start
5
&gt;&gt;&gt; my_location.nofuzzy_end
9
</PRE><P>Notice that this just gives you back the position attributes of the fuzzy locations.</P><P>Similary, to make it easy to create a position without worrying about fuzzy positions, you can just pass in numbers to the <CODE>FeaturePosition</CODE> constructors, and you&#X2019;ll get back out <CODE>ExactPosition</CODE> objects:</P><PRE CLASS="verbatim">&gt;&gt;&gt; exact_location = SeqFeature.FeatureLocation(5, 9)
&gt;&gt;&gt; print exact_location
[5:9]
&gt;&gt;&gt; exact_location.start
ExactPosition(5)
&gt;&gt;&gt; int(exact_location.start)
5
&gt;&gt;&gt; exact_location.nofuzzy_start
5
</PRE><P>That is all of the nitty gritty about dealing with fuzzy positions in Biopython. It has been designed so that dealing with fuzziness is not that much more complicated than dealing with exact positions, and hopefully you find that true!</P><!--TOC subsection Sequence-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">4.3.3</A>&#XA0;&#XA0;Sequence</H3><!--SEC END --><P>A <CODE>SeqFeature</CODE> object doesn&#X2019;t directly contain a sequence, instead its location (see Section&#XA0;<A HREF="#sec:locations">4.3.2</A>) describes how to get this from the parent sequence. For example consider a (short) gene sequence with location 5:18 on the reverse strand, which in GenBank/EMBL notation using 1-based counting would be <TT>complement(6..18)</TT>, like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.SeqFeature import SeqFeature, FeatureLocation
&gt;&gt;&gt; example_parent = Seq("ACCGAGACGGCAAAGGCTAGCATAGGTATGAGACTTCCTTCCTGCCAGTGCTGAGGAACTGGGAGCCTAC")
&gt;&gt;&gt; example_feature = SeqFeature(FeatureLocation(5, 18), type="gene", strand=-1)
</PRE><P>You could take the parent sequence, slice it to extract 5:18, and then take the reverse complement.
If you are using Biopython 1.59 or later, the feature location&#X2019;s start and end are integer like so this works:</P><PRE CLASS="verbatim">&gt;&gt;&gt; feature_seq = example_parent[example_feature.location.start:example_feature.location.end].reverse_complement()
&gt;&gt;&gt; print feature_seq
AGCCTTTGCCGTC
</PRE><P>This is a simple example so this isn&#X2019;t too bad &#X2013; however once you have to deal with compound features (joins) this is rather messy. Instead, the <CODE>SeqFeature</CODE> object has an <CODE>extract</CODE> method to take care of all this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; feature_seq = example_feature.extract(example_parent)
&gt;&gt;&gt; print feature_seq
AGCCTTTGCCGTC
</PRE><P>The <CODE>extract</CODE> method was added in Biopython 1.53, and in Biopython 1.56 the <CODE>SeqFeature</CODE> was further extended to give its length as that of the region of sequence it describes.</P><PRE CLASS="verbatim">&gt;&gt;&gt; print example_feature.extract(example_parent)
AGCCTTTGCCGTC
&gt;&gt;&gt; print len(example_feature.extract(example_parent))
13
&gt;&gt;&gt; print len(example_feature)
13
</PRE><!--TOC section Location testing-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc41">4.4</A>&#XA0;&#XA0;Location testing</H2><!--SEC END --><P>As of Biopython 1.56, you can use the Python keyword <CODE>in</CODE> with a
<CODE>SeqFeature</CODE> to see if the base/residue for a parent coordinate is
within the feature or not.</P><P>For example, suppose you have a SNP of interest and you want to know which
features this SNP is within, and lets suppose this SNP is at index 4350
(Python counting!). Here is a simple brute force solution where we just
check all the features one by one in a loop:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; my_snp = 4350
&gt;&gt;&gt; record = SeqIO.read("NC_005816.gb", "genbank")
&gt;&gt;&gt; for feature in record.features:
...     if my_snp in feature:
...         print feature.type, feature.qualifiers.get('db_xref')
...
source ['taxon:229193']
gene ['GeneID:2767712']
CDS ['GI:45478716', 'GeneID:2767712']
</PRE><P>Note that gene and CDS features from GenBank or EMBL files defined with joins
are the union of the exons &#X2013; they do not cover any introns.</P><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc42">4.5</A>&#XA0;&#XA0;References</H2><!--SEC END --><P>Another common annotation related to a sequence is a reference to a journal or other published work dealing with the sequence. We have a fairly simple way of representing a Reference in Biopython &#X2013; we have a <CODE>Bio.SeqFeature.Reference</CODE> class that stores the relevant information about a reference as attributes of an object.</P><P>The attributes include things that you would expect to see in a reference like <CODE>journal</CODE>, <CODE>title</CODE> and <CODE>authors</CODE>. Additionally, it also can hold the <CODE>medline_id</CODE> and <CODE>pubmed_id</CODE> and a <CODE>comment</CODE> about the reference. These are all accessed simply as attributes of the object.</P><P>A reference also has a <CODE>location</CODE> object so that it can specify a particular location on the sequence that the reference refers to. For instance, you might have a journal that is dealing with a particular gene located on a BAC, and want to specify that it only refers to this position exactly. The <CODE>location</CODE> is a potentially fuzzy location, as described in section&#XA0;<A HREF="#sec:locations">4.3.2</A>.</P><P>Any reference objects are stored as a list in the <CODE>SeqRecord</CODE> object&#X2019;s <CODE>annotations</CODE> dictionary under the key &#X201C;references&#X201D;.
That&#X2019;s all there is too it. References are meant to be easy to deal with, and hopefully general enough to cover lots of usage cases.</P><!--TOC section The format method-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc43">4.6</A>&#XA0;&#XA0;The format method</H2><!--SEC END --><P>
<A NAME="sec:SeqRecord-format"></A></P><P>Biopython 1.48 added a new <CODE>format()</CODE> method to the <CODE>SeqRecord</CODE> class which
gives a string containing your record formatted using one of the output file formats
supported by <CODE>Bio.SeqIO</CODE>, such as FASTA:</P><PRE CLASS="verbatim">from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Alphabet import generic_protein

record = SeqRecord(Seq("MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGD" \
                      +"GAGAVIVGSDPDLSVERPLYELVWTGATLLPDSEGAIDGHLREVGLTFHLLKDVPGLISK" \
                      +"NIEKSLKEAFTPLGISDWNSTFWIAHPGGPAILDQVEAKLGLKEEKMRATREVLSEYGNM" \
                      +"SSAC", generic_protein),
                   id="gi|14150838|gb|AAK54648.1|AF376133_1",
                   description="chalcone synthase [Cucumis sativus]")
                   
print record.format("fasta")
</PRE><P>which should give:
</P><PRE CLASS="verbatim">&gt;gi|14150838|gb|AAK54648.1|AF376133_1 chalcone synthase [Cucumis sativus]
MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGD
GAGAVIVGSDPDLSVERPLYELVWTGATLLPDSEGAIDGHLREVGLTFHLLKDVPGLISK
NIEKSLKEAFTPLGISDWNSTFWIAHPGGPAILDQVEAKLGLKEEKMRATREVLSEYGNM
SSAC
</PRE><P>This <CODE>format</CODE> method takes a single mandatory argument, a lower case string which is
supported by <CODE>Bio.SeqIO</CODE> as an output format (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>).
However, some of the file formats <CODE>Bio.SeqIO</CODE> can write to <EM>require</EM> more than
one record (typically the case for multiple sequence alignment formats), and thus won&#X2019;t
work via this <CODE>format()</CODE> method. See also Section&#XA0;<A HREF="#sec:Bio.SeqIO-and-StringIO">5.5.4</A>.</P><!--TOC section Slicing a SeqRecord-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">4.7</A>&#XA0;&#XA0;Slicing a SeqRecord</H2><!--SEC END --><P>
<A NAME="sec:SeqRecord-slicing"></A></P><P>One of the new features in Biopython 1.50 was the ability to slice a <CODE>SeqRecord</CODE>,
to give you a new <CODE>SeqRecord</CODE> covering just part of the sequence. What is important
here is that any per-letter annotations are also sliced, and any features which fall
completely within the new sequence are preserved (with their locations adjusted).</P><P>For example, taking the same GenBank file used earlier:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read("NC_005816.gb", "genbank")
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; record
SeqRecord(seq=Seq('TGTAACGAACGGTGCAATAGTGATCCACACCCAACGCCTGAAATCAGATCCAGG...CTG',
IUPACAmbiguousDNA()), id='NC_005816.1', name='NC_005816',
description='Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, complete sequence.',
dbxrefs=['Project:10638'])
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; len(record)
9609
&gt;&gt;&gt; len(record.features)
41
</PRE><P>For this example we&#X2019;re going to focus in on the <CODE>pim</CODE> gene, <CODE>YP_pPCP05</CODE>.
If you have a look at the GenBank file directly you&#X2019;ll find this gene/CDS has
location string <TT>4343..4780</TT>, or in Python counting <TT>4342:4780</TT>.
From looking at the file you can work out that these are the twelfth and
thirteenth entries in the file, so in Python zero-based counting they are
entries 11 and 12 in the <TT>features</TT> list:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record.features[20]
type: gene
location: [4342:4780](+)
qualifiers: 
    Key: db_xref, Value: ['GeneID:2767712']
    Key: gene, Value: ['pim']
    Key: locus_tag, Value: ['YP_pPCP05']
&lt;BLANKLINE&gt;
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; print record.features[21]
type: CDS
location: [4342:4780](+)
qualifiers: 
    Key: codon_start, Value: ['1']
    Key: db_xref, Value: ['GI:45478716', 'GeneID:2767712']
    Key: gene, Value: ['pim']
    Key: locus_tag, Value: ['YP_pPCP05']
    Key: note, Value: ['similar to many previously sequenced pesticin immunity ...']
    Key: product, Value: ['pesticin immunity protein']
    Key: protein_id, Value: ['NP_995571.1']
    Key: transl_table, Value: ['11']
    Key: translation, Value: ['MGGGMISKLFCLALIFLSSSGLAEKNTYTAKDILQNLELNTFGNSLSH...']
</PRE><P>Let&#X2019;s slice this parent record from 4300 to 4800 (enough to include the <CODE>pim</CODE>
gene/CDS), and see how many features we get:</P><PRE CLASS="verbatim">&gt;&gt;&gt; sub_record = record[4300:4800]
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; sub_record
SeqRecord(seq=Seq('ATAAATAGATTATTCCAAATAATTTATTTATGTAAGAACAGGATGGGAGGGGGA...TTA',
IUPACAmbiguousDNA()), id='NC_005816.1', name='NC_005816',
description='Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, complete sequence.',
dbxrefs=[])
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; len(sub_record)
500
&gt;&gt;&gt; len(sub_record.features)
2
</PRE><P>Our sub-record just has two features, the gene and CDS entries for <CODE>YP_pPCP05</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print sub_record.features[0]
type: gene
location: [42:480](+)
qualifiers: 
    Key: db_xref, Value: ['GeneID:2767712']
    Key: gene, Value: ['pim']
    Key: locus_tag, Value: ['YP_pPCP05']
&lt;BLANKLINE&gt;
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; print sub_record.features[20]
type: CDS
location: [42:480](+)
qualifiers: 
    Key: codon_start, Value: ['1']
    Key: db_xref, Value: ['GI:45478716', 'GeneID:2767712']
    Key: gene, Value: ['pim']
    Key: locus_tag, Value: ['YP_pPCP05']
    Key: note, Value: ['similar to many previously sequenced pesticin immunity ...']
    Key: product, Value: ['pesticin immunity protein']
    Key: protein_id, Value: ['NP_995571.1']
    Key: transl_table, Value: ['11']
    Key: translation, Value: ['MGGGMISKLFCLALIFLSSSGLAEKNTYTAKDILQNLELNTFGNSLSH...']
</PRE><P>Notice that their locations have been adjusted to reflect the new parent sequence!</P><P>While Biopython has done something sensible and hopefully intuitive with the features
(and any per-letter annotation), for the other annotation it is impossible to know if
this still applies to the sub-sequence or not. To avoid guessing, the <TT>annotations</TT>
and <TT>dbxrefs</TT> are omitted from the sub-record, and it is up to you to transfer
any relevant information as appropriate.</P><PRE CLASS="verbatim">&gt;&gt;&gt; sub_record.annotations
{}
&gt;&gt;&gt; sub_record.dbxrefs
[]
</PRE><P>The same point could be made about the record <TT>id</TT>, <TT>name</TT>
and <TT>description</TT>, but for practicality these are preserved:</P><PRE CLASS="verbatim">&gt;&gt;&gt; sub_record.id
'NC_005816.1'
&gt;&gt;&gt; sub_record.name
'NC_005816'
&gt;&gt;&gt; sub_record.description
'Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, complete sequence.'
</PRE><P>This illustrates the problem nicely though, our new sub-record is
<EM>not</EM> the complete sequence of the plasmid, so the description is wrong!
Let&#X2019;s fix this and then view the sub-record as a reduced GenBank file using
the <TT>format</TT> method described above in Section&#XA0;<A HREF="#sec:SeqRecord-format">4.6</A>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; sub_record.description = "Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, partial."
&gt;&gt;&gt; print sub_record.format("genbank")
...
</PRE><P>See Sections&#XA0;<A HREF="#sec:FASTQ-slicing-off-primer">16.1.7</A>
and&#XA0;<A HREF="#sec:FASTQ-slicing-off-adaptor">16.1.8</A> for some FASTQ examples where the
per-letter annotations (the read quality scores) are also sliced.</P><!--TOC section Adding SeqRecord objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc45">4.8</A>&#XA0;&#XA0;Adding SeqRecord objects</H2><!--SEC END --><P>
<A NAME="sec:SeqRecord-addition"></A></P><P>One of the new features in Biopython 1.53 was the ability to add <CODE>SeqRecord</CODE> objects
together, giving a new <CODE>SeqRecord</CODE>. What is important here is that any common
per-letter annotations are also added, all the features are preserved (with their
locations adjusted), and any other common annotation is also kept (like the id, name
and description).</P><P>For an example with per-letter annotation, we&#X2019;ll use the first record in a
FASTQ file. Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A> will explain the <CODE>SeqIO</CODE> functions:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.parse("example.fastq", "fastq").next()
&gt;&gt;&gt; len(record)
25
&gt;&gt;&gt; print record.seq
CCCTTCTTGTCTTCAGCGTTTCTCC
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; print record.letter_annotations["phred_quality"]
[26, 26, 18, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 22, 26, 26, 26, 26,
26, 26, 26, 23, 23]
</PRE><P>Let&#X2019;s suppose this was Roche 454 data, and that from other information
you think the <TT>TTT</TT> should be only <TT>TT</TT>. We can make a new edited
record by first slicing the <CODE>SeqRecord</CODE> before and after the &#X201C;extra&#X201D;
third <TT>T</TT>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; left = record[:20]
&gt;&gt;&gt; print left.seq
CCCTTCTTGTCTTCAGCGTT
&gt;&gt;&gt; print left.letter_annotations["phred_quality"]
[26, 26, 18, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 22, 26, 26, 26, 26]
&gt;&gt;&gt; right = record[21:]
&gt;&gt;&gt; print right.seq
CTCC
&gt;&gt;&gt; print right.letter_annotations["phred_quality"]
[26, 26, 23, 23]
</PRE><P>Now add the two parts together:</P><PRE CLASS="verbatim">&gt;&gt;&gt; edited = left + right
&gt;&gt;&gt; len(edited)
24
&gt;&gt;&gt; print edited.seq
CCCTTCTTGTCTTCAGCGTTCTCC
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; print edited.letter_annotations["phred_quality"]
[26, 26, 18, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 22, 26, 26, 26, 26,
26, 26, 23, 23]
</PRE><P>Easy and intuitive? We hope so! You can make this shorter with just:</P><PRE CLASS="verbatim">&gt;&gt;&gt; edited = record[:20] + record[21:]
</PRE><P>Now, for an example with features, we&#X2019;ll use a GenBank file.
Suppose you have a circular genome:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read("NC_005816.gb", "genbank")
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; record
SeqRecord(seq=Seq('TGTAACGAACGGTGCAATAGTGATCCACACCCAACGCCTGAAATCAGATCCAGG...CTG',
IUPACAmbiguousDNA()), id='NC_005816.1', name='NC_005816',
description='Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, complete sequence.',
dbxrefs=['Project:10638'])
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; len(record)
9609
&gt;&gt;&gt; len(record.features)
41
&gt;&gt;&gt; record.dbxrefs
['Project:58037']
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; record.annotations.keys()
['comment', 'sequence_version', 'source', 'taxonomy', 'keywords', 'references',
'accessions', 'data_file_division', 'date', 'organism', 'gi']
</PRE><P>You can shift the origin like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; shifted = record[2000:] + record[:2000]
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; shifted
SeqRecord(seq=Seq('GATACGCAGTCATATTTTTTACACAATTCTCTAATCCCGACAAGGTCGTAGGTC...GGA',
IUPACAmbiguousDNA()), id='NC_005816.1', name='NC_005816',
description='Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, complete sequence.',
dbxrefs=[])
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; len(shifted)
9609
</PRE><P>Note that this isn&#X2019;t perfect in that some annotation like the database cross references
and one of the features (the source feature) have been lost:</P><PRE CLASS="verbatim">&gt;&gt;&gt; len(shifted.features)
40
&gt;&gt;&gt; shifted.dbxrefs
[]
&gt;&gt;&gt; shifted.annotations.keys()
[]
</PRE><P>This is because the <CODE>SeqRecord</CODE> slicing step is cautious in what annotation
it preserves (erroneously propagating annotation can cause major problems). If
you want to keep the database cross references or the annotations dictionary,
this must be done explicitly:</P><PRE CLASS="verbatim">&gt;&gt;&gt; shifted.dbxrefs = record.dbxrefs[:]
&gt;&gt;&gt; shifted.annotations = record.annotations.copy()
&gt;&gt;&gt; shifted.dbxrefs
['Project:10638']
&gt;&gt;&gt; shifted.annotations.keys()
['comment', 'sequence_version', 'source', 'taxonomy', 'keywords', 'references',
'accessions', 'data_file_division', 'date', 'organism', 'gi']
</PRE><P>Also note that in an example like this, you should probably change the record
identifiers since the NCBI references refer to the <EM>original</EM> unmodified
sequence.</P><!--TOC section Reverse-complementing SeqRecord objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc46">4.9</A>&#XA0;&#XA0;Reverse-complementing SeqRecord objects</H2><!--SEC END --><P>
<A NAME="sec:SeqRecord-reverse-complement"></A></P><P>One of the new features in Biopython 1.57 was the <CODE>SeqRecord</CODE> object&#X2019;s
<CODE>reverse_complement</CODE> method. This tries to balance easy of use with worries
about what to do with the annotation in the reverse complemented record.</P><P>For the sequence, this uses the Seq object&#X2019;s reverse complement method. Any
features are transferred with the location and strand recalculated. Likewise
any per-letter-annotation is also copied but reversed (which makes sense for
typical examples like quality scores). However, transfer of most annotation
is problematical.</P><P>For instance, if the record ID was an accession, that accession should not really
apply to the reverse complemented sequence, and transferring the identifier by
default could easily cause subtle data corruption in downstream analysis.
Therefore by default, the <CODE>SeqRecord</CODE>&#X2019;s id, name, description, annotations
and database cross references are all <EM>not</EM> transferred by default.</P><P>The <CODE>SeqRecord</CODE> object&#X2019;s <CODE>reverse_complement</CODE> method takes a number
of optional arguments corresponding to properties of the record. Setting these
arguments to <CODE>True</CODE> means copy the old values, while <CODE>False</CODE> means
drop the old values and use the default value. You can alternatively provide
the new desired value instead.</P><P>Consider this example record:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read("NC_005816.gb", "genbank")
&gt;&gt;&gt; print record.id, len(record), len(record.features), len(record.dbxrefs), len(record.annotations)
NC_005816.1 9609 41 1 11
</PRE><P>Here we take the reverse complement and specify a new identifier &#X2013; but notice
how most of the annotation is dropped (but not the features):</P><PRE CLASS="verbatim">&gt;&gt;&gt; rc = record.reverse_complement(id="TESTING")
&gt;&gt;&gt; print rc.id, len(rc), len(rc.features), len(rc.dbxrefs), len(rc.annotations)
TESTING 9609 41 0 0
</PRE><!--TOC chapter Sequence Input/Output-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc47">Chapter&#XA0;5</A>&#XA0;&#XA0;Sequence Input/Output</H1><!--SEC END --><P>
<A NAME="chapter:Bio.SeqIO"></A></P><P>In this chapter we&#X2019;ll discuss in more detail the <CODE>Bio.SeqIO</CODE> module, which was briefly introduced in Chapter&#XA0;<A HREF="#chapter:quick-start">2</A> and also used in Chapter&#XA0;<A HREF="#chapter:SeqRecord">4</A>. This aims to provide a simple interface for working with assorted sequence file formats in a uniform way.
See also the <CODE>Bio.SeqIO</CODE> wiki page (<A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A>), and the built in documentation (also <A HREF="http://biopython.org/DIST/docs/api/Bio.SeqIO-module.html">online</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; help(SeqIO)
...
</PRE><P>The &#X201C;catch&#X201D; is that you have to work with <CODE>SeqRecord</CODE> objects (see Chapter&#XA0;<A HREF="#chapter:SeqRecord">4</A>), which contain a <CODE>Seq</CODE> object (see Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A>) plus annotation like an identifier and description.</P><!--TOC section Parsing or Reading Sequences-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc48">5.1</A>&#XA0;&#XA0;Parsing or Reading Sequences</H2><!--SEC END --><P>
<A NAME="sec:Bio.SeqIO-input"></A></P><P>The workhorse function <CODE>Bio.SeqIO.parse()</CODE> is used to read in sequence data as SeqRecord objects. This function expects two arguments:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The first argument is a <I>handle</I> to read the data from, or a filename. A handle is typically a file opened for reading, but could be the output from a command line program, or data downloaded from the internet (see Section&#XA0;<A HREF="#sec:SeqIO_Online">5.3</A>). See Section&#XA0;<A HREF="#sec:appendix-handles">20.1</A> for more about handles.
</LI><LI CLASS="li-enumerate">The second argument is a lower case string specifying sequence format &#X2013; we don&#X2019;t try and guess the file format for you! See <A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A> for a full listing of supported formats.
</LI></OL><P>As of Biopython 1.49 there is an optional argument <CODE>alphabet</CODE> to specify the alphabet to be used. This is useful for file formats like FASTA where otherwise <CODE>Bio.SeqIO</CODE> will default to a generic alphabet.</P><P>The <CODE>Bio.SeqIO.parse()</CODE> function returns an <I>iterator</I> which gives <CODE>SeqRecord</CODE> objects. Iterators are typically used in a for loop as shown below.</P><P>Sometimes you&#X2019;ll find yourself dealing with files which contain only a single record. For this situation Biopython 1.45 introduced the function <CODE>Bio.SeqIO.read()</CODE> which takes the same arguments. Provided there is one and only one record in the file, this is returned as a <CODE>SeqRecord</CODE> object. Otherwise an exception is raised.</P><!--TOC subsection Reading Sequence Files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc49">5.1.1</A>&#XA0;&#XA0;Reading Sequence Files</H3><!--SEC END --><P>In general <CODE>Bio.SeqIO.parse()</CODE> is used to read in sequence files as <CODE>SeqRecord</CODE> objects, and is typically used with a for loop like this:</P><PRE CLASS="verbatim">from Bio import SeqIO
for seq_record in SeqIO.parse("ls_orchid.fasta", "fasta"):
    print seq_record.id
    print repr(seq_record.seq)
    print len(seq_record)
</PRE><P>The above example is repeated from the introduction in Section&#XA0;<A HREF="#sec:sequence-parsing">2.4</A>, and will load the orchid DNA sequences in the FASTA format file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta">ls_orchid.fasta</A>. If instead you wanted to load a GenBank format file like <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">ls_orchid.gbk</A> then all you need to do is change the filename and the format string:</P><PRE CLASS="verbatim">from Bio import SeqIO
for seq_record in SeqIO.parse("ls_orchid.gbk", "genbank"):
    print seq_record.id
    print seq_record.seq
    print len(seq_record)
</PRE><P>Similarly, if you wanted to read in a file in another file format, then assuming <CODE>Bio.SeqIO.parse()</CODE> supports it you would just need to change the format string as appropriate, for example &#X201C;swiss&#X201D; for SwissProt files or &#X201C;embl&#X201D; for EMBL text files. There is a full listing on the wiki page (<A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A>) and in the built in documentation (also <A HREF="http://biopython.org/DIST/docs/api/Bio.SeqIO-module.html">online</A>).</P><P>Another very common way to use a Python iterator is within a list comprehension (or
a generator expression). For example, if all you wanted to extract from the file was
a list of the record identifiers we can easily do this with the following list comprehension:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; identifiers = [seq_record.id for seq_record in SeqIO.parse("ls_orchid.gbk", "genbank")]
&gt;&gt;&gt; identifiers
['Z78533.1', 'Z78532.1', 'Z78531.1', 'Z78530.1', 'Z78529.1', 'Z78527.1', ..., 'Z78439.1']
</PRE><P>There are more examples using <CODE>SeqIO.parse()</CODE> in a list
comprehension like this in Section&#XA0;<A HREF="#seq:sequence-parsing-plus-pylab">16.2</A>
(e.g. for plotting sequence lengths or GC%).</P><!--TOC subsection Iterating over the records in a sequence file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc50">5.1.2</A>&#XA0;&#XA0;Iterating over the records in a sequence file</H3><!--SEC END --><P>In the above examples, we have usually used a for loop to iterate over all the records one by one. You can use the for loop with all sorts of Python objects (including lists, tuples and strings) which support the iteration interface.</P><P>The object returned by <CODE>Bio.SeqIO</CODE> is actually an iterator which returns <CODE>SeqRecord</CODE> objects. You get to see each record in turn, but once and only once. The plus point is that an iterator can save you memory when dealing with large files.</P><P>Instead of using a for loop, can also use the <CODE>.next()</CODE> method of an iterator to step through the entries, like this:</P><PRE CLASS="verbatim">from Bio import SeqIO
record_iterator = SeqIO.parse("ls_orchid.fasta", "fasta")

first_record = record_iterator.next()
print first_record.id
print first_record.description

second_record = record_iterator.next()
print second_record.id
print second_record.description
</PRE><P>Note that if you try and use <CODE>.next()</CODE> and there are no more results, you&#X2019;ll get the special <CODE>StopIteration</CODE> exception.</P><P>One special case to consider is when your sequence files have multiple records, but you only want the first one. In this situation the following code is very concise:</P><PRE CLASS="verbatim">from Bio import SeqIO
first_record  = SeqIO.parse("ls_orchid.gbk", "genbank").next()
</PRE><P>A word of warning here &#X2013; using the <CODE>.next()</CODE> method like this will silently ignore any additional records in the file.
If your files have <I>one and only one</I> record, like some of the online examples later in this chapter, or a GenBank file for a single chromosome, then use the new <CODE>Bio.SeqIO.read()</CODE> function instead.
This will check there are no extra unexpected records present.</P><!--TOC subsection Getting a list of the records in a sequence file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc51">5.1.3</A>&#XA0;&#XA0;Getting a list of the records in a sequence file</H3><!--SEC END --><P>In the previous section we talked about the fact that <CODE>Bio.SeqIO.parse()</CODE> gives you a <CODE>SeqRecord</CODE> iterator, and that you get the records one by one. Very often you need to be able to access the records in any order. The Python <CODE>list</CODE> data type is perfect for this, and we can turn the record iterator into a list of <CODE>SeqRecord</CODE> objects using the built-in Python function <CODE>list()</CODE> like so:</P><PRE CLASS="verbatim">from Bio import SeqIO
records = list(SeqIO.parse("ls_orchid.gbk", "genbank"))

print "Found %i records" % len(records)

print "The last record"
last_record = records[-1] #using Python's list tricks
print last_record.id
print repr(last_record.seq)
print len(last_record)

print "The first record"
first_record = records[0] #remember, Python counts from zero
print first_record.id
print repr(first_record.seq)
print len(first_record)
</PRE><P>Giving:</P><PRE CLASS="verbatim">Found 94 records
The last record
Z78439.1
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACT...GCC', IUPACAmbiguousDNA())
592
The first record
Z78533.1
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', IUPACAmbiguousDNA())
740
</PRE><P>You can of course still use a for loop with a list of <CODE>SeqRecord</CODE> objects. Using a list is much more flexible than an iterator (for example, you can determine the number of records from the length of the list), but does need more memory because it will hold all the records in memory at once.</P><!--TOC subsection Extracting data-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc52">5.1.4</A>&#XA0;&#XA0;Extracting data</H3><!--SEC END --><P>The <CODE>SeqRecord</CODE> object and its annotation structures are described more fully in
Chapter&#XA0;<A HREF="#chapter:SeqRecord">4</A>. As an example of how annotations are stored, we&#X2019;ll look at the output from parsing the first record in the GenBank file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">ls_orchid.gbk</A>.</P><PRE CLASS="verbatim">from Bio import SeqIO
record_iterator = SeqIO.parse("ls_orchid.gbk", "genbank")
first_record = record_iterator.next()
print first_record
</PRE><P>That should give something like this:</P><PRE CLASS="verbatim">ID: Z78533.1
Name: Z78533
Description: C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA.
Number of features: 5
/sequence_version=1
/source=Cypripedium irapeanum
/taxonomy=['Eukaryota', 'Viridiplantae', 'Streptophyta', ..., 'Cypripedium']
/keywords=['5.8S ribosomal RNA', '5.8S rRNA gene', ..., 'ITS1', 'ITS2']
/references=[...]
/accessions=['Z78533']
/data_file_division=PLN
/date=30-NOV-2006
/organism=Cypripedium irapeanum
/gi=2765658
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', IUPACAmbiguousDNA())
</PRE><P>This gives a human readable summary of most of the annotation data for the <CODE>SeqRecord</CODE>.
For this example we&#X2019;re going to use the <CODE>.annotations</CODE> attribute which is just a Python dictionary.
The contents of this annotations dictionary were shown when we printed the record above.
You can also print them out directly:
</P><PRE CLASS="verbatim">print first_record.annotations
</PRE><P>Like any Python dictionary, you can easily get a list of the keys:
</P><PRE CLASS="verbatim">print first_record.annotations.keys()
</PRE><P>or values:
</P><PRE CLASS="verbatim">print first_record.annotations.values()
</PRE><P>In general, the annotation values are strings, or lists of strings. One special case is any references in the file get stored as reference objects. </P><P>Suppose you wanted to extract a list of the species from the <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">ls_orchid.gbk</A> GenBank file. The information we want, <EM>Cypripedium irapeanum</EM>, is held in the annotations dictionary under &#X2018;source&#X2019; and &#X2018;organism&#X2019;, which we can access like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print first_record.annotations["source"]
Cypripedium irapeanum
</PRE><P>or:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print first_record.annotations["organism"]
Cypripedium irapeanum
</PRE><P>In general, &#X2018;organism&#X2019; is used for the scientific name (in Latin, e.g. <I>Arabidopsis thaliana</I>),
while &#X2018;source&#X2019; will often be the common name (e.g. thale cress). In this example, as is often the case,
the two fields are identical. </P><P>Now let&#X2019;s go through all the records, building up a list of the species each orchid sequence is from:</P><PRE CLASS="verbatim">from Bio import SeqIO
all_species = []
for seq_record in SeqIO.parse("ls_orchid.gbk", "genbank"):
    all_species.append(seq_record.annotations["organism"])
print all_species
</PRE><P>Another way of writing this code is to use a list comprehension:</P><PRE CLASS="verbatim">from Bio import SeqIO
all_species = [seq_record.annotations["organism"] for seq_record in \
               SeqIO.parse("ls_orchid.gbk", "genbank")]
print all_species
</PRE><P>In either case, the result is:</P><PRE CLASS="verbatim">['Cypripedium irapeanum', 'Cypripedium californicum', ..., 'Paphiopedilum barbatum']
</PRE><P>Great. That was pretty easy because GenBank files are annotated in a standardised way.</P><P>Now, let&#X2019;s suppose you wanted to extract a list of the species from a FASTA file, rather than the GenBank file. The bad news is you will have to write some code to extract the data you want from the record&#X2019;s description line - if the information is in the file in the first place! Our example FASTA format file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta">ls_orchid.fasta</A> starts like this:</P><PRE CLASS="verbatim">&gt;gi|2765658|emb|Z78533.1|CIZ78533 C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA
CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAACGATCGAGTG
AATCCGGAGGACCGGTGTACTCAGCTCACCGGGGGCATTGCTCCCGTGGTGACCCTGATTTGTTGTTGGG
...
</PRE><P>You can check by hand, but for every record the species name is in the description line as the second word. This means if we break up each record&#X2019;s <CODE>.description</CODE> at the spaces, then the species is there as field number one (field zero is the record identifier). That means we can do this:</P><PRE CLASS="verbatim">from Bio import SeqIO
all_species = []
for seq_record in SeqIO.parse("ls_orchid.fasta", "fasta"):
    all_species.append(seq_record.description.split()[1])
print all_species
</PRE><P>This gives:</P><PRE CLASS="verbatim">['C.irapeanum', 'C.californicum', 'C.fasciculatum', 'C.margaritaceum', ..., 'P.barbatum']
</PRE><P>The concise alternative using list comprehensions would be:</P><PRE CLASS="verbatim">from Bio import SeqIO
all_species == [seq_record.description.split()[1] for seq_record in \
                SeqIO.parse("ls_orchid.fasta", "fasta")]
print all_species
</PRE><P>In general, extracting information from the FASTA description line is not very nice.
If you can get your sequences in a well annotated file format like GenBank or EMBL,
then this sort of annotation information is much easier to deal with.</P><!--TOC section Parsing sequences from compressed files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc53">5.2</A>&#XA0;&#XA0;Parsing sequences from compressed files</H2><!--SEC END --><P>
<A NAME="sec:SeqIO_compressed"></A>
In the previous section, we looked at parsing sequence data from a file.
Instead of using a filename, you can give <CODE>Bio.SeqIO</CODE> a handle
(see Section&#XA0;<A HREF="#sec:appendix-handles">20.1</A>), and in this section
we&#X2019;ll use handles to parse sequence from compressed files.</P><P>As you&#X2019;ll have seen above, we can use <CODE>Bio.SeqIO.read()</CODE> or
<CODE>Bio.SeqIO.parse()</CODE> with a filename - for instance this quick
example calculates the total length of the sequences in a multiple
record GenBank file using a generator expression:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; print sum(len(r) for r in SeqIO.parse("ls_orchid.gbk", "gb"))
67518
</PRE><P>Here we use a file handle instead, using the <CODE>with</CODE> statement
(Python 2.5 or later) to close the handle automatically:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from __future__ import with_statement #Needed on Python 2.5
&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; with open("ls_orchid.gbk") as handle:
...     print sum(len(r) for r in SeqIO.parse(handle, "gb"))
67518
</PRE><P>Or, the old fashioned way where you manually close the handle:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; handle = open("ls_orchid.gbk")
&gt;&gt;&gt; print sum(len(r) for r in SeqIO.parse(handle, "gb"))
67518
&gt;&gt;&gt; handle.close()
</PRE><P>Now, suppose we have a gzip compressed file instead? These are very
commonly used on Linux. We can use Python&#X2019;s <CODE>gzip</CODE> module to open
the compressed file for reading - which gives us a handle object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import gzip
&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; handle = gzip.open("ls_orchid.gbk.gz", "r")
&gt;&gt;&gt; print sum(len(r) for r in SeqIO.parse(handle, "gb"))
67518
&gt;&gt;&gt; handle.close()
</PRE><P>Similarly if we had a bzip2 compressed file (sadly the function name isn&#X2019;t
quite as consistent):</P><PRE CLASS="verbatim">&gt;&gt;&gt; import bz2
&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; handle = bz2.BZ2File("ls_orchid.gbk.bz2", "r")
&gt;&gt;&gt; print sum(len(r) for r in SeqIO.parse(handle, "gb"))
67518
&gt;&gt;&gt; handle.close()
</PRE><P>If you are using Python 2.7 or later, the <CODE>with</CODE>-version works for
gzip and bz2 as well. Unfortunately this is broken on older versions of
Python (<A HREF="http://bugs.python.org/issue3860">Issue 3860</A>) and you&#X2019;d
get an <CODE>AttributeError</CODE> about <CODE>__exit__</CODE> being missing.</P><P>There is a gzip (GNU Zip) variant called BGZF (Blocked GNU Zip Format),
which can be treated like an ordinary gzip file for reading, but has
advantages for random access later which we&#X2019;ll talk about later in
Section&#XA0;<A HREF="#sec:SeqIO-index-bgzf">5.4.4</A>.</P><!--TOC section Parsing sequences from the net-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc54">5.3</A>&#XA0;&#XA0;Parsing sequences from the net</H2><!--SEC END --><P>
<A NAME="sec:SeqIO_Online"></A>
In the previous sections, we looked at parsing sequence data from a file
(using a filename or handle), and from compressed files (using a handle).
Here we&#X2019;ll use <CODE>Bio.SeqIO</CODE> with a another type of handle, a network
connection, to download and parse sequences from the internet.</P><P>Note that just because you <EM>can</EM> download sequence data and parse it into
a <CODE>SeqRecord</CODE> object in one go doesn&#X2019;t mean this is a good idea.
In general, you should probably download sequences <EM>once</EM> and save them to
a file for reuse.</P><!--TOC subsection Parsing GenBank records from the net-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">5.3.1</A>&#XA0;&#XA0;Parsing GenBank records from the net</H3><!--SEC END --><P>
<A NAME="sec:SeqIO_GenBank_Online"></A>
Section&#XA0;<A HREF="#sec:efetch">8.6</A> talks about the Entrez EFetch interface in more detail,
but for now let&#X2019;s just connect to the NCBI and get a few <I>Opuntia</I> (prickly-pear)
sequences from GenBank using their GI numbers.</P><P>First of all, let&#X2019;s fetch just one record. If you don&#X2019;t care about the
annotations and features downloading a FASTA file is a good choice as these
are compact. Now remember, when you expect the handle to contain one and
only one record, use the <CODE>Bio.SeqIO.read()</CODE> function:</P><PRE CLASS="verbatim">from Bio import Entrez
from Bio import SeqIO
Entrez.email = "A.N.Other@example.com"
handle = Entrez.efetch(db="nucleotide", rettype="fasta", retmode="text", id="6273291")
seq_record = SeqIO.read(handle, "fasta")
handle.close()
print "%s with %i features" % (seq_record.id, len(seq_record.features))
</PRE><P>Expected output:</P><PRE CLASS="verbatim">gi|6273291|gb|AF191665.1|AF191665 with 0 features
</PRE><P>The NCBI will also let you ask for the file in other formats, in particular as
a GenBank file. Until Easter 2009, the Entrez EFetch API let you use &#X201C;genbank&#X201D;
as the return type, however the NCBI now insist on using the official
return types of &#X201C;gb&#X201D; (or &#X201C;gp&#X201D; for proteins) as described on
<A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/efetchseq_help.html">EFetch for Sequence and other Molecular Biology Databases</A>.
As a result, in Biopython 1.50 onwards, we support &#X201C;gb&#X201D; as an
alias for &#X201C;genbank&#X201D; in <CODE>Bio.SeqIO</CODE>.</P><PRE CLASS="verbatim">from Bio import Entrez
from Bio import SeqIO
Entrez.email = "A.N.Other@example.com"
handle = Entrez.efetch(db="nucleotide", rettype="gb", retmode="text", id="6273291")
seq_record = SeqIO.read(handle, "gb") #using "gb" as an alias for "genbank"
handle.close()
print "%s with %i features" % (seq_record.id, len(seq_record.features))
</PRE><P>The expected output of this example is:</P><PRE CLASS="verbatim">AF191665.1 with 3 features
</PRE><P>Notice this time we have three features.</P><P>Now let&#X2019;s fetch several records. This time the handle contains multiple records,
so we must use the <CODE>Bio.SeqIO.parse()</CODE> function:</P><PRE CLASS="verbatim">from Bio import Entrez
from Bio import SeqIO
Entrez.email = "A.N.Other@example.com"
handle = Entrez.efetch(db="nucleotide", rettype="gb", retmode="text", \
                       id="6273291,6273290,6273289")
for seq_record in SeqIO.parse(handle, "gb"):
    print seq_record.id, seq_record.description[:50] + "..."
    print "Sequence length %i," % len(seq_record),
    print "%i features," % len(seq_record.features),
    print "from: %s" % seq_record.annotations["source"]
handle.close()
</PRE><P>That should give the following output:</P><PRE CLASS="verbatim">AF191665.1 Opuntia marenae rpl16 gene; chloroplast gene for c...
Sequence length 902, 3 features, from: chloroplast Opuntia marenae
AF191664.1 Opuntia clavata rpl16 gene; chloroplast gene for c...
Sequence length 899, 3 features, from: chloroplast Grusonia clavata
AF191663.1 Opuntia bradtiana rpl16 gene; chloroplast gene for...
Sequence length 899, 3 features, from: chloroplast Opuntia bradtianaa
</PRE><P>See Chapter&#XA0;<A HREF="#chapter:entrez">8</A> for more about the <CODE>Bio.Entrez</CODE> module, and make sure to read about the NCBI guidelines for using Entrez (Section&#XA0;<A HREF="#sec:entrez-guidelines">8.1</A>).</P><!--TOC subsection Parsing SwissProt sequences from the net-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc56">5.3.2</A>&#XA0;&#XA0;Parsing SwissProt sequences from the net</H3><!--SEC END --><P>
<A NAME="sec:SeqIO_ExPASy_and_SwissProt"></A>
Now let&#X2019;s use a handle to download a SwissProt file from ExPASy,
something covered in more depth in Chapter&#XA0;<A HREF="#chapter:swiss_prot">9</A>.
As mentioned above, when you expect the handle to contain one and only one record,
use the <CODE>Bio.SeqIO.read()</CODE> function:</P><PRE CLASS="verbatim">from Bio import ExPASy
from Bio import SeqIO
handle = ExPASy.get_sprot_raw("O23729")
seq_record = SeqIO.read(handle, "swiss")
handle.close()
print seq_record.id
print seq_record.name
print seq_record.description
print repr(seq_record.seq)
print "Length %i" % len(seq_record)
print seq_record.annotations["keywords"]
</PRE><P>Assuming your network connection is OK, you should get back:</P><PRE CLASS="verbatim">O23729
CHS3_BROFI
RecName: Full=Chalcone synthase 3; EC=2.3.1.74; AltName: Full=Naringenin-chalcone synthase 3;
Seq('MAPAMEEIRQAQRAEGPAAVLAIGTSTPPNALYQADYPDYYFRITKSEHLTELK...GAE', ProteinAlphabet())
Length 394
['Acyltransferase', 'Flavonoid biosynthesis', 'Transferase']
</PRE><!--TOC section Sequence files as Dictionaries-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc57">5.4</A>&#XA0;&#XA0;Sequence files as Dictionaries</H2><!--SEC END --><P>We&#X2019;re now going to introduce three related functions in the <CODE>Bio.SeqIO</CODE>
module which allow dictionary like random access to a multi-sequence file.
There is a trade off here between flexibility and memory usage. In summary:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>Bio.SeqIO.to_dict()</CODE> is the most flexible but also the most
memory demanding option (see Section&#XA0;<A HREF="#SeqIO:to_dict">5.4.1</A>). This is basically
a helper function to build a normal Python <CODE>dictionary</CODE> with each entry
held as a <CODE>SeqRecord</CODE> object in memory, allowing you to modify the
records.
</LI><LI CLASS="li-itemize"><CODE>Bio.SeqIO.index()</CODE> is a useful middle ground, acting like a
read only dictionary and parsing sequences into <CODE>SeqRecord</CODE> objects
on demand (see Section&#XA0;<A HREF="#sec:SeqIO-index">5.4.2</A>).
</LI><LI CLASS="li-itemize"><CODE>Bio.SeqIO.index_db()</CODE> also acts like a read only dictionary
but stores the identifiers and file offsets in a file on disk (as an
SQLite3 database), meaning it has very low memory requirements (see
Section&#XA0;<A HREF="#sec:SeqIO-index-db">5.4.3</A>), but will be a little bit slower.
</LI></UL><P>
See the discussion for an broad overview
(Section&#XA0;<A HREF="#sec:SeqIO-indexing-discussion">5.4.5</A>).</P><!--TOC subsection Sequence files as Dictionaries &#X2013; In memory-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">5.4.1</A>&#XA0;&#XA0;Sequence files as Dictionaries &#X2013; In memory</H3><!--SEC END --><P>
<A NAME="SeqIO:to_dict"></A></P><P>The next thing that we&#X2019;ll do with our ubiquitous orchid files is to show how
to index them and access them like a database using the Python <CODE>dictionary</CODE>
data type (like a hash in Perl). This is very useful for moderately large files
where you only need to access certain elements of the file, and makes for a nice
quick &#X2019;n dirty database. For dealing with larger files where memory becomes a
problem, see Section&#XA0;<A HREF="#sec:SeqIO-index">5.4.2</A> below.</P><P>You can use the function <CODE>Bio.SeqIO.to_dict()</CODE> to make a SeqRecord dictionary
(in memory). By default this will use each record&#X2019;s identifier (i.e. the <CODE>.id</CODE>
attribute) as the key. Let&#X2019;s try this using our GenBank file:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; orchid_dict = SeqIO.to_dict(SeqIO.parse("ls_orchid.gbk", "genbank"))
</PRE><P>There is just one required argument for <CODE>Bio.SeqIO.to_dict()</CODE>, a list or
generator giving <CODE>SeqRecord</CODE> objects. Here we have just used the output
from the <CODE>SeqIO.parse</CODE> function. As the name suggests, this returns a
Python dictionary.</P><P>Since this variable <CODE>orchid_dict</CODE> is an ordinary Python dictionary, we can look at all of the keys we have available:</P><PRE CLASS="verbatim">&gt;&gt;&gt; len(orchid_dict)
94
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; print orchid_dict.keys()
['Z78484.1', 'Z78464.1', 'Z78455.1', 'Z78442.1', 'Z78532.1', 'Z78453.1', ..., 'Z78471.1']
</PRE><P>If you really want to, you can even look at all the records at once:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; orchid_dict.values() #lots of output!
...
</PRE><P>We can access a single <CODE>SeqRecord</CODE> object via the keys and manipulate the object as normal:</P><PRE CLASS="verbatim">&gt;&gt;&gt; seq_record = orchid_dict["Z78475.1"]
&gt;&gt;&gt; print seq_record.description
P.supardii 5.8S rRNA gene and ITS1 and ITS2 DNA.
&gt;&gt;&gt; print repr(seq_record.seq)
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGTTGAGATCACAT...GGT', IUPACAmbiguousDNA())
</PRE><P>So, it is very easy to create an in memory &#X201C;database&#X201D; of our GenBank records. Next we&#X2019;ll try this for the FASTA file instead.</P><P>Note that those of you with prior Python experience should all be able to construct a dictionary like this &#X201C;by hand&#X201D;. However, typical dictionary construction methods will not deal with the case of repeated keys very nicely. Using the <CODE>Bio.SeqIO.to_dict()</CODE> will explicitly check for duplicate keys, and raise an exception if any are found.</P><!--TOC subsubsection Specifying the dictionary keys-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->5.4.1.1&#XA0;&#XA0;Specifying the dictionary keys</H4><!--SEC END --><P>
<A NAME="seq:seqio-todict-functionkey"></A></P><P>Using the same code as above, but for the FASTA file instead:</P><PRE CLASS="verbatim">from Bio import SeqIO
orchid_dict = SeqIO.to_dict(SeqIO.parse("ls_orchid.fasta", "fasta"))
print orchid_dict.keys()
</PRE><P>This time the keys are:</P><PRE CLASS="verbatim">['gi|2765596|emb|Z78471.1|PDZ78471', 'gi|2765646|emb|Z78521.1|CCZ78521', ...
 ..., 'gi|2765613|emb|Z78488.1|PTZ78488', 'gi|2765583|emb|Z78458.1|PHZ78458']
</PRE><P>You should recognise these strings from when we parsed the FASTA file earlier in Section&#XA0;<A HREF="#sec:fasta-parsing">2.4.1</A>. Suppose you would rather have something else as the keys - like the accession numbers. This brings us nicely to <CODE>SeqIO.to_dict()</CODE>&#X2019;s optional argument <CODE>key_function</CODE>, which lets you define what to use as the dictionary key for your records.</P><P>First you must write your own function to return the key you want (as a string) when given a <CODE>SeqRecord</CODE> object. In general, the details of function will depend on the sort of input records you are dealing with. But for our orchids, we can just split up the record&#X2019;s identifier using the &#X201C;pipe&#X201D; character (the vertical line) and return the fourth entry (field three):</P><PRE CLASS="verbatim">def get_accession(record):
    """"Given a SeqRecord, return the accession number as a string.
  
    e.g. "gi|2765613|emb|Z78488.1|PTZ78488" -&gt; "Z78488.1"
    """
    parts = record.id.split("|")
    assert len(parts) == 5 and parts[0] == "gi" and parts[2] == "emb"
    return parts[3]
</PRE><P>Then we can give this function to the <CODE>SeqIO.to_dict()</CODE> function to use in building the dictionary:</P><PRE CLASS="verbatim">from Bio import SeqIO
orchid_dict = SeqIO.to_dict(SeqIO.parse("ls_orchid.fasta", "fasta"), key_function=get_accession)
print orchid_dict.keys()
</PRE><P>Finally, as desired, the new dictionary keys:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print orchid_dict.keys()
['Z78484.1', 'Z78464.1', 'Z78455.1', 'Z78442.1', 'Z78532.1', 'Z78453.1', ..., 'Z78471.1']
</PRE><P>Not too complicated, I hope!</P><!--TOC subsubsection Indexing a dictionary using the SEGUID checksum-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->5.4.1.2&#XA0;&#XA0;Indexing a dictionary using the SEGUID checksum</H4><!--SEC END --><P>To give another example of working with dictionaries of <CODE>SeqRecord</CODE> objects, we&#X2019;ll use the SEGUID checksum function. This is a relatively recent checksum, and collisions should be very rare (i.e. two different sequences with the same checksum), an improvement on the CRC64 checksum.</P><P>Once again, working with the orchids GenBank file:</P><PRE CLASS="verbatim">from Bio import SeqIO
from Bio.SeqUtils.CheckSum import seguid
for record in SeqIO.parse("ls_orchid.gbk", "genbank"):
    print record.id, seguid(record.seq)
</PRE><P>This should give:</P><PRE CLASS="verbatim">Z78533.1 JUEoWn6DPhgZ9nAyowsgtoD9TTo
Z78532.1 MN/s0q9zDoCVEEc+k/IFwCNF2pY
...
Z78439.1 H+JfaShya/4yyAj7IbMqgNkxdxQ
</PRE><P>Now, recall the <CODE>Bio.SeqIO.to_dict()</CODE> function&#X2019;s <CODE>key_function</CODE> argument expects a function which turns a <CODE>SeqRecord</CODE> into a string. We can&#X2019;t use the <CODE>seguid()</CODE> function directly because it expects to be given a <CODE>Seq</CODE> object (or a string). However, we can use Python&#X2019;s <CODE>lambda</CODE> feature to create a &#X201C;one off&#X201D; function to give to <CODE>Bio.SeqIO.to_dict()</CODE> instead:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; from Bio.SeqUtils.CheckSum import seguid
&gt;&gt;&gt; seguid_dict = SeqIO.to_dict(SeqIO.parse("ls_orchid.gbk", "genbank"),
...                             lambda rec : seguid(rec.seq))
&gt;&gt;&gt; record = seguid_dict["MN/s0q9zDoCVEEc+k/IFwCNF2pY"]
&gt;&gt;&gt; print record.id
Z78532.1
&gt;&gt;&gt; print record.description
C.californicum 5.8S rRNA gene and ITS1 and ITS2 DNA.
</PRE><P>That should have retrieved the record <TT>Z78532.1</TT>, the second entry in the file.</P><!--TOC subsection Sequence files as Dictionaries &#X2013; Indexed files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc59">5.4.2</A>&#XA0;&#XA0;Sequence files as Dictionaries &#X2013; Indexed files</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-index"></A></P><P>As the previous couple of examples tried to illustrate, using
<CODE>Bio.SeqIO.to_dict()</CODE> is very flexible. However, because it holds
everything in memory, the size of file you can work with is limited by your
computer&#X2019;s RAM. In general, this will only work on small to medium files.</P><P>For large files, Biopython 1.52 introduced an alternative,
<CODE>Bio.SeqIO.index()</CODE>, which works a little differently. Although
it still returns a dictionary like object, this does <EM>not</EM> keep
<EM>everything</EM> in memory. Instead, it just records where each record
is within the file &#X2013; when you ask for a particular record, it then parses
it on demand.</P><P>As an example, let&#X2019;s use the same GenBank file as before:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; orchid_dict = SeqIO.index("ls_orchid.gbk", "genbank")
&gt;&gt;&gt; len(orchid_dict)
94
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; orchid_dict.keys()
['Z78484.1', 'Z78464.1', 'Z78455.1', 'Z78442.1', 'Z78532.1', 'Z78453.1', ..., 'Z78471.1']
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; seq_record = orchid_dict["Z78475.1"]
&gt;&gt;&gt; print seq_record.description
P.supardii 5.8S rRNA gene and ITS1 and ITS2 DNA.
&gt;&gt;&gt; seq_record.seq
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGTTGAGATCACAT...GGT', IUPACAmbiguousDNA())
</PRE><P>Note that <CODE>Bio.SeqIO.index()</CODE> won&#X2019;t take a handle,
but only a filename. There are good reasons for this, but it is a little
technical. The second argument is the file format (a lower case string as
used in the other <CODE>Bio.SeqIO</CODE> functions). You can use many other
simple file formats, including FASTA and FASTQ files (see the example in
Section&#XA0;<A HREF="#sec:fastq-indexing">16.1.11</A>). However, alignment
formats like PHYLIP or Clustal are not supported. Finally as an optional
argument you can supply an alphabet, or a key function.</P><P>Here is the same example using the FASTA file - all we change is the
filename and the format name:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; orchid_dict = SeqIO.index("ls_orchid.fasta", "fasta")
&gt;&gt;&gt; len(orchid_dict)
94
&gt;&gt;&gt; orchid_dict.keys()
['gi|2765596|emb|Z78471.1|PDZ78471', 'gi|2765646|emb|Z78521.1|CCZ78521', ...
 ..., 'gi|2765613|emb|Z78488.1|PTZ78488', 'gi|2765583|emb|Z78458.1|PHZ78458']
</PRE><!--TOC subsubsection Specifying the dictionary keys-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->5.4.2.1&#XA0;&#XA0;Specifying the dictionary keys</H4><!--SEC END --><P>
<A NAME="seq:seqio-index-functionkey"></A></P><P>Suppose you want to use the same keys as before? Much like with the
<CODE>Bio.SeqIO.to_dict()</CODE> example in Section&#XA0;<A HREF="#seq:seqio-todict-functionkey">5.4.1.1</A>,
you&#X2019;ll need to write a tiny function to map from the FASTA identifier
(as a string) to the key you want:</P><PRE CLASS="verbatim">def get_acc(identifier):
    """"Given a SeqRecord identifier string, return the accession number as a string.
  
    e.g. "gi|2765613|emb|Z78488.1|PTZ78488" -&gt; "Z78488.1"
    """
    parts = identifier.split("|")
    assert len(parts) == 5 and parts[0] == "gi" and parts[2] == "emb"
    return parts[3]
</PRE><P>Then we can give this function to the <CODE>Bio.SeqIO.index()</CODE>
function to use in building the dictionary:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; orchid_dict = SeqIO.index("ls_orchid.fasta", "fasta", key_function=get_acc)
&gt;&gt;&gt; print orchid_dict.keys()
['Z78484.1', 'Z78464.1', 'Z78455.1', 'Z78442.1', 'Z78532.1', 'Z78453.1', ..., 'Z78471.1']
</PRE><P>Easy when you know how?</P><!--TOC subsubsection Getting the raw data for a record-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->5.4.2.2&#XA0;&#XA0;Getting the raw data for a record</H4><!--SEC END --><P>
<A NAME="sec:seqio-index-getraw"></A></P><P>The dictionary-like object from <CODE>Bio.SeqIO.index()</CODE> gives you each
entry as a <CODE>SeqRecord</CODE> object. However, it is sometimes useful to
be able to get the original raw data straight from the file. For this
reason Biopython 1.54 added a <CODE>get_raw()</CODE> method which takes a
single argument (the record identifier) and returns a string (extracted
from the file without modification).</P><P>A motivating example is extracting a subset of a records from a large
file where either <CODE>Bio.SeqIO.write()</CODE> does not (yet) support the
output file format (e.g. the plain text SwissProt file format) or
where you need to preserve the text exactly (e.g. GenBank or EMBL
output from Biopython does not yet preserve every last bit of
annotation).</P><P>Let&#X2019;s suppose you have download the whole of UniProt in the plain
text SwissPort file format from their FTP site
(<A HREF="ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.dat.gz"><TT>ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.dat.gz</TT></A>)
and uncompressed it as the file <CODE>uniprot_sprot.dat</CODE>, and you
want to extract just a few records from it:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; uniprot = SeqIO.index("uniprot_sprot.dat", "swiss")
&gt;&gt;&gt; handle = open("selected.dat", "w")
&gt;&gt;&gt; for acc in ["P33487", "P19801", "P13689", "Q8JZQ5", "Q9TRC7"]:
...     handle.write(uniprot.get_raw(acc))
&gt;&gt;&gt; handle.close()
</PRE><P>There is a longer example in Section&#XA0;<A HREF="#sec:SeqIO-sort">16.1.5</A> using the
<CODE>SeqIO.index()</CODE> function to sort a large sequence file (without
loading everything into memory at once).</P><!--TOC subsection Sequence files as Dictionaries &#X2013; Database indexed files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc60">5.4.3</A>&#XA0;&#XA0;Sequence files as Dictionaries &#X2013; Database indexed files</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-index-db"></A></P><P>Biopython 1.57 introduced an alternative, <CODE>Bio.SeqIO.index_db()</CODE>, which
can work on even extremely large files since it stores the record information
as a file on disk (using an SQLite3 database) rather than in memory. Also,
you can index multiple files together (providing all the record identifiers
are unique).</P><P>The <CODE>Bio.SeqIO.index()</CODE> function takes three required arguments:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Index filename, we suggest using something ending <TT>.idx</TT>.
This index file is actually an SQLite3 database.
</LI><LI CLASS="li-itemize">List of sequence filenames to index (or a single filename)
</LI><LI CLASS="li-itemize">File format (lower case string as used in the rest of the
<CODE>SeqIO</CODE> module).
</LI></UL><P>As an example, consider the GenBank flat file releases from the NCBI FTP site,
<A HREF="ftp://ftp.ncbi.nih.gov/genbank/"><TT>ftp://ftp.ncbi.nih.gov/genbank/</TT></A>, which are gzip compressed GenBank files.
As of GenBank release 182, there are 16 files making up the viral sequences,
<TT>gbvrl1.seq</TT>, &#X2026;, <TT>gbvrl16.seq</TT>, containing in total almost
one million records. You can index them like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; files = ["gbvrl%i.seq" % (i+1) for i in range(16)]
&gt;&gt;&gt; gb_vrl = SeqIO.index_db("gbvrl.idx", files, "genbank")
&gt;&gt;&gt; print "%i sequences indexed" % len(gb_vrl)
958086 sequences indexed
</PRE><P>That takes about two minutes to run on my machine. If you rerun it then the
index file (here <TT>gbvrl.idx</TT>) is reloaded in under a second. You can
use the index as a read only Python dictionary - without having to worry
about which file the sequence comes from, e.g.</P><PRE CLASS="verbatim">&gt;&gt;&gt; print gb_vrl["GQ333173.1"].description
HIV-1 isolate F12279A1 from Uganda gag protein (gag) gene, partial cds.
</PRE><!--TOC subsubsection Getting the raw data for a record-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->5.4.3.1&#XA0;&#XA0;Getting the raw data for a record</H4><!--SEC END --><P>Just as with the <CODE>Bio.SeqIO.index()</CODE> function discussed above in
Section&#XA0;<A HREF="#sec:seqio-index-getraw">5.4.2.2</A>, the dictionary like object also lets you
get at the raw text of each record:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print gb_vrl.get_raw("GQ333173.1")
LOCUS       GQ333173                 459 bp    DNA     linear   VRL 21-OCT-2009
DEFINITION  HIV-1 isolate F12279A1 from Uganda gag protein (gag) gene, partial
            cds.
ACCESSION   GQ333173
...
//
</PRE><!--TOC subsection Indexing compressed files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc61">5.4.4</A>&#XA0;&#XA0;Indexing compressed files</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-index-bgzf"></A></P><P>Very often when you are indexing a sequence file it can be quite large &#X2013; so
you may want to compress it on disk. Unfortunately efficient random access
is difficult with the more common file formats like gzip and bzip2. In this
setting, BGZF (Blocked GNU Zip Format) can be very helpful. This is a variant
of gzip (and can be decompressed using standard gzip tools) popularised by
the BAM file format, <A HREF="http://samtools.sourceforge.net/">samtools</A>, and
<A HREF="http://samtools.sourceforge.net/tabix.shtml">tabix</A>.</P><P>To create a BGZF compressed file you can use the command line tool <CODE>bgzip</CODE>
which comes with samtools. In our examples we use a filename extension
<CODE>*.bgz</CODE>, so they can be distinguished from normal gzipped files (named
<CODE>*.gz</CODE>). You can also use the <CODE>Bio.bgzf</CODE> module to read and write
BGZF files from within Python.</P><P>The <CODE>Bio.SeqIO.index()</CODE> and <CODE>Bio.SeqIO.index_db()</CODE> can both be
used with BGZF compressed files. For example, if you started with an
uncompressed GenBank file:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; orchid_dict = SeqIO.index("ls_orchid.gbk", "genbank")
&gt;&gt;&gt; len(orchid_dict)
94
</PRE><P>You could compress this (while keeping the original file) at the command
line using the following command &#X2013; but don&#X2019;t worry, the compressed file
is already included with the other example files:</P><PRE CLASS="verbatim">$ bgzip -c ls_orchid.gbk &gt; ls_orchid.gbk.bgz
</PRE><P>You can use the compressed file in exactly the same way:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; orchid_dict = SeqIO.index("ls_orchid.gbk.bgz", "genbank")
&gt;&gt;&gt; len(orchid_dict)
94
</PRE><P>or:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; orchid_dict = SeqIO.index_db("ls_orchid.gbk.bgz.idx", "ls_orchid.gbk.bgz", "genbank")
&gt;&gt;&gt; len(orchid_dict)
94
</PRE><P>The <CODE>SeqIO</CODE> indexing automatically detects the BGZF compression. Note
that you can&#X2019;t use the same index file for the uncompressed and compressed files.</P><!--TOC subsection Discussion-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc62">5.4.5</A>&#XA0;&#XA0;Discussion</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-indexing-discussion"></A></P><P>So, which of these methods should you use and why? It depends on what you are
trying to do (and how much data you are dealing with). However, in general
picking <CODE>Bio.SeqIO.index()</CODE> is a good starting point. If you are dealing
with millions of records, multiple files, or repeated analyses, then look at
<CODE>Bio.SeqIO.index_db()</CODE>.</P><P>Reasons to choose <CODE>Bio.SeqIO.to_dict()</CODE> over either
<CODE>Bio.SeqIO.index()</CODE> or <CODE>Bio.SeqIO.index_db()</CODE> boil down to a need
for flexibility despite its high memory needs. The advantage of storing the
<CODE>SeqRecord</CODE> objects in memory is they can be changed, added to, or
removed at will. In addition to the downside of high memory consumption,
indexing can also take longer because all the records must be fully parsed.</P><P>Both <CODE>Bio.SeqIO.index()</CODE> and <CODE>Bio.SeqIO.index_db()</CODE> only parse
records on demand. When indexing, they scan the file once looking for the
start of each record and do as little work as possible to extract the
identifier.</P><P>Reasons to choose <CODE>Bio.SeqIO.index()</CODE> over <CODE>Bio.SeqIO.index_db()</CODE>
include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Faster to build the index (more noticeable in simple file formats)
</LI><LI CLASS="li-itemize">Slightly faster access as SeqRecord objects (but the difference is only
really noticeable for simple to parse file formats).
</LI><LI CLASS="li-itemize">Can use any immutable Python object as the dictionary keys (e.g. a
tuple of strings, or a frozen set) not just strings.
</LI><LI CLASS="li-itemize">Don&#X2019;t need to worry about the index database being out of date if the
sequence file being indexed has changed.
</LI></UL><P>Reasons to choose <CODE>Bio.SeqIO.index_db()</CODE> over <CODE>Bio.SeqIO.index()</CODE>
include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Not memory limited &#X2013; this is already important with files from second
generation sequencing where 10s of millions of sequences are common, and
using <CODE>Bio.SeqIO.index()</CODE> can require more than 4GB of RAM and therefore
a 64bit version of Python.
</LI><LI CLASS="li-itemize">Because the index is kept on disk, it can be reused. Although building
the index database file takes longer, if you have a script which will be
rerun on the same datafiles in future, this could save time in the long run.
</LI><LI CLASS="li-itemize">Indexing multiple files together
</LI><LI CLASS="li-itemize">The <CODE>get_raw()</CODE> method can be much faster, since for most file
formats the length of each record is stored as well as its offset.
</LI></UL><!--TOC section Writing Sequence Files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc63">5.5</A>&#XA0;&#XA0;Writing Sequence Files</H2><!--SEC END --><P>We&#X2019;ve talked about using <CODE>Bio.SeqIO.parse()</CODE> for sequence input (reading files), and now we&#X2019;ll look at <CODE>Bio.SeqIO.write()</CODE> which is for sequence output (writing files). This is a function taking three arguments: some <CODE>SeqRecord</CODE> objects, a handle or filename to write to, and a sequence format.</P><P>Here is an example, where we start by creating a few <CODE>SeqRecord</CODE> objects the hard way (by hand, rather than by loading them from a file):</P><PRE CLASS="verbatim">from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Alphabet import generic_protein

rec1 = SeqRecord(Seq("MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGD" \
                    +"GAGAVIVGSDPDLSVERPLYELVWTGATLLPDSEGAIDGHLREVGLTFHLLKDVPGLISK" \
                    +"NIEKSLKEAFTPLGISDWNSTFWIAHPGGPAILDQVEAKLGLKEEKMRATREVLSEYGNM" \
                    +"SSAC", generic_protein),
                 id="gi|14150838|gb|AAK54648.1|AF376133_1",
                 description="chalcone synthase [Cucumis sativus]")

rec2 = SeqRecord(Seq("YPDYYFRITNREHKAELKEKFQRMCDKSMIKKRYMYLTEEILKENPSMCEYMAPSLDARQ" \
                    +"DMVVVEIPKLGKEAAVKAIKEWGQ", generic_protein),
                 id="gi|13919613|gb|AAK33142.1|",
                 description="chalcone synthase [Fragaria vesca subsp. bracteata]")

rec3 = SeqRecord(Seq("MVTVEEFRRAQCAEGPATVMAIGTATPSNCVDQSTYPDYYFRITNSEHKVELKEKFKRMC" \
                    +"EKSMIKKRYMHLTEEILKENPNICAYMAPSLDARQDIVVVEVPKLGKEAAQKAIKEWGQP" \
                    +"KSKITHLVFCTTSGVDMPGCDYQLTKLLGLRPSVKRFMMYQQGCFAGGTVLRMAKDLAEN" \
                    +"NKGARVLVVCSEITAVTFRGPNDTHLDSLVGQALFGDGAAAVIIGSDPIPEVERPLFELV" \
                    +"SAAQTLLPDSEGAIDGHLREVGLTFHLLKDVPGLISKNIEKSLVEAFQPLGISDWNSLFW" \
                    +"IAHPGGPAILDQVELKLGLKQEKLKATRKVLSNYGNMSSACVLFILDEMRKASAKEGLGT" \
                    +"TGEGLEWGVLFGFGPGLTVETVVLHSVAT", generic_protein),
                 id="gi|13925890|gb|AAK49457.1|",
                 description="chalcone synthase [Nicotiana tabacum]")
               
my_records = [rec1, rec2, rec3]
</PRE><P>Now we have a list of <CODE>SeqRecord</CODE> objects, we&#X2019;ll write them to a FASTA format file:</P><PRE CLASS="verbatim">from Bio import SeqIO
SeqIO.write(my_records, "my_example.faa", "fasta")
</PRE><P>And if you open this file in your favourite text editor it should look like this:</P><PRE CLASS="verbatim">&gt;gi|14150838|gb|AAK54648.1|AF376133_1 chalcone synthase [Cucumis sativus]
MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGD
GAGAVIVGSDPDLSVERPLYELVWTGATLLPDSEGAIDGHLREVGLTFHLLKDVPGLISK
NIEKSLKEAFTPLGISDWNSTFWIAHPGGPAILDQVEAKLGLKEEKMRATREVLSEYGNM
SSAC
&gt;gi|13919613|gb|AAK33142.1| chalcone synthase [Fragaria vesca subsp. bracteata]
YPDYYFRITNREHKAELKEKFQRMCDKSMIKKRYMYLTEEILKENPSMCEYMAPSLDARQ
DMVVVEIPKLGKEAAVKAIKEWGQ
&gt;gi|13925890|gb|AAK49457.1| chalcone synthase [Nicotiana tabacum]
MVTVEEFRRAQCAEGPATVMAIGTATPSNCVDQSTYPDYYFRITNSEHKVELKEKFKRMC
EKSMIKKRYMHLTEEILKENPNICAYMAPSLDARQDIVVVEVPKLGKEAAQKAIKEWGQP
KSKITHLVFCTTSGVDMPGCDYQLTKLLGLRPSVKRFMMYQQGCFAGGTVLRMAKDLAEN
NKGARVLVVCSEITAVTFRGPNDTHLDSLVGQALFGDGAAAVIIGSDPIPEVERPLFELV
SAAQTLLPDSEGAIDGHLREVGLTFHLLKDVPGLISKNIEKSLVEAFQPLGISDWNSLFW
IAHPGGPAILDQVELKLGLKQEKLKATRKVLSNYGNMSSACVLFILDEMRKASAKEGLGT
TGEGLEWGVLFGFGPGLTVETVVLHSVAT
</PRE><P>Suppose you wanted to know how many records the <CODE>Bio.SeqIO.write()</CODE> function wrote to the handle?
If your records were in a list you could just use <CODE>len(my_records)</CODE>, however you can&#X2019;t do that when your records come from a generator/iterator. Therefore as of Biopython 1.49, the <CODE>Bio.SeqIO.write()</CODE> function returns the number of <CODE>SeqRecord</CODE> objects written to the file. </P><P><EM>Note</EM> - If you tell the <CODE>Bio.SeqIO.write()</CODE> function to write to a file that already exists, the old file will be overwritten without any warning.</P><!--TOC subsection Round trips-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc64">5.5.1</A>&#XA0;&#XA0;Round trips</H3><!--SEC END --><P>Some people like their parsers to be &#X201C;round-tripable&#X201D;, meaning if you read in
a file and write it back out again it is unchanged. This requires that the parser
must extract enough information to reproduce the original file <EM>exactly</EM>.
<CODE>Bio.SeqIO</CODE> does <EM>not</EM> aim to do this.</P><P>As a trivial example, any line wrapping of the sequence data in FASTA files is
allowed. An identical <CODE>SeqRecord</CODE> would be given from parsing the following
two examples which differ only in their line breaks:</P><PRE CLASS="verbatim">&gt;YAL068C-7235.2170 Putative promoter sequence
TACGAGAATAATTTCTCATCATCCAGCTTTAACACAAAATTCGCACAGTTTTCGTTAAGA
GAACTTAACATTTTCTTATGACGTAAATGAAGTTTATATATAAATTTCCTTTTTATTGGA

&gt;YAL068C-7235.2170 Putative promoter sequence
TACGAGAATAATTTCTCATCATCCAGCTTTAACACAAAATTCGCA
CAGTTTTCGTTAAGAGAACTTAACATTTTCTTATGACGTAAATGA
AGTTTATATATAAATTTCCTTTTTATTGGA
</PRE><P>To make a round-tripable FASTA parser you would need to keep track of where the
sequence line breaks occurred, and this extra information is usually pointless.
Instead Biopython uses a default line wrapping of 60 characters on output.
The same problem with white space applies in many other file formats too.
Another issue in some cases is that Biopython does not (yet) preserve every
last bit of annotation (e.g. GenBank and EMBL).</P><P>Occasionally preserving the original layout (with any quirks it may have) is
important. See Section&#XA0;<A HREF="#sec:seqio-index-getraw">5.4.2.2</A> about the <CODE>get_raw()</CODE>
method of the <CODE>Bio.SeqIO.index()</CODE> dictionary-like object for one potential
solution.</P><!--TOC subsection Converting between sequence file formats-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc65">5.5.2</A>&#XA0;&#XA0;Converting between sequence file formats</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-conversion"></A></P><P>In previous example we used a list of <CODE>SeqRecord</CODE> objects as input to the <CODE>Bio.SeqIO.write()</CODE> function, but it will also accept a <CODE>SeqRecord</CODE> iterator like we get from <CODE>Bio.SeqIO.parse()</CODE> &#X2013; this lets us do file conversion by combining these two functions.</P><P>For this example we&#X2019;ll read in the GenBank format file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">ls_orchid.gbk</A> and write it out in FASTA format:</P><PRE CLASS="verbatim">from Bio import SeqIO
records = SeqIO.parse("ls_orchid.gbk", "genbank")
count = SeqIO.write(records, "my_example.fasta", "fasta")
print "Converted %i records" % count
</PRE><P>Still, that is a little bit complicated. So, because file conversion is such a
common task, Biopython 1.52 introduced a helper function letting you replace
that with just:</P><PRE CLASS="verbatim">from Bio import SeqIO
count = SeqIO.convert("ls_orchid.gbk", "genbank", "my_example.fasta", "fasta")
print "Converted %i records" % count
</PRE><P>The <CODE>Bio.SeqIO.convert()</CODE> function will take handles <EM>or</EM> filenames.
Watch out though &#X2013; if the output file already exists, it will overwrite it!
To find out more, see the built in help:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; help(SeqIO.convert)
...
</PRE><P>In principle, just by changing the filenames and the format names, this code
could be used to convert between any file formats available in Biopython.
However, writing some formats requires information (e.g. quality scores) which
other files formats don&#X2019;t contain. For example, while you can turn a FASTQ
file into a FASTA file, you can&#X2019;t do the reverse. See also
Sections&#XA0;<A HREF="#sec:SeqIO-fastq-conversion">16.1.9</A> and&#XA0;<A HREF="#sec:SeqIO-fasta-qual-conversion">16.1.10</A>
in the cookbook chapter which looks at inter-converting between different FASTQ formats.</P><P>Finally, as an added incentive for using the <CODE>Bio.SeqIO.convert()</CODE> function
(on top of the fact your code will be shorter), doing it this way may also be
faster! The reason for this is the convert function can take advantage of
several file format specific optimisations and tricks.</P><!--TOC subsection Converting a file of sequences to their reverse complements-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc66">5.5.3</A>&#XA0;&#XA0;Converting a file of sequences to their reverse complements</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-reverse-complement"></A></P><P>Suppose you had a file of nucleotide sequences, and you wanted to turn it into a file containing their reverse complement sequences. This time a little bit of work is required to transform the <CODE>SeqRecord</CODE> objects we get from our input file into something suitable for saving to our output file.</P><P>To start with, we&#X2019;ll use <CODE>Bio.SeqIO.parse()</CODE> to load some nucleotide
sequences from a file, then print out their reverse complements using
the <CODE>Seq</CODE> object&#X2019;s built in <CODE>.reverse_complement()</CODE> method (see Section&#XA0;<A HREF="#sec:seq-reverse-complement">3.7</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; for record in SeqIO.parse("ls_orchid.gbk", "genbank"):
...     print record.id
...     print record.seq.reverse_complement()
</PRE><P>Now, if we want to save these reverse complements to a file, we&#X2019;ll need to make <CODE>SeqRecord</CODE> objects.
We can use the <CODE>SeqRecord</CODE> object&#X2019;s built in <CODE>.reverse_complement()</CODE> method (see Section&#XA0;<A HREF="#sec:SeqRecord-reverse-complement">4.9</A>) but we must decide how to name our new records.</P><P>This is an excellent place to demonstrate the power of list comprehensions which make a list in memory:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; records = [rec.reverse_complement(id="rc_"+rec.id, description = "reverse complement") \
...            for rec in SeqIO.parse("ls_orchid.fasta", "fasta")]
&gt;&gt;&gt; len(records)
94
</PRE><P>Now list comprehensions have a nice trick up their sleeves, you can add a conditional statement:</P><PRE CLASS="verbatim">&gt;&gt;&gt; records = [rec.reverse_complement(id="rc_"+rec.id, description = "reverse complement") \
...            for rec in SeqIO.parse("ls_orchid.fasta", "fasta") if len(rec)&lt;700]
&gt;&gt;&gt; len(records)
18
</PRE><P>That would create an in memory list of reverse complement records where the sequence length was under 700 base pairs. However, we can do exactly the same with a generator expression - but with the advantage that this does not create a list of all the records in memory at once:</P><PRE CLASS="verbatim">&gt;&gt;&gt; records = (rec.reverse_complement(id="rc_"+rec.id, description = "reverse complement") \
...           for rec in SeqIO.parse("ls_orchid.fasta", "fasta") if len(rec)&lt;700)
</PRE><P>As a complete example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; records = (rec.reverse_complement(id="rc_"+rec.id, description = "reverse complement") \
...            for rec in SeqIO.parse("ls_orchid.fasta", "fasta") if len(rec)&lt;700)
&gt;&gt;&gt; SeqIO.write(records, "rev_comp.fasta", "fasta")
18
</PRE><P>There is a related example in Section&#XA0;<A HREF="#sec:SeqIO-translate">16.1.3</A>, translating each
record in a FASTA file from nucleotides to amino acids.</P><!--TOC subsection Getting your SeqRecord objects as formatted strings-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">5.5.4</A>&#XA0;&#XA0;Getting your SeqRecord objects as formatted strings</H3><!--SEC END --><P>
<A NAME="sec:Bio.SeqIO-and-StringIO"></A>
Suppose that you don&#X2019;t really want to write your records to a file or handle &#X2013; instead you want a string containing the records in a particular file format. The <CODE>Bio.SeqIO</CODE> interface is based on handles, but Python has a useful built in module which provides a string based handle.</P><P>For an example of how you might use this, let&#X2019;s load in a bunch of <CODE>SeqRecord</CODE> objects from our orchids GenBank file, and create a string containing the records in FASTA format:</P><PRE CLASS="verbatim">from Bio import SeqIO
from StringIO import StringIO
records = SeqIO.parse("ls_orchid.gbk", "genbank")
out_handle = StringIO()
SeqIO.write(records, out_handle, "fasta")
fasta_data = out_handle.getvalue()
print fasta_data
</PRE><P>This isn&#X2019;t entirely straightforward the first time you see it! On the bright side, for the special case where you would like a string containing a <EM>single</EM> record in a particular file format, Biopython 1.48 added a new <CODE>format()</CODE> method to the <CODE>SeqRecord</CODE> class (see Section&#XA0;<A HREF="#sec:SeqRecord-format">4.6</A>).</P><P>Note that although we don&#X2019;t encourage it, you <EM>can</EM> use the <CODE>format()</CODE> method to write to a file, for example something like this:
</P><PRE CLASS="verbatim">from Bio import SeqIO
out_handle = open("ls_orchid_long.tab", "w")
for record in SeqIO.parse("ls_orchid.gbk", "genbank"):
    if len(record) &gt; 100:
        out_handle.write(record.format("tab"))
out_handle.close()
</PRE><P>While this style of code will work for a simple sequential file format like FASTA or the simple tab separated format used here, it will <EM>not</EM> work for more complex or interlaced file formats. This is why we still recommend using <CODE>Bio.SeqIO.write()</CODE>, as in the following example:
</P><PRE CLASS="verbatim">from Bio import SeqIO
records = (rec for rec in SeqIO.parse("ls_orchid.gbk", "genbank") if len(rec) &gt; 100)
SeqIO.write(records, "ls_orchid.tab", "tab")
</PRE><P>Making a single call to <CODE>SeqIO.write(...)</CODE> is also much quicker than
multiple calls to the <CODE>SeqRecord.format(...)</CODE> method.</P><!--TOC chapter Multiple Sequence Alignment objects-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc68">Chapter&#XA0;6</A>&#XA0;&#XA0;Multiple Sequence Alignment objects</H1><!--SEC END --><P>
<A NAME="chapter:Bio.AlignIO"></A></P><P>This chapter is about Multiple Sequence Alignments, by which we mean a collection of
multiple sequences which have been aligned together &#X2013; usually with the insertion of gap
characters, and addition of leading or trailing gaps &#X2013; such that all the sequence
strings are the same length. Such an alignment can be regarded as a matrix of letters,
where each row is held as a <CODE>SeqRecord</CODE> object internally.</P><P>We will introduce the <CODE>MultipleSeqAlignment</CODE> object which holds this kind of data,
and the <CODE>Bio.AlignIO</CODE> module for reading and writing them as various file formats
(following the design of the <CODE>Bio.SeqIO</CODE> module from the previous chapter).
Note that both <CODE>Bio.SeqIO</CODE> and <CODE>Bio.AlignIO</CODE> can read and write sequence
alignment files. The appropriate choice will depend largely on what you want to do
with the data.</P><P>The final part of this chapter is about our command line wrappers for common multiple
sequence alignment tools like ClustalW and MUSCLE.</P><!--TOC section Parsing or Reading Sequence Alignments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc69">6.1</A>&#XA0;&#XA0;Parsing or Reading Sequence Alignments</H2><!--SEC END --><P>We have two functions for reading in sequence alignments, <CODE>Bio.AlignIO.read()</CODE> and <CODE>Bio.AlignIO.parse()</CODE> which following the convention introduced in <CODE>Bio.SeqIO</CODE> are for files containing one or multiple alignments respectively.</P><P>Using <CODE>Bio.AlignIO.parse()</CODE> will return an <I>iterator</I> which gives <CODE>MultipleSeqAlignment</CODE> objects. Iterators are typically used in a for loop. Examples of situations where you will have multiple different alignments include resampled alignments from the PHYLIP tool <CODE>seqboot</CODE>, or multiple pairwise alignments from the EMBOSS tools <CODE>water</CODE> or <CODE>needle</CODE>, or Bill Pearson&#X2019;s FASTA tools.</P><P>However, in many situations you will be dealing with files which contain only a single alignment. In this case, you should use the <CODE>Bio.AlignIO.read()</CODE> function which returns a single <CODE>MultipleSeqAlignment</CODE> object.</P><P>Both functions expect two mandatory arguments:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The first argument is a <I>handle</I> to read the data from, typically an open file (see Section&#XA0;<A HREF="#sec:appendix-handles">20.1</A>), or a filename.
</LI><LI CLASS="li-enumerate">The second argument is a lower case string specifying the alignment format. As in <CODE>Bio.SeqIO</CODE> we don&#X2019;t try and guess the file format for you! See <A HREF="http://biopython.org/wiki/AlignIO"><TT>http://biopython.org/wiki/AlignIO</TT></A> for a full listing of supported formats.
</LI></OL><P>There is also an optional <CODE>seq_count</CODE> argument which is discussed in Section&#XA0;<A HREF="#sec:AlignIO-count-argument">6.1.3</A> below for dealing with ambiguous file formats which may contain more than one alignment.</P><P>Biopython 1.49 introduced a further optional <CODE>alphabet</CODE> argument allowing you to specify the expected alphabet. This can be useful as many alignment file formats do not explicitly label the sequences as RNA, DNA or protein &#X2013; which means <CODE>Bio.AlignIO</CODE> will default to using a generic alphabet.</P><!--TOC subsection Single Alignments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">6.1.1</A>&#XA0;&#XA0;Single Alignments</H3><!--SEC END --><P>
As an example, consider the following annotation rich protein alignment in the PFAM or Stockholm file format:</P><PRE CLASS="verbatim"># STOCKHOLM 1.0
#=GS COATB_BPIKE/30-81  AC P03620.1
#=GS COATB_BPIKE/30-81  DR PDB; 1ifl ; 1-52;
#=GS Q9T0Q8_BPIKE/1-52  AC Q9T0Q8.1
#=GS COATB_BPI22/32-83  AC P15416.1
#=GS COATB_BPM13/24-72  AC P69541.1
#=GS COATB_BPM13/24-72  DR PDB; 2cpb ; 1-49;
#=GS COATB_BPM13/24-72  DR PDB; 2cps ; 1-49;
#=GS COATB_BPZJ2/1-49   AC P03618.1
#=GS Q9T0Q9_BPFD/1-49   AC Q9T0Q9.1
#=GS Q9T0Q9_BPFD/1-49   DR PDB; 1nh4 A; 1-49;
#=GS COATB_BPIF1/22-73  AC P03619.2
#=GS COATB_BPIF1/22-73  DR PDB; 1ifk ; 1-50;
COATB_BPIKE/30-81             AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA
#=GR COATB_BPIKE/30-81  SS    -HHHHHHHHHHHHHH--HHHHHHHH--HHHHHHHHHHHHHHHHHHHHH----
Q9T0Q8_BPIKE/1-52             AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA
COATB_BPI22/32-83             DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA
COATB_BPM13/24-72             AEGDDP...AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
#=GR COATB_BPM13/24-72  SS    ---S-T...CHCHHHHCCCCTCCCTTCHHHHHHHHHHHHHHHHHHHHCTT--
COATB_BPZJ2/1-49              AEGDDP...AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA
Q9T0Q9_BPFD/1-49              AEGDDP...AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
#=GR Q9T0Q9_BPFD/1-49   SS    ------...-HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH--
COATB_BPIF1/22-73             FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA
#=GR COATB_BPIF1/22-73  SS    XX-HHHH--HHHHHH--HHHHHHH--HHHHHHHHHHHHHHHHHHHHHHH---
#=GC SS_cons                  XHHHHHHHHHHHHHHHCHHHHHHHHCHHHHHHHHHHHHHHHHHHHHHHHC--
#=GC seq_cons                 AEssss...AptAhDSLpspAT-hIu.sWshVsslVsAsluIKLFKKFsSKA
//
</PRE><P>This is the seed alignment for the Phage_Coat_Gp8 (PF05371) PFAM entry, downloaded from a now out of date release of PFAM from <A HREF="http://pfam.sanger.ac.uk/"><TT>http://pfam.sanger.ac.uk/</TT></A>. We can load this file as follows (assuming it has been saved to disk as &#X201C;PF05371_seed.sth&#X201D; in the current working directory):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
</PRE><P>This code will print out a summary of the alignment:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment
SingleLetterAlphabet() alignment with 7 rows and 52 columns
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRL...SKA COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKL...SRA Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRL...SKA COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKL...SRA COATB_BPIF1/22-73
</PRE><P>You&#X2019;ll notice in the above output the sequences have been truncated. We could instead write our own code to format this as we please by iterating over the rows as <CODE>SeqRecord</CODE> objects:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
&gt;&gt;&gt; print "Alignment length %i" % alignment.get_alignment_length()
Alignment length 52
&gt;&gt;&gt; for record in alignment:
...     print "%s - %s" % (record.seq, record.id)
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA - COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA - Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA - COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA - COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA - COATB_BPIF1/22-73
</PRE><P>You could also use the alignment object&#X2019;s <CODE>format</CODE> method to show it in a particular file format &#X2013; see Section&#XA0;<A HREF="#sec:alignment-format-method">6.2.2</A> for details.</P><P>Did you notice in the raw file above that several of the sequences include database cross-references to the PDB and the associated known secondary structure? Try this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for record in alignment:
...     if record.dbxrefs:
...         print record.id, record.dbxrefs
COATB_BPIKE/30-81 ['PDB; 1ifl ; 1-52;']
COATB_BPM13/24-72 ['PDB; 2cpb ; 1-49;', 'PDB; 2cps ; 1-49;']
Q9T0Q9_BPFD/1-49 ['PDB; 1nh4 A; 1-49;']
COATB_BPIF1/22-73 ['PDB; 1ifk ; 1-50;']
</PRE><P>To have a look at all the sequence annotation, try this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for record in alignment:
...     print record
</PRE><P>Sanger provide a nice web interface at <A HREF="http://pfam.sanger.ac.uk/family?acc=PF05371"><TT>http://pfam.sanger.ac.uk/family?acc=PF05371</TT></A> which will actually let you download this alignment in several other formats. This is what the file looks like in the FASTA file format:</P><PRE CLASS="verbatim">&gt;COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA
&gt;Q9T0Q8_BPIKE/1-52
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA
&gt;COATB_BPI22/32-83
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA
&gt;COATB_BPM13/24-72
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
&gt;COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA
&gt;Q9T0Q9_BPFD/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
&gt;COATB_BPIF1/22-73
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA
</PRE><P>Note the website should have an option about showing gaps as periods (dots) or dashes, we&#X2019;ve shown dashes above. Assuming you download and save this as file &#X201C;PF05371_seed.faa&#X201D; then you can load it with almost exactly the same code:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read("PF05371_seed.faa", "fasta")
print alignment
</PRE><P>All that has changed in this code is the filename and the format string. You&#X2019;ll get the same output as before, the sequences and record identifiers are the same.
However, as you should expect, if you check each <CODE>SeqRecord</CODE> there is no annotation nor database cross-references because these are not included in the FASTA file format.</P><P>Note that rather than using the Sanger website, you could have used <CODE>Bio.AlignIO</CODE> to convert the original Stockholm format file into a FASTA file yourself (see below).</P><P>With any supported file format, you can load an alignment in exactly the same way just by changing the format string. For example, use &#X201C;phylip&#X201D; for PHYLIP files, &#X201C;nexus&#X201D; for NEXUS files or &#X201C;emboss&#X201D; for the alignments output by the EMBOSS tools. There is a full listing on the wiki page (<A HREF="http://biopython.org/wiki/AlignIO"><TT>http://biopython.org/wiki/AlignIO</TT></A>) and in the built in documentation (also <A HREF="http://biopython.org/DIST/docs/api/Bio.AlignIO-module.html">online</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; help(AlignIO)
...
</PRE><!--TOC subsection Multiple Alignments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">6.1.2</A>&#XA0;&#XA0;Multiple Alignments</H3><!--SEC END --><P>The previous section focused on reading files containing a single alignment. In general however, files can contain more than one alignment, and to read these files we must use the <CODE>Bio.AlignIO.parse()</CODE> function.</P><P>Suppose you have a small alignment in PHYLIP format:</P><PRE CLASS="verbatim">    5    6
Alpha     AACAAC
Beta      AACCCC
Gamma     ACCAAC
Delta     CCACCA
Epsilon   CCAAAC
</PRE><P>If you wanted to bootstrap a phylogenetic tree using the PHYLIP tools, one of the steps would be to create a set of many resampled alignments using the tool <CODE>bootseq</CODE>. This would give output something like this, which has been abbreviated for conciseness:</P><PRE CLASS="verbatim">    5     6
Alpha     AAACCA
Beta      AAACCC
Gamma     ACCCCA
Delta     CCCAAC
Epsilon   CCCAAA
    5     6
Alpha     AAACAA
Beta      AAACCC
Gamma     ACCCAA
Delta     CCCACC
Epsilon   CCCAAA
    5     6
Alpha     AAAAAC
Beta      AAACCC
Gamma     AACAAC
Delta     CCCCCA
Epsilon   CCCAAC
...
    5     6
Alpha     AAAACC
Beta      ACCCCC
Gamma     AAAACC
Delta     CCCCAA
Epsilon   CAAACC
</PRE><P>If you wanted to read this in using <CODE>Bio.AlignIO</CODE> you could use:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignments = AlignIO.parse("resampled.phy", "phylip")
for alignment in alignments:
    print alignment
    print
</PRE><P>This would give the following output, again abbreviated for display:</P><PRE CLASS="verbatim">SingleLetterAlphabet() alignment with 5 rows and 6 columns
AAACCA Alpha
AAACCC Beta
ACCCCA Gamma
CCCAAC Delta
CCCAAA Epsilon

SingleLetterAlphabet() alignment with 5 rows and 6 columns
AAACAA Alpha
AAACCC Beta
ACCCAA Gamma
CCCACC Delta
CCCAAA Epsilon

SingleLetterAlphabet() alignment with 5 rows and 6 columns
AAAAAC Alpha
AAACCC Beta
AACAAC Gamma
CCCCCA Delta
CCCAAC Epsilon

...

SingleLetterAlphabet() alignment with 5 rows and 6 columns
AAAACC Alpha
ACCCCC Beta
AAAACC Gamma
CCCCAA Delta
CAAACC Epsilon
</PRE><P>As with the function <CODE>Bio.SeqIO.parse()</CODE>, using <CODE>Bio.AlignIO.parse()</CODE> returns an iterator.
If you want to keep all the alignments in memory at once, which will allow you to access them in any order, then turn the iterator into a list:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignments = list(AlignIO.parse("resampled.phy", "phylip"))
last_align = alignments[-1]
first_align = alignments[0]
</PRE><!--TOC subsection Ambiguous Alignments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">6.1.3</A>&#XA0;&#XA0;Ambiguous Alignments</H3><!--SEC END --><P>
<A NAME="sec:AlignIO-count-argument"></A>
Many alignment file formats can explicitly store more than one alignment, and the division between each alignment is clear. However, when a general sequence file format has been used there is no such block structure. The most common such situation is when alignments have been saved in the FASTA file format. For example consider the following:</P><PRE CLASS="verbatim">&gt;Alpha
ACTACGACTAGCTCAG--G
&gt;Beta
ACTACCGCTAGCTCAGAAG
&gt;Gamma
ACTACGGCTAGCACAGAAG
&gt;Alpha
ACTACGACTAGCTCAGG--
&gt;Beta
ACTACCGCTAGCTCAGAAG
&gt;Gamma
ACTACGGCTAGCACAGAAG
</PRE><P>This could be a single alignment containing six sequences (with repeated identifiers). Or, judging from the identifiers, this is probably two different alignments each with three sequences, which happen to all have the same length.</P><P>What about this next example?</P><PRE CLASS="verbatim">&gt;Alpha
ACTACGACTAGCTCAG--G
&gt;Beta
ACTACCGCTAGCTCAGAAG
&gt;Alpha
ACTACGACTAGCTCAGG--
&gt;Gamma
ACTACGGCTAGCACAGAAG
&gt;Alpha
ACTACGACTAGCTCAGG--
&gt;Delta
ACTACGGCTAGCACAGAAG
</PRE><P>Again, this could be a single alignment with six sequences. However this time based on the identifiers we might guess this is three pairwise alignments which by chance have all got the same lengths.</P><P>This final example is similar:</P><PRE CLASS="verbatim">&gt;Alpha
ACTACGACTAGCTCAG--G
&gt;XXX
ACTACCGCTAGCTCAGAAG
&gt;Alpha
ACTACGACTAGCTCAGG
&gt;YYY
ACTACGGCAAGCACAGG
&gt;Alpha
--ACTACGAC--TAGCTCAGG
&gt;ZZZ
GGACTACGACAATAGCTCAGG
</PRE><P>In this third example, because of the differing lengths, this cannot be treated as a single alignment containing all six records. However, it could be three pairwise alignments.</P><P>Clearly trying to store more than one alignment in a FASTA file is not ideal. However, if you are forced to deal with these as input files <CODE>Bio.AlignIO</CODE> can cope with the most common situation where all the alignments have the same number of records.
One example of this is a collection of pairwise alignments, which can be produced by the EMBOSS tools <CODE>needle</CODE> and <CODE>water</CODE> &#X2013; although in this situation, <CODE>Bio.AlignIO</CODE> should be able to understand their native output using &#X201C;emboss&#X201D; as the format string.</P><P>To interpret these FASTA examples as several separate alignments, we can use <CODE>Bio.AlignIO.parse()</CODE> with the optional <CODE>seq_count</CODE> argument which specifies how many sequences are expected in each alignment (in these examples, 3, 2 and 2 respectively).
For example, using the third example as the input data:</P><PRE CLASS="verbatim">for alignment in AlignIO.parse(handle, "fasta", seq_count=2):
    print "Alignment length %i" % alignment.get_alignment_length()
    for record in alignment:
        print "%s - %s" % (record.seq, record.id)
    print
</PRE><P>giving:</P><PRE CLASS="verbatim">Alignment length 19
ACTACGACTAGCTCAG--G - Alpha
ACTACCGCTAGCTCAGAAG - XXX

Alignment length 17
ACTACGACTAGCTCAGG - Alpha
ACTACGGCAAGCACAGG - YYY

Alignment length 21
--ACTACGAC--TAGCTCAGG - Alpha
GGACTACGACAATAGCTCAGG - ZZZ
</PRE><P>Using <CODE>Bio.AlignIO.read()</CODE> or <CODE>Bio.AlignIO.parse()</CODE> without the <CODE>seq_count</CODE> argument would give a single alignment containing all six records for the first two examples. For the third example, an exception would be raised because the lengths differ preventing them being turned into a single alignment.</P><P>If the file format itself has a block structure allowing <CODE>Bio.AlignIO</CODE> to determine the number of sequences in each alignment directly, then the <CODE>seq_count</CODE> argument is not needed. If it is supplied, and doesn&#X2019;t agree with the file contents, an error is raised.</P><P>Note that this optional <CODE>seq_count</CODE> argument assumes each alignment in the file has the same number of sequences. Hypothetically you may come across stranger situations, for example a FASTA file containing several alignments each with a different number of sequences &#X2013; although I would love to hear of a real world example of this. Assuming you cannot get the data in a nicer file format, there is no straight forward way to deal with this using <CODE>Bio.AlignIO</CODE>. In this case, you could consider reading in the sequences themselves using <CODE>Bio.SeqIO</CODE> and batching them together to create the alignments as appropriate.</P><!--TOC section Writing Alignments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc73">6.2</A>&#XA0;&#XA0;Writing Alignments</H2><!--SEC END --><P>We&#X2019;ve talked about using <CODE>Bio.AlignIO.read()</CODE> and <CODE>Bio.AlignIO.parse()</CODE> for alignment input (reading files), and now we&#X2019;ll look at <CODE>Bio.AlignIO.write()</CODE> which is for alignment output (writing files). This is a function taking three arguments: some <CODE>MultipleSeqAlignment</CODE> objects (or for backwards compatibility the obsolete <CODE>Alignment</CODE> objects), a handle or filename to write to, and a sequence format.</P><P>Here is an example, where we start by creating a few <CODE>MultipleSeqAlignment</CODE> objects the hard way (by hand, rather than by loading them from a file).
Note we create some <CODE>SeqRecord</CODE> objects to construct the alignment from.</P><PRE CLASS="verbatim">from Bio.Alphabet import generic_dna
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Align import MultipleSeqAlignment

align1 = MultipleSeqAlignment([
             SeqRecord(Seq("ACTGCTAGCTAG", generic_dna), id="Alpha"),
             SeqRecord(Seq("ACT-CTAGCTAG", generic_dna), id="Beta"),
             SeqRecord(Seq("ACTGCTAGDTAG", generic_dna), id="Gamma"),
         ])

align2 = MultipleSeqAlignment([
             SeqRecord(Seq("GTCAGC-AG", generic_dna), id="Delta"),
             SeqRecord(Seq("GACAGCTAG", generic_dna), id="Epsilon"),
             SeqRecord(Seq("GTCAGCTAG", generic_dna), id="Zeta"),
         ])

align3 = MultipleSeqAlignment([
             SeqRecord(Seq("ACTAGTACAGCTG", generic_dna), id="Eta"),
             SeqRecord(Seq("ACTAGTACAGCT-", generic_dna), id="Theta"),
             SeqRecord(Seq("-CTACTACAGGTG", generic_dna), id="Iota"),
         ])

my_alignments = [align1, align2, align3]
</PRE><P>Now we have a list of <CODE>Alignment</CODE> objects, we&#X2019;ll write them to a PHYLIP format file:</P><PRE CLASS="verbatim">from Bio import AlignIO
AlignIO.write(my_alignments, "my_example.phy", "phylip")
</PRE><P>And if you open this file in your favourite text editor it should look like this:</P><PRE CLASS="verbatim"> 3 12
Alpha      ACTGCTAGCT AG
Beta       ACT-CTAGCT AG
Gamma      ACTGCTAGDT AG
 3 9
Delta      GTCAGC-AG
Epislon    GACAGCTAG
Zeta       GTCAGCTAG
 3 13
Eta        ACTAGTACAG CTG
Theta      ACTAGTACAG CT-
Iota       -CTACTACAG GTG
</PRE><P>Its more common to want to load an existing alignment, and save that, perhaps after some simple manipulation like removing certain rows or columns.</P><P>Suppose you wanted to know how many alignments the <CODE>Bio.AlignIO.write()</CODE> function wrote to the handle? If your alignments were in a list like the example above, you could just use <CODE>len(my_alignments)</CODE>, however you can&#X2019;t do that when your records come from a generator/iterator. Therefore as of Biopython 1.49, the <CODE>Bio.AlignIO.write()</CODE> function returns the number of alignments written to the file. </P><P><EM>Note</EM> - If you tell the <CODE>Bio.AlignIO.write()</CODE> function to write to a file that already exists, the old file will be overwritten without any warning.</P><!--TOC subsection Converting between sequence alignment file formats-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc74">6.2.1</A>&#XA0;&#XA0;Converting between sequence alignment file formats</H3><!--SEC END --><P>
<A NAME="sec:converting-alignments"></A></P><P>Converting between sequence alignment file formats with <CODE>Bio.AlignIO</CODE> works
in the same way as converting between sequence file formats with <CODE>Bio.SeqIO</CODE>
(Section&#XA0;<A HREF="#sec:SeqIO-conversion">5.5.2</A>). We load generally the alignment(s) using
<CODE>Bio.AlignIO.parse()</CODE> and then save them using the <CODE>Bio.AlignIO.write()</CODE>
&#X2013; or just use the <CODE>Bio.AlignIO.convert()</CODE> helper function.</P><P>For this example, we&#X2019;ll load the PFAM/Stockholm format file used earlier and save it as a Clustal W format file:</P><PRE CLASS="verbatim">from Bio import AlignIO
count = AlignIO.convert("PF05371_seed.sth", "stockholm", "PF05371_seed.aln", "clustal")
print "Converted %i alignments" % count
</PRE><P>Or, using <CODE>Bio.AlignIO.parse()</CODE> and <CODE>Bio.AlignIO.write()</CODE>:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignments = AlignIO.parse("PF05371_seed.sth", "stockholm")
count = AlignIO.write(alignments, "PF05371_seed.aln", "clustal")
print "Converted %i alignments" % count
</PRE><P>The <CODE>Bio.AlignIO.write()</CODE> function expects to be given multiple alignment objects. In the example above we gave it the alignment iterator returned by <CODE>Bio.AlignIO.parse()</CODE>.</P><P>In this case, we know there is only one alignment in the file so we could have used <CODE>Bio.AlignIO.read()</CODE> instead, but notice we have to pass this alignment to <CODE>Bio.AlignIO.write()</CODE> as a single element list:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
AlignIO.write([alignment], "PF05371_seed.aln", "clustal")
</PRE><P>Either way, you should end up with the same new Clustal W format file &#X201C;PF05371_seed.aln&#X201D; with the following content:</P><PRE CLASS="verbatim">CLUSTAL X (1.81) multiple sequence alignment


COATB_BPIKE/30-81                   AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSS
Q9T0Q8_BPIKE/1-52                   AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVS
COATB_BPI22/32-83                   DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSS
COATB_BPM13/24-72                   AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTS
COATB_BPZJ2/1-49                    AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFAS
Q9T0Q9_BPFD/1-49                    AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTS
COATB_BPIF1/22-73                   FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVS

COATB_BPIKE/30-81                   KA
Q9T0Q8_BPIKE/1-52                   RA
COATB_BPI22/32-83                   KA
COATB_BPM13/24-72                   KA
COATB_BPZJ2/1-49                    KA
Q9T0Q9_BPFD/1-49                    KA
COATB_BPIF1/22-73                   RA
</PRE><P>Alternatively, you could make a PHYLIP format file which we&#X2019;ll name &#X201C;PF05371_seed.phy&#X201D;:</P><PRE CLASS="verbatim">from Bio import AlignIO
AlignIO.convert("PF05371_seed.sth", "stockholm", "PF05371_seed.phy", "phylip")
</PRE><P>This time the output looks like this:</P><PRE CLASS="verbatim"> 7 52
COATB_BPIK AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIRLFKKFSS
Q9T0Q8_BPI AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIKLFKKFVS
COATB_BPI2 DGTSTATSYA TEAMNSLKTQ ATDLIDQTWP VVTSVAVAGL AIRLFKKFSS
COATB_BPM1 AEGDDP---A KAAFNSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
COATB_BPZJ AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFAS
Q9T0Q9_BPF AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
COATB_BPIF FAADDATSQA KAAFDSLTAQ ATEMSGYAWA LVVLVVGATV GIKLFKKFVS

           KA
           RA
           KA
           KA
           KA
           KA
           RA
</PRE><P>One of the big handicaps of the PHYLIP alignment file format is that the sequence identifiers are strictly truncated at ten characters. In this example, as you can see the resulting names are still unique - but they are not very readable. In this particular case, there is no clear way to compress the identifiers, but for the sake of argument you may want to assign your own names or numbering system. This following bit of code manipulates the record identifiers before saving the output:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
name_mapping = {}
for i, record in enumerate(alignment):
    name_mapping[i] = record.id
    record.id = "seq%i" % i
print name_mapping

AlignIO.write([alignment], "PF05371_seed.phy", "phylip")
</PRE><P>This code used a Python dictionary to record a simple mapping from the new sequence system to the original identifier:
</P><PRE CLASS="verbatim">{0: 'COATB_BPIKE/30-81', 1: 'Q9T0Q8_BPIKE/1-52', 2: 'COATB_BPI22/32-83', ...}
</PRE><P>Here is the new PHYLIP format output:
</P><PRE CLASS="verbatim"> 7 52
seq0       AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIRLFKKFSS
seq1       AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIKLFKKFVS
seq2       DGTSTATSYA TEAMNSLKTQ ATDLIDQTWP VVTSVAVAGL AIRLFKKFSS
seq3       AEGDDP---A KAAFNSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
seq4       AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFAS
seq5       AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
seq6       FAADDATSQA KAAFDSLTAQ ATEMSGYAWA LVVLVVGATV GIKLFKKFVS

           KA
           RA
           KA
           KA
           KA
           KA
           RA
</PRE><P>In general, because of the identifier limitation, working with PHYLIP file formats shouldn&#X2019;t be your first choice. Using the PFAM/Stockholm format on the other hand allows you to record a lot of additional annotation too.</P><!--TOC subsection Getting your alignment objects as formatted strings-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc75">6.2.2</A>&#XA0;&#XA0;Getting your alignment objects as formatted strings</H3><!--SEC END --><P>
<A NAME="sec:alignment-format-method"></A>
The <CODE>Bio.AlignIO</CODE> interface is based on handles, which means if you want to get your alignment(s) into a string in a particular file format you need to do a little bit more work (see below). 
However, you will probably prefer to take advantage of the new <CODE>format()</CODE> method added to the alignment object in Biopython 1.48. This takes a single mandatory argument, a lower case string which is supported by <CODE>Bio.AlignIO</CODE> as an output format. For example:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
print alignment.format("clustal")
</PRE><P>As described in Section&#XA0;<A HREF="#sec:SeqRecord-format">4.6</A>), the <CODE>SeqRecord</CODE> object has a similar method using output formats supported by <CODE>Bio.SeqIO</CODE>.</P><P>Internally the <CODE>format()</CODE> method is using the <CODE>StringIO</CODE> string based handle and calling
<CODE>Bio.AlignIO.write()</CODE>. You can do this in your own code if for example you are using an
older version of Biopython:</P><PRE CLASS="verbatim">from Bio import AlignIO
from StringIO import StringIO

alignments = AlignIO.parse("PF05371_seed.sth", "stockholm")

out_handle = StringIO()
AlignIO.write(alignments, out_handle, "clustal")
clustal_data = out_handle.getvalue()

print clustal_data
</PRE><!--TOC section Manipulating Alignments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc76">6.3</A>&#XA0;&#XA0;Manipulating Alignments</H2><!--SEC END --><P>
<A NAME="sec:manipulating-alignments"></A></P><P>Now that we&#X2019;ve covered loading and saving alignments, we&#X2019;ll look at what else you can do
with them. Note that many of these features are new in Biopython 1.54.</P><P>First of all, in some senses the alignment objects act like a Python <CODE>list</CODE> of
<CODE>SeqRecord</CODE> objects (the rows). With this model in mind hopefully the actions
of <CODE>len()</CODE> (the number of rows) and iteration (each row as a <CODE>SeqRecord</CODE>)
make sense:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; alignment = AlignIO.read("PF05371_seed.sth", "stockholm")
&gt;&gt;&gt; print "Number of rows: %i" % len(alignment)
Number of rows: 7
&gt;&gt;&gt; for record in alignment:
...     print "%s - %s" % (record.seq, record.id)
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA - COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA - Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA - COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA - COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA - COATB_BPIF1/22-73
</PRE><P>You can also use the list-like <CODE>append</CODE> and <CODE>extend</CODE> methods to add
more rows to the alignment (as <CODE>SeqRecord</CODE> objects). Keeping the list
metaphor in mind, simple slicing of the alignment should also make sense -
it selects some of the rows giving back another alignment object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment
SingleLetterAlphabet() alignment with 7 rows and 52 columns
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRL...SKA COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKL...SRA Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRL...SKA COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKL...SRA COATB_BPIF1/22-73
&gt;&gt;&gt; print alignment[3:7]
SingleLetterAlphabet() alignment with 4 rows and 52 columns
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKL...SRA COATB_BPIF1/22-73
</PRE><P>What if you wanted to select by column? Those of you who have used the NumPy
matrix or array objects won&#X2019;t be surprised at this - you use a double index.</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment[2,6]
T
</PRE><P>Using two integer indices pulls out a single letter, short hand for this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment[2].seq[6]
T
</PRE><P>You can pull out a single column as a string like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment[:,6]
TTT---T
</PRE><P>You can also select a range of columns. For example, to pick out those same
three rows we extracted earlier, but take just their first six columns:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment[3:6,:6]
SingleLetterAlphabet() alignment with 3 rows and 6 columns
AEGDDP COATB_BPM13/24-72
AEGDDP COATB_BPZJ2/1-49
AEGDDP Q9T0Q9_BPFD/1-49
</PRE><P>Leaving the first index as <CODE>:</CODE> means take all the rows:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment[:,:6]
SingleLetterAlphabet() alignment with 7 rows and 6 columns
AEPNAA COATB_BPIKE/30-81
AEPNAA Q9T0Q8_BPIKE/1-52
DGTSTA COATB_BPI22/32-83
AEGDDP COATB_BPM13/24-72
AEGDDP COATB_BPZJ2/1-49
AEGDDP Q9T0Q9_BPFD/1-49
FAADDA COATB_BPIF1/22-73
</PRE><P>This brings us to a neat way to remove a section. Notice columns
7, 8 and 9 which are gaps in three of the seven sequences:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment[:,6:9]
SingleLetterAlphabet() alignment with 7 rows and 3 columns
TNY COATB_BPIKE/30-81
TNY Q9T0Q8_BPIKE/1-52
TSY COATB_BPI22/32-83
--- COATB_BPM13/24-72
--- COATB_BPZJ2/1-49
--- Q9T0Q9_BPFD/1-49
TSQ COATB_BPIF1/22-73
</PRE><P>Again, you can slice to get everything after the ninth column:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print alignment[:,9:]
SingleLetterAlphabet() alignment with 7 rows and 43 columns
ATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA COATB_BPIKE/30-81
ATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA Q9T0Q8_BPIKE/1-52
ATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA COATB_BPI22/32-83
AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA COATB_BPM13/24-72
AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA COATB_BPZJ2/1-49
AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA Q9T0Q9_BPFD/1-49
AKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA COATB_BPIF1/22-73
</PRE><P>Now, the interesting thing is that addition of alignment objects works
by column. This lets you do this as a way to remove a block of columns:</P><PRE CLASS="verbatim">&gt;&gt;&gt; edited = alignment[:,:6] + alignment[:,9:]
&gt;&gt;&gt; print edited
SingleLetterAlphabet() alignment with 7 rows and 49 columns
AEPNAAATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA COATB_BPIKE/30-81
AEPNAAATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA Q9T0Q8_BPIKE/1-52
DGTSTAATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA COATB_BPI22/32-83
AEGDDPAKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA COATB_BPM13/24-72
AEGDDPAKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA COATB_BPZJ2/1-49
AEGDDPAKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA Q9T0Q9_BPFD/1-49
FAADDAAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA COATB_BPIF1/22-73
</PRE><P>Another common use of alignment addition would be to combine alignments for
several different genes into a meta-alignment. Watch out though - the identifiers
need to match up (see Section&#XA0;<A HREF="#sec:SeqRecord-addition">4.8</A> for how adding
<CODE>SeqRecord</CODE> objects works). You may find it helpful to first sort the
alignment rows alphabetically by id:</P><PRE CLASS="verbatim">&gt;&gt;&gt; edited.sort()
&gt;&gt;&gt; print edited
SingleLetterAlphabet() alignment with 7 rows and 49 columns
DGTSTAATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA COATB_BPI22/32-83
FAADDAAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA COATB_BPIF1/22-73
AEPNAAATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA COATB_BPIKE/30-81
AEGDDPAKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA COATB_BPM13/24-72
AEGDDPAKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA COATB_BPZJ2/1-49
AEPNAAATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA Q9T0Q8_BPIKE/1-52
AEGDDPAKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA Q9T0Q9_BPFD/1-49
</PRE><P>Note that you can only add two alignments together if they
have the same number of rows.</P><!--TOC section Alignment Tools-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc77">6.4</A>&#XA0;&#XA0;Alignment Tools</H2><!--SEC END --><P>
<A NAME="sec:alignment-tools"></A></P><P>There are <EM>lots</EM> of algorithms out there for aligning sequences, both pairwise alignments
and multiple sequence alignments. These calculations are relatively slow, and you generally
wouldn&#X2019;t want to write such an algorithm in Python. Instead, you can use Biopython to invoke
a command line tool on your behalf. Normally you would:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Prepare an input file of your unaligned sequences, typically this will be a FASTA file
which you might create using <CODE>Bio.SeqIO</CODE> (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>).
</LI><LI CLASS="li-enumerate">Call the command line tool to process this input file, typically via one of Biopython&#X2019;s
command line wrappers (which we&#X2019;ll discuss here).
</LI><LI CLASS="li-enumerate">Read the output from the tool, i.e. your aligned sequences, typically using
<CODE>Bio.AlignIO</CODE> (see earlier in this chapter). 
</LI></OL><P>All the command line wrappers we&#X2019;re going to talk about in this chapter follow the same style.
You create a command line object specifying the options (e.g. the input filename and the
output filename), then invoke this command line via a Python operating system call (e.g.
using the <TT>subprocess</TT> module).</P><P>Most of these wrappers are defined in the <CODE>Bio.Align.Applications</CODE> module:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import Bio.Align.Applications
&gt;&gt;&gt; dir(Bio.Align.Applications)
...
['ClustalwCommandline', 'DialignCommandline', 'MafftCommandline', 'MuscleCommandline',
'PrankCommandline', 'ProbconsCommandline', 'TCoffeeCommandline' ...]
</PRE><P>(Ignore the entries starting with an underscore &#X2013; these have
special meaning in Python.)
The module <CODE>Bio.Emboss.Applications</CODE> has wrappers for some of the
<A HREF="http://emboss.sourceforge.net/">EMBOSS suite</A>, including
<TT>needle</TT> and <TT>water</TT>, which are described below in
Section&#XA0;<A HREF="#seq:emboss-needle-water">6.4.5</A>, and wrappers for the EMBOSS
packaged versions of the PHYLIP tools (which EMBOSS refer to as one
of their EMBASSY packages - third party tools with an EMBOSS style
interface).
We won&#X2019;t explore all these alignment tools here in the section, just a
sample, but the same principles apply.</P><!--TOC subsection ClustalW-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc78">6.4.1</A>&#XA0;&#XA0;ClustalW</H3><!--SEC END --><P>
<A NAME="sec:align_clustal"></A>
ClustalW is a popular command line tool for multiple sequence alignment
(there is also a graphical interface called ClustalX). Biopython&#X2019;s
<CODE>Bio.Align.Applications</CODE> module has a wrapper for this alignment tool
(and several others).</P><P>Before trying to use ClustalW from within Python, you should first try running
the ClustalW tool yourself by hand at the command line, to familiarise
yourself the other options. You&#X2019;ll find the Biopython wrapper is very
faithful to the actual command line API:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import ClustalwCommandline
&gt;&gt;&gt; help(ClustalwCommandline)
...
</PRE><P>For the most basic usage, all you need is to have a FASTA input file, such as
<A HREF="http://biopython.org/DIST/docs/tutorial/examples/opuntia.fasta">opuntia.fasta</A>
(available online or in the Doc/examples subdirectory of the Biopython source
code). This is a small FASTA file containing seven prickly-pear DNA sequences
(from the cactus family <I>Opuntia</I>).</P><P>By default ClustalW will generate an alignment and guide tree file with names
based on the input FASTA file, in this case <TT>opuntia.aln</TT> and
<TT>opuntia.dnd</TT>, but you can override this or make it explicit:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import ClustalwCommandline
&gt;&gt;&gt; cline = ClustalwCommandline("clustalw2", infile="opuntia.fasta")
&gt;&gt;&gt; print cline
clustalw2 -infile=opuntia.fasta
</PRE><P>Notice here we have given the executable name as <TT>clustalw2</TT>,
indicating we have version two installed, which has a different filename to
version one (<TT>clustalw</TT>, the default). Fortunately both versions
support the same set of arguments at the command line (and indeed, should be
functionally identical).</P><P>You may find that even though you have ClustalW installed, the above command
doesn&#X2019;t work &#X2013; you may get a message about &#X201C;command not found&#X201D; (especially
on Windows). This indicated that the ClustalW executable is not on your PATH
(an environment variable, a list of directories to be searched). You can
either update your PATH setting to include the location of your copy of
ClustalW tools (how you do this will depend on your OS), or simply type in
the full path of the tool. For example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import os
&gt;&gt;&gt; from Bio.Align.Applications import ClustalwCommandline
&gt;&gt;&gt; clustalw_exe = r"C:\Program Files\new clustal\clustalw2.exe"
&gt;&gt;&gt; clustalw_cline = ClustalwCommandline(clustalw_exe, infile="opuntia.fasta")
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; assert os.path.isfile(clustalw_exe), "Clustal W executable missing"
&gt;&gt;&gt; stdout, stderr = clustalw_cline()
</PRE><P>Remember, in Python strings <CODE>\n</CODE> and <CODE>\t</CODE> are by default
interpreted as a new line and a tab &#X2013; which is why we&#X2019;re put a letter
&#X201C;r&#X201D; at the start for a raw string that isn&#X2019;t translated in this way.
This is generally good practice when specifying a Windows style file name.</P><P>The last line of the example requires Biopython 1.55 or later to run the
the command line tool via our wrapper object. Internally this uses the
<CODE>subprocess</CODE> module which is now the recommended way to run another
program in Python. This replaces older options like the <CODE>os.system()</CODE>
and the <CODE>os.popen*</CODE> functions.</P><P>Now, at this point it helps to know about how command line tools &#X201C;work&#X201D;.
When you run a tool at the command line, it will often print text output
directly to screen. This text can be captured or redirected, via
two &#X201C;pipes&#X201D;, called standard output (the normal results) and standard
error (for error messages and debug messages). There is also standard
input, which is any text fed into the tool. These names get shortened
to stdin, stdout and stderr. When the tool finishes, it has a return
code (an integer), which by convention is zero for success.</P><P>When you run the command line tool like this via the Biopython wrapper,
it will wait for it to finish, and check the return code. If this is
non zero (indicating an error), an exception is raised. The wrapper
then returns two strings, stdout and stderr.</P><P>In the case of ClustalW, when run at the command line all the important
output is written directly to the output files. Everything normally printed to
screen while you wait (via stdout or stderr) is boring and can be
ignored (assuming it worked).</P><P>What we care about are the two output files, the alignment and the guide
tree. We didn&#X2019;t tell ClustalW what filenames to use, but it defaults to
picking names based on the input file. In this case the output should be
in the file <CODE>opuntia.aln</CODE>.
You should be able to work out how to read in the alignment using
<CODE>Bio.AlignIO</CODE> by now:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; align = AlignIO.read("opuntia.aln", "clustal")
&gt;&gt;&gt; print align
SingleLetterAlphabet() alignment with 7 rows and 906 columns
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF191
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF191
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF191
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF191
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF191
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF191
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273291|gb|AF191665.1|AF191
</PRE><P>In case you are interested (and this is an aside from the main thrust of this
chapter), the <TT>opuntia.dnd</TT> file ClustalW creates is just a standard
Newick tree file, and <CODE>Bio.Phylo</CODE> can parse these:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Phylo
&gt;&gt;&gt; tree = Phylo.read("opuntia.dnd", "newick")
&gt;&gt;&gt; Phylo.draw_ascii(tree)
                             _______________ gi|6273291|gb|AF191665.1|AF191665
  __________________________|
 |                          |   ______ gi|6273290|gb|AF191664.1|AF191664
 |                          |__|
 |                             |_____ gi|6273289|gb|AF191663.1|AF191663
 |
_|_________________ gi|6273287|gb|AF191661.1|AF191661
 |
 |__________ gi|6273286|gb|AF191660.1|AF191660
 |
 |    __ gi|6273285|gb|AF191659.1|AF191659
 |___|
     | gi|6273284|gb|AF191658.1|AF191658

</PRE><P>Chapter <A HREF="#sec:Phylo">12</A> covers Biopython&#X2019;s support for phylogenetic trees in more
depth.</P><!--TOC subsection MUSCLE-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc79">6.4.2</A>&#XA0;&#XA0;MUSCLE</H3><!--SEC END --><P>
MUSCLE is a more recent multiple sequence alignment tool than ClustalW, and
Biopython also has a wrapper for it under the <CODE>Bio.Align.Applications</CODE>
module. As before, we recommend you try using MUSCLE from the command line before
trying it from within Python, as the Biopython wrapper is very faithful to the
actual command line API:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import MuscleCommandline
&gt;&gt;&gt; help(MuscleCommandline)
...
</PRE><P>For the most basic usage, all you need is to have a FASTA input file, such as
<A HREF="http://biopython.org/DIST/docs/tutorial/examples/opuntia.fasta">opuntia.fasta</A>
(available online or in the Doc/examples subdirectory of the Biopython source
code). You can then tell MUSCLE to read in this FASTA file, and write the
alignment to an output file:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import MuscleCommandline
&gt;&gt;&gt; cline = MuscleCommandline(input="opuntia.fasta", out="opuntia.txt")
&gt;&gt;&gt; print cline
muscle -in opuntia.fasta -out opuntia.txt
</PRE><P>Note that MUSCLE uses &#X201C;-in&#X201D; and &#X201C;-out&#X201D; but in Biopython we have to use
&#X201C;input&#X201D; and &#X201C;out&#X201D; as the keyword arguments or property names. This is
because &#X201C;in&#X201D; is a reserved word in Python.</P><P>By default MUSCLE will output the alignment as a FASTA file (using gapped
sequences). The <CODE>Bio.AlignIO</CODE> module should be able to read this
alignment using <TT>format="fasta"</TT>.
You can also ask for ClustalW-like output:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import MuscleCommandline
&gt;&gt;&gt; cline = MuscleCommandline(input="opuntia.fasta", out="opuntia.aln", clw=True)
&gt;&gt;&gt; print cline
muscle -in opuntia.fasta -out opuntia.aln -clw
</PRE><P>Or, strict ClustalW output where the original ClustalW header line is
used for maximum compatibility:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import MuscleCommandline
&gt;&gt;&gt; cline = MuscleCommandline(input="opuntia.fasta", out="opuntia.aln", clwstrict=True)
&gt;&gt;&gt; print cline
muscle -in opuntia.fasta -out opuntia.aln -clwstrict
</PRE><P>The <CODE>Bio.AlignIO</CODE> module should be able to read these alignments
using <TT>format="clustal"</TT>.</P><P>MUSCLE can also output in GCG MSF format (using the <TT>msf</TT> argument), but
Biopython can&#X2019;t currently parse that, or using HTML which would give a human
readable web page (not suitable for parsing).</P><P>You can also set the other optional parameters, for example the maximum number
of iterations. See the built in help for details.</P><P>You would then run MUSCLE command line string as described above for
ClustalW, and parse the output using <CODE>Bio.AlignIO</CODE> to get an
alignment object.</P><!--TOC subsection MUSCLE using stdout-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc80">6.4.3</A>&#XA0;&#XA0;MUSCLE using stdout</H3><!--SEC END --><P>Using a MUSCLE command line as in the examples above will write the alignment
to a file. This means there will be no important information written to the
standard out (stdout) or standard error (stderr) handles. However, by default
MUSCLE will write the alignment to standard output (stdout). We can take
advantage of this to avoid having a temporary output file! For example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import MuscleCommandline
&gt;&gt;&gt; muscle_cline = MuscleCommandline(input="opuntia.fasta")
&gt;&gt;&gt; print muscle_cline
muscle -in opuntia.fasta
</PRE><P>If we run this via the wrapper, we get back the output as a string. In order
to parse this we can use <CODE>StringIO</CODE> to turn it into a handle.
Remember that MUSCLE defaults to using FASTA as the output format:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import MuscleCommandline
&gt;&gt;&gt; muscle_cline = MuscleCommandline(input="opuntia.fasta")
&gt;&gt;&gt; stdout, stderr = muscle_cline()
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; align = AlignIO.read(StringIO(stdout), "fasta")
&gt;&gt;&gt; print align
SingleLetterAlphabet() alignment with 7 rows and 906 columns
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF191663
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273291|gb|AF191665.1|AF191665
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF191664
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF191661
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF191660
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF191659
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF191658
</PRE><P>The above approach is fairly simple, but if you are dealing with very large output
text the fact that all of stdout and stderr is loaded into memory as a string can
be a potential drawback. Using the <CODE>subprocess</CODE> module we can work directly
with handles instead:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; from Bio.Align.Applications import MuscleCommandline
&gt;&gt;&gt; muscle_cline = MuscleCommandline(input="opuntia.fasta")
&gt;&gt;&gt; child = subprocess.Popen(str(muscle_cline),
...                          stdout=subprocess.PIPE,
...                          stderr=subprocess.PIPE,
...                          shell=(sys.platform!="win32"))
&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; align = AlignIO.read(child.stdout, "fasta")
&gt;&gt;&gt; print align
SingleLetterAlphabet() alignment with 7 rows and 906 columns
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF191663
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273291|gb|AF191665.1|AF191665
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF191664
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF191661
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF191660
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF191659
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF191658
</PRE><!--TOC subsection MUSCLE using stdin and stdout-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">6.4.4</A>&#XA0;&#XA0;MUSCLE using stdin and stdout</H3><!--SEC END --><P>We don&#X2019;t actually <EM>need</EM> to have our FASTA input sequences prepared in a file,
because by default MUSCLE will read in the input sequence from standard input!
Note this is a bit more advanced and fiddly, so don&#X2019;t bother with this technique
unless you need to.</P><P>First, we&#X2019;ll need some unaligned sequences in memory as <CODE>SeqRecord</CODE> objects.
For this demonstration I&#X2019;m going to use a filtered version of the original FASTA
file (using a generator expression), taking just six of the seven sequences:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; records = (r for r in SeqIO.parse("opuntia.fasta", "fasta") if len(r) &lt; 900)
</PRE><P>Then we create the MUSCLE command line, leaving the input and output to their
defaults (stdin and stdout). I&#X2019;m also going to ask for strict ClustalW format
as for the output.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Align.Applications import MuscleCommandline
&gt;&gt;&gt; muscle_cline = MuscleCommandline(clwstrict=True)
&gt;&gt;&gt; print muscle_cline
muscle -clwstrict
</PRE><P>Now for the fiddly bits using the <CODE>subprocess</CODE> module, stdin and stdout:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import subprocess
&gt;&gt;&gt; import sys
&gt;&gt;&gt; child = subprocess.Popen(str(cline),
...                          stdin=subprocess.PIPE,
...                          stdout=subprocess.PIPE,
...                          stderr=subprocess.PIPE,
...                          shell=(sys.platform!="win32"))                     
</PRE><P>That should start MUSCLE, but it will be sitting waiting for its FASTA input
sequences, which we must supply via its stdin handle:</P><PRE CLASS="verbatim">&gt;&gt;&gt; SeqIO.write(records, child.stdin, "fasta")
6
&gt;&gt;&gt; child.stdin.close()
</PRE><P>After writing the six sequences to the handle, MUSCLE will still be waiting
to see if that is all the FASTA sequences or not &#X2013; so we must signal that
this is all the input data by closing the handle. At that point MUSCLE should
start to run, and we can ask for the output:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; align = AlignIO.read(child.stdout, "clustal")
&gt;&gt;&gt; print align
SingleLetterAlphabet() alignment with 6 rows and 900 columns
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF19166
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF19166
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF19166
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF19166
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF19165
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF19165
</PRE><P>Wow! There we are with a new alignment of just the six records, without having created
a temporary FASTA input file, or a temporary alignment output file. However, a word of
caution: Dealing with errors with this style of calling external programs is much more
complicated.
It also becomes far harder to diagnose problems, because you can&#X2019;t try running MUSCLE
manually outside of Biopython (because you don&#X2019;t have the input file to supply).
There can also be subtle cross platform issues (e.g. Windows versus Linux), and how
you run your script can have an impact (e.g. at the command line, from IDLE or an
IDE, or as a GUI script). These are all generic Python issues though, and not
specific to Biopython.</P><P>If you find working directly with <TT>subprocess</TT> like this scary, there is an
alternative. If you execute the tool with <TT>muscle_cline()</TT> you can supply
any standard input as a big string, <TT>muscle_cline(stdin=...)</TT>. So,
provided your data isn&#X2019;t very big, you can prepare the FASTA input in memory as
a string using <TT>StringIO</TT> (see Section&#XA0;<A HREF="#sec:appendix-handles">20.1</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; records = (r for r in SeqIO.parse("opuntia.fasta", "fasta") if len(r) &lt; 900)
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; handle = StringIO()
&gt;&gt;&gt; SeqIO.write(records, handle, "fasta")
6
&gt;&gt;&gt; data = handle.getvalue()
</PRE><P>You can then run the tool and parse the alignment as follows:</P><PRE CLASS="verbatim">&gt;&gt;&gt; stdout, stderr = muscle_cline(stdin=data)
&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; align = AlignIO.read(StringIO(stdout), "clustal")
&gt;&gt;&gt; print align
SingleLetterAlphabet() alignment with 6 rows and 900 columns
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273290|gb|AF191664.1|AF19166
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273289|gb|AF191663.1|AF19166
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273287|gb|AF191661.1|AF19166
TATACATAAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273286|gb|AF191660.1|AF19166
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273285|gb|AF191659.1|AF19165
TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAG...AGA gi|6273284|gb|AF191658.1|AF19165
</PRE><P>You might find this easier, but it does require more memory (RAM) for the strings
used for the input FASTA and output Clustal formatted data.</P><!--TOC subsection EMBOSS needle and water-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc82">6.4.5</A>&#XA0;&#XA0;EMBOSS needle and water</H3><!--SEC END --><P>
<A NAME="seq:emboss-needle-water"></A>
The <A HREF="http://emboss.sourceforge.net/">EMBOSS</A> suite includes the <TT>water</TT> and
<TT>needle</TT> tools for Smith-Waterman algorithm local alignment, and Needleman-Wunsch
global alignment. The tools share the same style interface, so switching between the two
is trivial &#X2013; we&#X2019;ll just use <TT>needle</TT> here.</P><P>Suppose you want to do a global pairwise alignment between two sequences, prepared in
FASTA format as follows:</P><PRE CLASS="verbatim">&gt;HBA_HUMAN
MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSHGSAQVKGHG
KKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFKLLSHCLLVTLAAHLPAEFTP
AVHASLDKFLASVSTVLTSKYR
</PRE><P>in a file <TT>alpha.fasta</TT>, and secondly in a file <TT>beta.fasta</TT>:</P><PRE CLASS="verbatim">&gt;HBB_HUMAN
MVHLTPEEKSAVTALWGKVNVDEVGGEALGRLLVVYPWTQRFFESFGDLSTPDAVMGNPK
VKAHGKKVLGAFSDGLAHLDNLKGTFATLSELHCDKLHVDPENFRLLGNVLVCVLAHHFG
KEFTPPVQAAYQKVVAGVANALAHKYH
</PRE><P>Let&#X2019;s start by creating a complete <TT>needle</TT> command line object in one go:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Emboss.Applications import NeedleCommandline
&gt;&gt;&gt; needle_cline = NeedleCommandline(asequence="alpha.faa", bsequence="beta.faa",
...                                  gapopen=10, gapextend=0.5, outfile="needle.txt")
&gt;&gt;&gt; print needle_cline
needle -outfile=needle.txt -asequence=alpha.faa -bsequence=beta.faa -gapopen=10 -gapextend=0.5
</PRE><P>Why not try running this by hand at the command prompt? You should see it does a
pairwise comparison and records the output in the file <TT>needle.txt</TT> (in the
default EMBOSS alignment file format).</P><P>Even if you have EMBOSS installed, running this command may not work &#X2013; you
might get a message about &#X201C;command not found&#X201D; (especially on Windows). This
probably means that the EMBOSS tools are not on your PATH environment
variable. You can either update your PATH setting, or simply tell Biopython
the full path to the tool, for example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Emboss.Applications import NeedleCommandline
&gt;&gt;&gt; needle_cline = NeedleCommandline(r"C:\EMBOSS\needle.exe",
...                                  asequence="alpha.faa", bsequence="beta.faa",
...                                  gapopen=10, gapextend=0.5, outfile="needle.txt")
</PRE><P>Remember in Python that for a default string <CODE>\n</CODE> or <CODE>\t</CODE> means a
new line or a tab &#X2013; which is why we&#X2019;re put a letter &#X201C;r&#X201D; at the start for a raw string.</P><P>At this point it might help to try running the EMBOSS tools yourself by hand at the
command line, to familiarise yourself the other options and compare them to the
Biopython help text:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Emboss.Applications import NeedleCommandline
&gt;&gt;&gt; help(NeedleCommandline)
...
</PRE><P>Note that you can also specify (or change or look at) the settings like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Emboss.Applications import NeedleCommandline
&gt;&gt;&gt; needle_cline = NeedleCommandline()
&gt;&gt;&gt; needle_cline.asequence="alpha.faa"
&gt;&gt;&gt; needle_cline.bsequence="beta.faa"
&gt;&gt;&gt; needle_cline.gapopen=10
&gt;&gt;&gt; needle_cline.gapextend=0.5
&gt;&gt;&gt; needle_cline.outfile="needle.txt"
&gt;&gt;&gt; print needle_cline
needle -outfile=needle.txt -asequence=alpha.faa -bsequence=beta.faa -gapopen=10 -gapextend=0.5
&gt;&gt;&gt; print needle_cline.outfile
needle.txt
</PRE><P>Next we want to use Python to run this command for us. As explained above,
for full control, we recommend you use the built in Python <TT>subprocess</TT>
module, but for simple usage the wrapper object usually suffices:</P><PRE CLASS="verbatim">&gt;&gt;&gt; stdout, stderr = needle_cline()
&gt;&gt;&gt; print stdout + stderr
Needleman-Wunsch global alignment of two sequences
</PRE><P>Next we can load the output file with <CODE>Bio.AlignIO</CODE> as
discussed earlier in this chapter, as the <TT>emboss</TT> format:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import AlignIO
&gt;&gt;&gt; align = AlignIO.read("needle.txt", "emboss")
&gt;&gt;&gt; print align
SingleLetterAlphabet() alignment with 2 rows and 149 columns
MV-LSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTY...KYR HBA_HUMAN
MVHLTPEEKSAVTALWGKV--NVDEVGGEALGRLLVVYPWTQRF...KYH HBB_HUMAN
</PRE><P>In this example, we told EMBOSS to write the output to a file, but you
<EM>can</EM> tell it to write the output to stdout instead (useful if you
don&#X2019;t want a temporary output file to get rid of &#X2013; use
<TT>stdout=True</TT> rather than the <TT>outfile</TT> argument), and
also to read <EM>one</EM> of the one of the inputs from stdin (e.g.
<TT>asequence="stdin"</TT>, much like in the MUSCLE example in the
section above).</P><P>This has only scratched the surface of what you can do with <TT>needle</TT>
and <TT>water</TT>. One useful trick is that the second file can contain
multiple sequences (say five), and then EMBOSS will do five pairwise
alignments.</P><P>Note - Biopython includes its own pairwise alignment code in the <CODE>Bio.pairwise2</CODE>
module (written in C for speed, but with a pure Python fallback available too). This
doesn&#X2019;t work with alignment objects, so we have not covered it within this chapter.
See the module&#X2019;s docstring (built in help) for details.</P><!--TOC chapter BLAST-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc83">Chapter&#XA0;7</A>&#XA0;&#XA0;BLAST</H1><!--SEC END --><P>
<A NAME="chapter:blast"></A>
Hey, everybody loves BLAST right? I mean, geez, how can get it get any easier to do comparisons between one of your sequences and every other sequence in the known world? But, of course, this section isn&#X2019;t about how cool BLAST is, since we already know that. It is about the problem with BLAST &#X2013; it can be really difficult to deal with the volume of data generated by large runs, and to automate BLAST runs in general.</P><P>Fortunately, the Biopython folks know this only too well, so they&#X2019;ve developed lots of tools for dealing with BLAST and making things much easier. This section details how to use these tools and do useful things with them.</P><P>Dealing with BLAST can be split up into two steps, both of which can be done from within Biopython.
Firstly, running BLAST for your query sequence(s), and getting some output.
Secondly, parsing the BLAST output in Python for further analysis.</P><P>Your first introduction to running BLAST was probably via the NCBI web-service.
In fact, there are lots of ways you can run BLAST, which can be categorised several ways.
The most important distinction is running BLAST locally (on your own machine),
and running BLAST remotely (on another machine, typically the NCBI servers).
We&#X2019;re going to start this chapter by invoking the NCBI online BLAST service
from within a Python script.</P><!--TOC section Running BLAST over the Internet-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc84">7.1</A>&#XA0;&#XA0;Running BLAST over the Internet</H2><!--SEC END --><P>
<A NAME="sec:running-www-blast"></A></P><P>We use the function <CODE>qblast()</CODE> in the <CODE>Bio.Blast.NCBIWWW</CODE> module
call the online version of BLAST. This has three non-optional arguments:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The first argument is the blast program to use for the search, as a
lower case string. The options and descriptions of the programs are
available at <A HREF="http://www.ncbi.nlm.nih.gov/BLAST/blast_program.shtml"><TT>http://www.ncbi.nlm.nih.gov/BLAST/blast_program.shtml</TT></A>.
Currently <CODE>qblast</CODE> only works with blastn, blastp, blastx, tblast
and tblastx.
</LI><LI CLASS="li-itemize">The second argument specifies the databases to search against. Again,
the options for this are available on the NCBI web pages at
<A HREF="http://www.ncbi.nlm.nih.gov/BLAST/blast_databases.shtml"><TT>http://www.ncbi.nlm.nih.gov/BLAST/blast_databases.shtml</TT></A>.
</LI><LI CLASS="li-itemize">The third argument is a string containing your query sequence. This
can either be the sequence itself, the sequence in fasta format,
or an identifier like a GI number.
</LI></UL><P>The <CODE>qblast</CODE> function also take a number of other option arguments
which are basically analogous to the different parameters you can set
on the BLAST web page. We&#X2019;ll just highlight a few of them here:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The <CODE>qblast</CODE> function can return the BLAST results in various
formats, which you can choose with the optional <CODE>format_type</CODE> keyword:
<CODE>"HTML"</CODE>, <CODE>"Text"</CODE>, <CODE>"ASN.1"</CODE>, or <CODE>"XML"</CODE>.
The default is <CODE>"XML"</CODE>, as that is the format expected by the parser,
described in section&#XA0;<A HREF="#sec:parsing-blast">7.3</A> below.
</LI><LI CLASS="li-itemize">The argument <CODE>expect</CODE> sets the expectation or e-value threshold.
</LI></UL><P>For more about the optional BLAST arguments, we refer you to the NCBI&#X2019;s own
documentation, or that built into Biopython:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; help(NCBIWWW.qblast)
...
</PRE><P>Note that the default settings on the NCBI BLAST website are not quite
the same as the defaults on QBLAST. If you get different results, you&#X2019;ll
need to check the parameters (e.g. the expectation value threshold and
the gap values).</P><P>For example, if you have a nucleotide sequence you want to search against
the nucleotide database (nt) using BLASTN, and you know the GI number of your
query sequence, you can use:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nt", "8332116")
</PRE><P>Alternatively, if we have our query sequence already in a FASTA formatted
file, we just need to open the file and read in this record as a string,
and use that as the query argument:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; fasta_string = open("m_cold.fasta").read()
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nt", fasta_string)
</PRE><P>We could also have read in the FASTA file as a <CODE>SeqRecord</CODE> and then
supplied just the sequence itself:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read(open("m_cold.fasta"), format="fasta")
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nt", record.seq)
</PRE><P>Supplying just the sequence means that BLAST will assign an identifier
for your sequence automatically. You might prefer to use the
<CODE>SeqRecord</CODE> object&#X2019;s format method to make a fasta string
(which will include the existing identifier):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read(open("m_cold.fasta"), format="fasta")
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nt", record.format("fasta"))
</PRE><P>This approach makes more sense if you have your sequence(s) in a
non-FASTA file format which you can extract using <CODE>Bio.SeqIO</CODE>
(see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>).</P><P>Whatever arguments you give the <CODE>qblast()</CODE> function, you should
get back your results in a handle object (by default in XML format).
The next step would be to parse the XML output into Python objects
representing the search results (Section&#XA0;<A HREF="#sec:parsing-blast">7.3</A>),
but you might want to save a local copy of the output file first.
I find this especially useful when debugging my code that extracts
info from the BLAST results (because re-running the online search
is slow and wastes the NCBI computer time).</P><P><A NAME="sec:saving-blast-output"></A></P><P>We need to be a bit careful since we can use <CODE>result_handle.read()</CODE> to
read the BLAST output only once &#X2013; calling <CODE>result_handle.read()</CODE> again
returns an empty string.</P><PRE CLASS="verbatim">&gt;&gt;&gt; save_file = open("my_blast.xml", "w")
&gt;&gt;&gt; save_file.write(result_handle.read())
&gt;&gt;&gt; save_file.close()
&gt;&gt;&gt; result_handle.close()
</PRE><P>After doing this, the results are in the file <CODE>my_blast.xml</CODE> and the
original handle has had all its data extracted (so we closed it). However,
the <CODE>parse</CODE> function of the BLAST parser (described
in&#XA0;<A HREF="#sec:parsing-blast">7.3</A>) takes a file-handle-like object, so
we can just open the saved file for input:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_blast.xml")
</PRE><P>Now that we&#X2019;ve got the BLAST results back into a handle again, we are ready
to do something with them, so this leads us right into the parsing section
(see Section&#XA0;<A HREF="#sec:parsing-blast">7.3</A> below). You may want to jump ahead to
that now &#X2026;.</P><!--TOC section Running BLAST locally-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc85">7.2</A>&#XA0;&#XA0;Running BLAST locally</H2><!--SEC END --><P>
<A NAME="sec:running-local-blast"></A></P><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc86">7.2.1</A>&#XA0;&#XA0;Introduction</H3><!--SEC END --><P>Running BLAST locally (as opposed to over the internet, see
Section&#XA0;<A HREF="#sec:running-www-blast">7.1</A>) has at least major two advantages:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Local BLAST may be faster than BLAST over the internet;
</LI><LI CLASS="li-itemize">Local BLAST allows you to make your own database to search for sequences against.
</LI></UL><P>
Dealing with proprietary or unpublished sequence data can be another reason to run BLAST
locally. You may not be allowed to redistribute the sequences, so submitting them to the
NCBI as a BLAST query would not be an option.</P><P>Unfortunately, there are some major drawbacks too &#X2013; installing all the bits and getting
it setup right takes some effort:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Local BLAST requires command line tools to be installed.
</LI><LI CLASS="li-itemize">Local BLAST requires (large) BLAST databases to be setup (and potentially kept up to date).
</LI></UL><P>To further confuse matters there are at least four different standalone BLAST packages,
and there are also other tools which can produce imitation BLAST output files, such as BLAT.</P><!--TOC subsection Standalone NCBI &#X201C;legacy&#X201D; BLAST-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc87">7.2.2</A>&#XA0;&#XA0;Standalone NCBI &#X201C;legacy&#X201D; BLAST</H3><!--SEC END --><P><A HREF="http://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web&PAGE_TYPE=BlastDocs&DOC_TYPE=Download">NCBI &#X201C;legacy&#X201D; BLAST</A> included command line tools <CODE>blastall</CODE>, <CODE>blastpgp</CODE> and
<CODE>rpsblast</CODE>. This was the most widely used standalone BLAST tool up until its replacement
BLAST+ was released by the NCBI.</P><P>The <CODE>Bio.Blast.Applications</CODE> module has wrappers for the &#X201C;legacy&#X201D; NCBI BLAST tools
like <CODE>blastall</CODE>, <CODE>blastpgp</CODE> and <CODE>rpsblast</CODE>, and there are also helper
functions in <CODE>Bio.Blast.NCBIStandalone</CODE>. These are now considered obsolete, and will
be deprecated and eventually removed from Biopython as people move over to the replacement
BLAST+ suite.</P><P>To try and avoid confusion, we will not cover calling these old tools from Biopython
in this tutorial. Have a look at the older edition of this tutorial included with
Biopython 1.52 if you are curious (look at the Tutorial PDF or HTML file in the Doc
directory within <TT>biopython-1.52.tar.gz</TT> or <TT>biopython-1.52.zip</TT>).</P><!--TOC subsection Standalone NCBI BLAST+-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">7.2.3</A>&#XA0;&#XA0;Standalone NCBI BLAST+</H3><!--SEC END --><P><A HREF="http://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web&PAGE_TYPE=BlastDocs&DOC_TYPE=Download">NCBI &#X201C;new&#X201D; BLAST+</A> was released in 2009. This replaces the old NCBI &#X201C;legacy&#X201D; BLAST
package. The <CODE>Bio.Blast.Applications</CODE> module has wrappers for these &#X201C;new&#X201D; tools
like <CODE>blastn</CODE>, <CODE>blastp</CODE>, <CODE>blastx</CODE>, <CODE>tblastn</CODE>, <CODE>tblastx</CODE>
(which all used to be handled by <CODE>blastall</CODE>), <CODE>psiblast</CODE>
(replacing <CODE>blastpgp</CODE>) and <CODE>rpsblast</CODE> and <CODE>rpstblastn</CODE>
(which replace the old <CODE>rpsblast</CODE>).
We don&#X2019;t include a wrapper for the <CODE>makeblastdb</CODE> used in BLAST+ to build a
local BLAST database from FASTA file, nor the equivalent tool <CODE>formatdb</CODE> in
&#X201C;legacy&#X201D; BLAST.</P><P>This section will show briefly how to use these tools from within Python. If you have
already read or tried the alignment tool examples in Section&#XA0;<A HREF="#sec:alignment-tools">6.4</A>
this should all seem quite straightforward. First, we construct a command line string
(as you would type in at the command line prompt if running standalone BLAST by hand).
Then we can execute this command from within Python.</P><P>For example, taking a FASTA file of gene nucleotide sequences, you might want to
run a BLASTX (translation) search against the non-redundant (NR) protein database.
Assuming you (or your systems administrator) has downloaded and installed the NR
database, you might run:</P><PRE CLASS="verbatim">blastx -query opuntia.fasta -db nr -out opuntia.xml -evalue 0.001 -outfmt 5
</PRE><P>This should run BLASTX against the NR database, using an expectation cut-off value
of 0.001 and produce XML output to the specified file (which we can then parse).
On my computer this takes about six minutes - a good reason to save the output
to a file so you and repeat any analysis as needed.</P><P>From within Biopython we can use the NCBI BLASTX wrapper from the
<CODE>Bio.Blast.Applications</CODE> module to build the command line string,
and run it:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast.Applications import NcbiblastxCommandline
&gt;&gt;&gt; help(NcbiblastxCommandline)
...
&gt;&gt;&gt; blastx_cline = NcbiblastxCommandline(query="opuntia.fasta", db="nr", evalue=0.001,
...                                      outfmt=5, out="opuntia.xml")
&gt;&gt;&gt; blastx_cline
NcbiblastxCommandline(cmd='blastx', out='opuntia.xml', outfmt=5, query='opuntia.fasta',
db='nr', evalue=0.001)
&gt;&gt;&gt; print blastx_cline
blastx -out opuntia.xml -outfmt 5 -query opuntia.fasta -db nr -evalue 0.001
&gt;&gt;&gt; stdout, stderr = blastx_cline()
</PRE><P>In this example there shouldn&#X2019;t be any output from BLASTX to the terminal,
so stdout and stderr should be empty. You may want to check the output file
<CODE>opuntia.xml</CODE> has been created.</P><P>As you may recall from earlier examples in the tutorial, the <CODE>opuntia.fasta</CODE>
contains seven sequences, so the BLAST XML output should contain multiple results.
Therefore use <CODE>Bio.Blast.NCBIXML.parse()</CODE> to parse it as described below in
Section&#XA0;<A HREF="#sec:parsing-blast">7.3</A>.</P><!--TOC subsection WU-BLAST and AB-BLAST-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">7.2.4</A>&#XA0;&#XA0;WU-BLAST and AB-BLAST</H3><!--SEC END --><P>You may also come across <A HREF="http://blast.wustl.edu/">Washington University BLAST</A>
(WU-BLAST), and its successor, <A HREF="http://blast.advbiocomp.com">Advanced Biocomputing
BLAST</A> (AB-BLAST, released in 2009, not free/open source). These packages include
the command line tools <CODE>wu-blastall</CODE> and <CODE>ab-blastall</CODE>.</P><P>Biopython does not currently provide wrappers for calling these tools, but should be able
to parse any NCBI compatible output from them.</P><!--TOC section Parsing BLAST output-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc90">7.3</A>&#XA0;&#XA0;Parsing BLAST output</H2><!--SEC END --><P>
<A NAME="sec:parsing-blast"></A></P><P>As mentioned above, BLAST can generate output in various formats, such as
XML, HTML, and plain text. Originally, Biopython had parsers for BLAST
plain text and HTML output, as these were the only output formats offered
at the time. Unfortunately, the BLAST output in these formats kept changing,
each time breaking the Biopython parsers. Our HTML BLAST parser has been
removed, but the plain text BLAST parser is still available (see
Section&#XA0;<A HREF="#sec:parsing-blast-deprecated">7.5</A>). Use it at your own risk,
it may or may not work, depending on which BLAST version you&#X2019;re using.</P><P>As keeping up with changes in BLAST
became a hopeless endeavor, especially with users running different BLAST
versions, we now recommend to parse the output in XML format, which can be
generated by recent versions of BLAST. Not only is the XML output more stable
than the plain text and HTML output, it is also much easier to parse
automatically, making Biopython a whole lot more stable.</P><P>You can get BLAST output in XML format in various ways. For the parser, it
doesn&#X2019;t matter how the output was generated, as long as it is in the XML format.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
You can use Biopython to run BLAST over the internet, as described in
section&#XA0;<A HREF="#sec:running-www-blast">7.1</A>.
</LI><LI CLASS="li-itemize">You can use Biopython to run BLAST locally, as described in
section&#XA0;<A HREF="#sec:running-local-blast">7.2</A>.
</LI><LI CLASS="li-itemize">You can do the BLAST search yourself on the NCBI site through your
web browser, and then save the results. You need to choose XML as the format
in which to receive the results, and save the final BLAST page you get
(you know, the one with all of the interesting results!) to a file.
</LI><LI CLASS="li-itemize">You can also run BLAST locally without using Biopython, and save
the output in a file. Again, you need to choose XML as the format in which
to receive the results.
</LI></UL><P>
The important point is that you do not have to use Biopython
scripts to fetch the data in order to be able to parse it.
Doing things in one of these ways, you then need to get a handle
to the results. In Python, a handle is just a nice general way of
describing input to any info source so that the info can be retrieved
using <CODE>read()</CODE> and <CODE>readline()</CODE> functions
(see Section&#XA0;sec:appendix-handles).</P><P>If you followed the code above for interacting with BLAST through a
script, then you already have <CODE>result_handle</CODE>, the handle to the
BLAST results. For example, using a GI number to do an online search:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nt", "8332116")
</PRE><P>If instead you ran BLAST some other way, and have the
BLAST output (in XML format) in the file <CODE>my_blast.xml</CODE>, all you
need to do is to open the file for reading:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_blast.xml")
</PRE><P>Now that we&#X2019;ve got a handle, we are ready to parse the output. The
code to parse it is really quite small. If you expect a single
BLAST result (i.e. you used a single query):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIXML
&gt;&gt;&gt; blast_record = NCBIXML.read(result_handle)
</PRE><P>or, if you have lots of results (i.e. multiple query sequences):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIXML
&gt;&gt;&gt; blast_records = NCBIXML.parse(result_handle)
</PRE><P>Just like <CODE>Bio.SeqIO</CODE> and <CODE>Bio.AlignIO</CODE>
(see Chapters&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A> and&#XA0;<A HREF="#chapter:Bio.AlignIO">6</A>),
we have a pair of input functions, <CODE>read</CODE> and <CODE>parse</CODE>, where
<CODE>read</CODE> is for when you have exactly one object, and <CODE>parse</CODE>
is an iterator for when you can have lots of objects &#X2013; but instead of
getting <CODE>SeqRecord</CODE> or <CODE>MultipleSeqAlignment</CODE> objects, we
get BLAST record objects.</P><P>To be able to handle the situation where the BLAST file may be huge,
containing thousands of results, <CODE>NCBIXML.parse()</CODE> returns an
iterator. In plain English, an iterator allows you to step through
the BLAST output, retrieving BLAST records one by one for each BLAST
search result:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIXML
&gt;&gt;&gt; blast_records = NCBIXML.parse(result_handle)
&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
# No further records
</PRE><P>Or, you can use a <CODE>for</CODE>-loop:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for blast_record in blast_records:
...     # Do something with blast_record
</PRE><P>Note though that you can step through the BLAST records only once.
Usually, from each BLAST record you would save the information that
you are interested in. If you want to save all returned BLAST records,
you can convert the iterator into a list:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_records = list(blast_records)
</PRE><P>Now you can access each BLAST record in the list with an index as usual.
If your BLAST file is huge though, you may run into memory problems trying to
save them all in a list.</P><P>Usually, you&#X2019;ll be running one BLAST search at a time. Then, all you need
to do is to pick up the first (and only) BLAST record in <CODE>blast_records</CODE>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIXML
&gt;&gt;&gt; blast_records = NCBIXML.parse(result_handle)
&gt;&gt;&gt; blast_record = blast_records.next()
</PRE><P>or more elegantly:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIXML
&gt;&gt;&gt; blast_record = NCBIXML.read(result_handle)
</PRE><P>I guess by now you&#X2019;re wondering what is in a BLAST record.</P><!--TOC section The BLAST record class-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">7.4</A>&#XA0;&#XA0;The BLAST record class</H2><!--SEC END --><P>A BLAST Record contains everything you might ever want to extract from the
BLAST output. Right now we&#X2019;ll just show
an example of how to get some info out of the BLAST report, but if you
want something in particular that is not described here, look at the
info on the record class in detail, and take a gander into the code or
automatically generated documentation &#X2013; the docstrings have lots of
good info about what is stored in each piece of information.</P><P>To continue with our example, let&#X2019;s just print out some summary info
about all hits in our blast report greater than a particular
threshold. The following code does this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; E_VALUE_THRESH = 0.04

&gt;&gt;&gt; for alignment in blast_record.alignments:
...     for hsp in alignment.hsps:
...         if hsp.expect &lt; E_VALUE_THRESH:
...             print '****Alignment****'
...             print 'sequence:', alignment.title
...             print 'length:', alignment.length
...             print 'e value:', hsp.expect
...             print hsp.query[0:75] + '...'
...             print hsp.match[0:75] + '...'
...             print hsp.sbjct[0:75] + '...'
</PRE><P>This will print out summary reports like the following:</P><PRE CLASS="verbatim">****Alignment****
sequence: &gt;gb|AF283004.1|AF283004 Arabidopsis thaliana cold acclimation protein WCOR413-like protein
alpha form mRNA, complete cds
length: 783
e value: 0.034
tacttgttgatattggatcgaacaaactggagaaccaacatgctcacgtcacttttagtcccttacatattcctc...
||||||||| | ||||||||||| || ||||  || || |||||||| |||||| |  | |||||||| ||| ||...
tacttgttggtgttggatcgaaccaattggaagacgaatatgctcacatcacttctcattccttacatcttcttc...
</PRE><P>Basically, you can do anything you want to with the info in the BLAST
report once you have parsed it. This will, of course, depend on what
you want to use it for, but hopefully this helps you get started on
doing what you need to do!</P><P>An important consideration for extracting information from a BLAST report is the type of objects that the information is stored in. In Biopython, the parsers return <CODE>Record</CODE> objects, either <CODE>Blast</CODE> or <CODE>PSIBlast</CODE> depending on what you are parsing. These objects are defined in <CODE>Bio.Blast.Record</CODE> and are quite complete.</P><P>Here are my attempts at UML class diagrams for the <CODE>Blast</CODE> and <CODE>PSIBlast</CODE> record classes. If you are good at UML and see mistakes/improvements that can be made, please let me know. The Blast class diagram is shown in Figure&#XA0;<A HREF="#fig:blastrecord">7.4</A>.</P><P>
<A NAME="fig:blastrecord"></A>
<IMG SRC="images/BlastRecord.png" width=650, height=750>
</P><P>The PSIBlast record object is similar, but has support for the rounds that are used in the iteration steps of PSIBlast. The class diagram for PSIBlast is shown in Figure&#XA0;<A HREF="#fig:psiblastrecord">7.4</A>.</P><P>
<A NAME="fig:psiblastrecord"></A>
<IMG SRC="images/PSIBlastRecord.png" width=650, height=750>
</P><!--TOC section Deprecated BLAST parsers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc92">7.5</A>&#XA0;&#XA0;Deprecated BLAST parsers</H2><!--SEC END --><P>
<A NAME="sec:parsing-blast-deprecated"></A></P><P>Older versions of Biopython had parsers for BLAST output in plain text or HTML
format. Over the years, we discovered that it is very hard to maintain these
parsers in working order. Basically, any small change to the BLAST output in
newly released BLAST versions tends to cause the plain text and HTML parsers
to break. We therefore recommend parsing BLAST output in XML format, as
described in section&#XA0;<A HREF="#sec:parsing-blast">7.3</A>.</P><P>Depending on which BLAST versions or programs you&#X2019;re using, our plain text BLAST parser may or may not work. Use it at your own risk!</P><!--TOC subsection Parsing plain-text BLAST output-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">7.5.1</A>&#XA0;&#XA0;Parsing plain-text BLAST output</H3><!--SEC END --><P>The plain text BLAST parser is located in <CODE>Bio.Blast.NCBIStandalone</CODE>.</P><P>As with the XML parser, we need to have a handle object that we can pass to the parser. The handle must implement the <CODE>readline()</CODE> method and do this properly. The common ways to get such a handle are to either use the provided <CODE>blastall</CODE> or <CODE>blastpgp</CODE> functions to run the local blast, or to run a local blast via the command line, and then do something like the following:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_file_of_blast_output.txt")
</PRE><P>Well, now that we&#X2019;ve got a handle (which we&#X2019;ll call <CODE>result_handle</CODE>),
we are ready to parse it. This can be done with the following code:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; blast_parser = NCBIStandalone.BlastParser()
&gt;&gt;&gt; blast_record = blast_parser.parse(result_handle)
</PRE><P>This will parse the BLAST report into a Blast Record class (either a Blast or a PSIBlast record, depending on what you are parsing) so that you can extract the information from it. In our case, let&#X2019;s just use print out a quick summary of all of the alignments greater than some threshold value.</P><PRE CLASS="verbatim">&gt;&gt;&gt; E_VALUE_THRESH = 0.04
&gt;&gt;&gt; for alignment in blast_record.alignments:
...     for hsp in alignment.hsps:
...         if hsp.expect &lt; E_VALUE_THRESH:
...             print '****Alignment****'
...             print 'sequence:', alignment.title
...             print 'length:', alignment.length
...             print 'e value:', hsp.expect
...             print hsp.query[0:75] + '...'
...             print hsp.match[0:75] + '...'
...             print hsp.sbjct[0:75] + '...'
</PRE><P>If you also read the section&#XA0;<A HREF="#sec:parsing-blast">7.3</A> on parsing BLAST XML output, you&#X2019;ll notice that the above code is identical to what is found in that section. Once you parse something into a record class you can deal with it independent of the format of the original BLAST info you were parsing. Pretty snazzy!</P><P>Sure, parsing one record is great, but I&#X2019;ve got a BLAST file with tons of records &#X2013; how can I parse them all? Well, fear not, the answer lies in the very next section.</P><!--TOC subsection Parsing a plain-text BLAST file full of BLAST runs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">7.5.2</A>&#XA0;&#XA0;Parsing a plain-text BLAST file full of BLAST runs</H3><!--SEC END --><P>We can do this using the blast iterator. To set up an iterator, we first set up a parser, to parse our blast reports in Blast Record objects:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; blast_parser = NCBIStandalone.BlastParser()
</PRE><P>Then we will assume we have a handle to a bunch of blast records, which we&#X2019;ll call <CODE>result_handle</CODE>. Getting a handle is described in full detail above in the blast parsing sections.</P><P>Now that we&#X2019;ve got a parser and a handle, we are ready to set up the iterator with the following command:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_iterator = NCBIStandalone.Iterator(result_handle, blast_parser)
</PRE><P>The second option, the parser, is optional. If we don&#X2019;t supply a parser, then the iterator will just return the raw BLAST reports one at a time.</P><P>Now that we&#X2019;ve got an iterator, we start retrieving blast records (generated by our parser) using <CODE>next()</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_record = blast_iterator.next()
</PRE><P>Each call to next will return a new record that we can deal with. Now we can iterate through this records and generate our old favorite, a nice little blast report:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for blast_record in blast_iterator:
...     E_VALUE_THRESH = 0.04
...     for alignment in blast_record.alignments:
...         for hsp in alignment.hsps:
...             if hsp.expect &lt; E_VALUE_THRESH:
...                 print '****Alignment****'
...                 print 'sequence:', alignment.title
...                 print 'length:', alignment.length
...                 print 'e value:', hsp.expect
...                 if len(hsp.query) &gt; 75:
...                     dots = '...'
...                 else:
...                     dots = ''
...                 print hsp.query[0:75] + dots
...                 print hsp.match[0:75] + dots
...                 print hsp.sbjct[0:75] + dots
</PRE><P>The iterator allows you to deal with huge blast records without any memory problems, since things are read in one at a time. I have parsed tremendously huge files without any problems using this.</P><!--TOC subsection Finding a bad record somewhere in a huge plain-text BLAST file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc95">7.5.3</A>&#XA0;&#XA0;Finding a bad record somewhere in a huge plain-text BLAST file</H3><!--SEC END --><P>One really ugly problem that happens to me is that I&#X2019;ll be parsing a huge blast file for a while, and the parser will bomb out with a ValueError. This is a serious problem, since you can&#X2019;t tell if the ValueError is due to a parser problem, or a problem with the BLAST. To make it even worse, you have no idea where the parse failed, so you can&#X2019;t just ignore the error, since this could be ignoring an important data point.</P><P>We used to have to make a little script to get around this problem, but the <CODE>Bio.Blast</CODE> module now includes a <CODE>BlastErrorParser</CODE> which really helps make this easier. The <CODE>BlastErrorParser</CODE> works very similar to the regular <CODE>BlastParser</CODE>, but it adds an extra layer of work by catching ValueErrors that are generated by the parser, and attempting to diagnose the errors.</P><P>Let&#X2019;s take a look at using this parser &#X2013; first we define the file we are going to parse and the file to write the problem reports to:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import os
&gt;&gt;&gt; blast_file = os.path.join(os.getcwd(), "blast_out", "big_blast.out")
&gt;&gt;&gt; error_file = os.path.join(os.getcwd(), "blast_out", "big_blast.problems")
</PRE><P>Now we want to get a <CODE>BlastErrorParser</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; error_handle = open(error_file, "w")
&gt;&gt;&gt; blast_error_parser = NCBIStandalone.BlastErrorParser(error_handle)
</PRE><P>Notice that the parser take an optional argument of a handle. If a handle is passed, then the parser will write any blast records which generate a ValueError to this handle. Otherwise, these records will not be recorded.</P><P>Now we can use the <CODE>BlastErrorParser</CODE> just like a regular blast parser. Specifically, we might want to make an iterator that goes through our blast records one at a time and parses them with the error parser:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open(blast_file)
&gt;&gt;&gt; iterator = NCBIStandalone.Iterator(result_handle, blast_error_parser)
</PRE><P>We can read these records one a time, but now we can catch and deal with errors that are due to problems with Blast (and not with the parser itself):</P><PRE CLASS="verbatim">&gt;&gt;&gt; try:
...     next_record = iterator.next()
... except NCBIStandalone.LowQualityBlastError, info:
...     print "LowQualityBlastError detected in id %s" % info[1]
</PRE><P>The <CODE>.next()</CODE> method is normally called indirectly via a <CODE>for</CODE>-loop.
Right now the <CODE>BlastErrorParser</CODE> can generate the following errors:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>ValueError</CODE> &#X2013; This is the same error generated by the regular BlastParser, and is due to the parser not being able to parse a specific file. This is normally either due to a bug in the parser, or some kind of discrepancy between the version of BLAST you are using and the versions the parser is able to handle.</LI><LI CLASS="li-itemize"><CODE>LowQualityBlastError</CODE> &#X2013; When BLASTing a sequence that is of really bad quality (for example, a short sequence that is basically a stretch of one nucleotide), it seems that Blast ends up masking out the entire sequence and ending up with nothing to parse. In this case it will produce a truncated report that causes the parser to generate a ValueError. <CODE>LowQualityBlastError</CODE> is reported in these cases. This error returns an info item with the following information:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>item[0]</CODE> &#X2013; The error message
</LI><LI CLASS="li-itemize"><CODE>item[1]</CODE> &#X2013; The id of the input record that caused the error. This is really useful if you want to record all of the records that are causing problems.
</LI></UL>
</LI></UL><P>As mentioned, with each error generated, the BlastErrorParser will write the offending record to the specified <CODE>error_handle</CODE>. You can then go ahead and look and these and deal with them as you see fit. Either you will be able to debug the parser with a single blast report, or will find out problems in your blast runs. Either way, it will definitely be a useful experience!</P><P>Hopefully the <CODE>BlastErrorParser</CODE> will make it much easier to debug and deal with large Blast files.</P><!--TOC section Dealing with PSI-BLAST-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc96">7.6</A>&#XA0;&#XA0;Dealing with PSI-BLAST</H2><!--SEC END --><P>You can run the standalone version of PSI-BLAST (the legacy NCBI command line
tool <CODE>blastpgp</CODE>, or its replacement <CODE>psiblast</CODE>) using the wrappers
in <CODE>Bio.Blast.Applications</CODE> module.</P><P>At the time of writing, the NCBI do not appear to support tools running a
PSI-BLAST search via the internet.</P><P>Note that the <CODE>Bio.Blast.NCBIXML</CODE> parser can read the XML output from
current versions of PSI-BLAST, but information like which sequences in each
iteration is new or reused isn&#X2019;t present in the XML file.
If you care about this information you may have more joy with the plain text
output and the <CODE>PSIBlastParser</CODE> in <CODE>Bio.Blast.NCBIStandalone</CODE>.</P><!--TOC section Dealing with RPS-BLAST-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc97">7.7</A>&#XA0;&#XA0;Dealing with RPS-BLAST</H2><!--SEC END --><P>You can run the standalone version of RPS-BLAST (either the legacy NCBI
command line tool <CODE>rpsblast</CODE>, or its replacement with the same name)
using the wrappers in <CODE>Bio.Blast.Applications</CODE> module.</P><P>At the time of writing, the NCBI do not appear to support tools running an
RPS-BLAST search via the internet.</P><P>You can use the <CODE>Bio.Blast.NCBIXML</CODE> parser to read the XML output from
current versions of RPS-BLAST.</P><!--TOC chapter Accessing NCBI&#X2019;s Entrez databases-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc98">Chapter&#XA0;8</A>&#XA0;&#XA0;Accessing NCBI&#X2019;s Entrez databases</H1><!--SEC END --><P>
<A NAME="chapter:entrez"></A></P><P>Entrez (<A HREF="http://www.ncbi.nlm.nih.gov/Entrez"><TT>http://www.ncbi.nlm.nih.gov/Entrez</TT></A>) is a data retrieval system that provides users access to NCBI&#X2019;s databases such as PubMed, GenBank, GEO, and many others. You can access Entrez from a web browser to manually enter queries, or you can use Biopython&#X2019;s <CODE>Bio.Entrez</CODE> module for programmatic access to Entrez. The latter allows you for example to search PubMed or download GenBank records from within a Python script.</P><P>The <CODE>Bio.Entrez</CODE> module makes use of the Entrez Programming Utilities (also known as EUtils), consisting of eight tools that are described in detail on NCBI&#X2019;s page at <A HREF="http://www.ncbi.nlm.nih.gov/entrez/utils/"><TT>http://www.ncbi.nlm.nih.gov/entrez/utils/</TT></A>.
Each of these tools corresponds to one Python function in the <CODE>Bio.Entrez</CODE> module, as described in the sections below. This module makes sure that the correct URL is used for the queries, and that not more than one request is made every three seconds, as required by NCBI.</P><P>The output returned by the Entrez Programming Utilities is typically in XML format. To parse such output, you have several options:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Use <CODE>Bio.Entrez</CODE>&#X2019;s parser to parse the XML output into a Python object;
</LI><LI CLASS="li-enumerate">Use the DOM (Document Object Model) parser in Python&#X2019;s standard library;
</LI><LI CLASS="li-enumerate">Use the SAX (Simple API for XML) parser in Python&#X2019;s standard library;
</LI><LI CLASS="li-enumerate">Read the XML output as raw text, and parse it by string searching and manipulation.
</LI></OL><P>
For the DOM and SAX parsers, see the Python documentation. The parser in <CODE>Bio.Entrez</CODE> is discussed below.</P><P>NCBI uses DTD (Document Type Definition) files to describe the structure of the information contained in XML files. Most of the DTD files used by NCBI are included in the Biopython distribution. The <CODE>Bio.Entrez</CODE> parser makes use of the DTD files when parsing an XML file returned by NCBI Entrez.</P><P>Occasionally, you may find that the DTD file associated with a specific XML file is missing in the Biopython distribution. In particular, this may happen when NCBI updates its DTD files. If this happens, <CODE>Entrez.read</CODE> will show a warning message with the name and URL of the missing DTD file. The parser will proceed to access the missing DTD file through the internet, allowing the parsing of the XML file to continue. However, the parser is much faster if the DTD file is available locally. For this purpose, please download the DTD file from the URL in the warning message and place it in the directory <CODE>...site-packages/Bio/Entrez/DTDs</CODE>, containing the other DTD files. If you don&#X2019;t have write access to this directory, you can also place the DTD file in <CODE>~/.biopython/Bio/Entrez/DTDs</CODE>, where <CODE>~</CODE> represents your home directory. Since this directory is read before the directory <CODE>...site-packages/Bio/Entrez/DTDs</CODE>, you can also put newer versions of DTD files there if the ones in <CODE>...site-packages/Bio/Entrez/DTDs</CODE> become outdated. Alternatively, if you installed Biopython from source, you can add the DTD file to the source code&#X2019;s <CODE>Bio/Entrez/DTDs</CODE> directory, and reinstall Biopython. This will install the new DTD file in the correct location together with the other DTD files.</P><P>The Entrez Programming Utilities can also generate output in other formats, such as the Fasta or GenBank file formats for sequence databases, or the MedLine format for the literature database, discussed in Section&#XA0;<A HREF="#sec:entrez-specialized-parsers">8.12</A>.</P><!--TOC section Entrez Guidelines-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc99">8.1</A>&#XA0;&#XA0;Entrez Guidelines</H2><!--SEC END --><P>
<A NAME="sec:entrez-guidelines"></A>
Before using Biopython to access the NCBI&#X2019;s online resources (via <CODE>Bio.Entrez</CODE> or some of the other modules), please read the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/eutils_help.html#UserSystemRequirements">NCBI&#X2019;s Entrez User Requirements</A>. If the NCBI finds you are abusing their systems, they can and will ban your access! </P><P>To paraphrase:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
For any series of more than 100 requests, do this at weekends or outside USA peak times. This is up to you to obey.
</LI><LI CLASS="li-itemize">Use the <A HREF="http://eutils.ncbi.nlm.nih.gov"><TT>http://eutils.ncbi.nlm.nih.gov</TT></A> address, not the standard NCBI Web address. Biopython uses this web address.
</LI><LI CLASS="li-itemize">Make no more than three requests every seconds (relaxed from at most one request every three seconds in early 2009). This is automatically enforced by Biopython.
</LI><LI CLASS="li-itemize">Use the optional email parameter so the NCBI can contact you if there is a problem. You can either explicitly set this as a parameter with each call to Entrez (e.g. include <TT>email="A.N.Other@example.com"</TT> in the argument list), or as of Biopython 1.48, you can set a global email address:
<PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"
</PRE><TT>Bio.Entrez</TT> will then use this email address with each call to Entrez. The <TT>example.com</TT> address is a reserved domain name specifically for documentation (RFC 2606). Please DO NOT use a random email &#X2013; it&#X2019;s better not to give an email at all. The email parameter will be mandatory from June 1, 2010. In case of excessive usage, NCBI will attempt to contact a user at the e-mail address provided prior to blocking access to the E-utilities.
</LI><LI CLASS="li-itemize">If you are using Biopython within some larger software suite, use the tool parameter to specify this. You can either explicitly set the tool name as a parameter with each call to Entrez (e.g. include <TT>tool="MyLocalScript"</TT> in the argument list), or as of Biopython 1.54, you can set a global tool name:
<PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.tool = "MyLocalScript"
</PRE>The tool parameter will default to Biopython.
</LI><LI CLASS="li-itemize">For large queries, the NCBI also recommend using their session history feature (the WebEnv session cookie string, see Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A>). This is only slightly more complicated.
</LI></UL><P>In conclusion, be sensible with your usage levels. If you plan to download lots of data, consider other options. For example, if you want easy access to all the human genes, consider fetching each chromosome by FTP as a GenBank file, and importing these into your own BioSQL database (see Section&#XA0;<A HREF="#sec:BioSQL">16.5</A>).</P><!--TOC section EInfo: Obtaining information about the Entrez databases-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc100">8.2</A>&#XA0;&#XA0;EInfo: Obtaining information about the Entrez databases</H2><!--SEC END --><P>
<A NAME="sec:entrez-einfo"></A>
EInfo provides field index term counts, last update, and available links for each of NCBI&#X2019;s databases. In addition, you can use EInfo to obtain a list of all database names accessible through the Entrez utilities:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.einfo()
&gt;&gt;&gt; result = handle.read()
</PRE><P>The variable <CODE>result</CODE> now contains a list of databases in XML format:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print result
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE eInfoResult PUBLIC "-//NLM//DTD eInfoResult, 11 May 2002//EN"
 "http://www.ncbi.nlm.nih.gov/entrez/query/DTD/eInfo_020511.dtd"&gt;
&lt;eInfoResult&gt;
&lt;DbList&gt;
        &lt;DbName&gt;pubmed&lt;/DbName&gt;
        &lt;DbName&gt;protein&lt;/DbName&gt;
        &lt;DbName&gt;nucleotide&lt;/DbName&gt;
        &lt;DbName&gt;nuccore&lt;/DbName&gt;
        &lt;DbName&gt;nucgss&lt;/DbName&gt;
        &lt;DbName&gt;nucest&lt;/DbName&gt;
        &lt;DbName&gt;structure&lt;/DbName&gt;
        &lt;DbName&gt;genome&lt;/DbName&gt;
        &lt;DbName&gt;books&lt;/DbName&gt;
        &lt;DbName&gt;cancerchromosomes&lt;/DbName&gt;
        &lt;DbName&gt;cdd&lt;/DbName&gt;
        &lt;DbName&gt;gap&lt;/DbName&gt;
        &lt;DbName&gt;domains&lt;/DbName&gt;
        &lt;DbName&gt;gene&lt;/DbName&gt;
        &lt;DbName&gt;genomeprj&lt;/DbName&gt;
        &lt;DbName&gt;gensat&lt;/DbName&gt;
        &lt;DbName&gt;geo&lt;/DbName&gt;
        &lt;DbName&gt;gds&lt;/DbName&gt;
        &lt;DbName&gt;homologene&lt;/DbName&gt;
        &lt;DbName&gt;journals&lt;/DbName&gt;
        &lt;DbName&gt;mesh&lt;/DbName&gt;
        &lt;DbName&gt;ncbisearch&lt;/DbName&gt;
        &lt;DbName&gt;nlmcatalog&lt;/DbName&gt;
        &lt;DbName&gt;omia&lt;/DbName&gt;
        &lt;DbName&gt;omim&lt;/DbName&gt;
        &lt;DbName&gt;pmc&lt;/DbName&gt;
        &lt;DbName&gt;popset&lt;/DbName&gt;
        &lt;DbName&gt;probe&lt;/DbName&gt;
        &lt;DbName&gt;proteinclusters&lt;/DbName&gt;
        &lt;DbName&gt;pcassay&lt;/DbName&gt;
        &lt;DbName&gt;pccompound&lt;/DbName&gt;
        &lt;DbName&gt;pcsubstance&lt;/DbName&gt;
        &lt;DbName&gt;snp&lt;/DbName&gt;
        &lt;DbName&gt;taxonomy&lt;/DbName&gt;
        &lt;DbName&gt;toolkit&lt;/DbName&gt;
        &lt;DbName&gt;unigene&lt;/DbName&gt;
        &lt;DbName&gt;unists&lt;/DbName&gt;
&lt;/DbList&gt;
&lt;/eInfoResult&gt;
</PRE><P>Since this is a fairly simple XML file, we could extract the information it contains simply by string searching. Using <CODE>Bio.Entrez</CODE>&#X2019;s parser instead, we can directly parse this XML file into a Python object:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.einfo()
&gt;&gt;&gt; record = Entrez.read(handle)
</PRE><P>Now <CODE>record</CODE> is a dictionary with exactly one key:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.keys()
[u'DbList']
</PRE><P>The values stored in this key is the list of database names shown in the XML above:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; record["DbList"]
['pubmed', 'protein', 'nucleotide', 'nuccore', 'nucgss', 'nucest',
 'structure', 'genome', 'books', 'cancerchromosomes', 'cdd', 'gap',
 'domains', 'gene', 'genomeprj', 'gensat', 'geo', 'gds', 'homologene',
 'journals', 'mesh', 'ncbisearch', 'nlmcatalog', 'omia', 'omim', 'pmc',
 'popset', 'probe', 'proteinclusters', 'pcassay', 'pccompound',
 'pcsubstance', 'snp', 'taxonomy', 'toolkit', 'unigene', 'unists']
</PRE><P>For each of these databases, we can use EInfo again to obtain more information:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.einfo(db="pubmed")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["DbInfo"]["Description"]
'PubMed bibliographic record'
&gt;&gt;&gt; record["DbInfo"]["Count"]
'17989604'
&gt;&gt;&gt; record["DbInfo"]["LastUpdate"]
'2008/05/24 06:45'
</PRE><P>Try <CODE>record["DbInfo"].keys()</CODE> for other information stored in this record.
One of the most useful is a list of possible search fields for use with ESearch:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for field in record["DbInfo"]["FieldList"]:
...     print "%(Name)s, %(FullName)s, %(Description)s" % field
ALL, All Fields, All terms from all searchable fields
UID, UID, Unique number assigned to publication
FILT, Filter, Limits the records
TITL, Title, Words in title of publication
WORD, Text Word, Free text associated with publication
MESH, MeSH Terms, Medical Subject Headings assigned to publication
MAJR, MeSH Major Topic, MeSH terms of major importance to publication
AUTH, Author, Author(s) of publication
JOUR, Journal, Journal abbreviation of publication
AFFL, Affiliation, Author's institutional affiliation and address
...
</PRE><P>That&#X2019;s a long list, but indirectly this tells you that for the PubMed
database, you can do things like <TT>Jones[AUTH]</TT> to search the
author field, or <TT>Sanger[AFFL]</TT> to restrict to authors at the
Sanger Centre. This can be very handy - especially if you are not so
familiar with a particular database.</P><!--TOC section ESearch: Searching the Entrez databases-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc101">8.3</A>&#XA0;&#XA0;ESearch: Searching the Entrez databases</H2><!--SEC END --><P>
<A NAME="sec:entrez-esearch"></A>
To search any of these databases, we use <CODE>Bio.Entrez.esearch()</CODE>. For example, let&#X2019;s search in PubMed for publications related to Biopython:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.esearch(db="pubmed", term="biopython")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["IdList"]
['19304878', '18606172', '16403221', '16377612', '14871861', '14630660', '12230038']
</PRE><P>In this output, you see seven PubMed IDs (including 19304878 which is the PMID for the Biopython application note), which can be retrieved by EFetch (see section <A HREF="#sec:efetch">8.6</A>).</P><P>You can also use ESearch to search GenBank. Here we&#X2019;ll do a quick
search for the <EM>matK</EM> gene in <EM>Cypripedioideae</EM> orchids
(see Section&#XA0;<A HREF="#sec:entrez-einfo">8.2</A> about EInfo for one way to
find out which fields you can search in each Entrez database):</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.esearch(db="nucleotide",term="Cypripedioideae[Orgn] AND matK[Gene]")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["Count"]
'25'
&gt;&gt;&gt; record["IdList"]
['126789333', '37222967', '37222966', '37222965', ..., '61585492']
</PRE><P>Each of the IDs (126789333, 37222967, 37222966, &#X2026;) is a GenBank identifier.
See section&#XA0;<A HREF="#sec:efetch">8.6</A> for information on how to actually download these GenBank records.</P><P>Note that instead of a species name like <TT>Cypripedioideae[Orgn]</TT>, you can restrict the search using an NCBI taxon identifier, here this would be <TT>txid158330[Orgn]</TT>. This isn&#X2019;t currently documented on the ESearch help page - the NCBI explained this in reply to an email query. You can often deduce the search term formatting by playing with the Entrez web interface. For example, including <TT>complete[prop]</TT> in a genome search restricts to just completed genomes.</P><P>As a final example, let&#X2019;s get a list of computational journal titles:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.esearch(db="journals", term="computational")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["Count"]
'16'
&gt;&gt;&gt; record["IdList"]
['30367', '33843', '33823', '32989', '33190', '33009', '31986',
 '34502', '8799', '22857', '32675', '20258', '33859', '32534',
 '32357', '32249']
</PRE><P>Again, we could use EFetch to obtain more information for each of these journal IDs.</P><P>ESearch has many useful options &#X2014; see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/esearch_help.html">ESearch help page</A> for more information.</P><!--TOC section EPost: Uploading a list of identifiers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc102">8.4</A>&#XA0;&#XA0;EPost: Uploading a list of identifiers</H2><!--SEC END --><P>
EPost uploads a list of UIs for use in subsequent search strategies; see the
<A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/epost_help.html">EPost help page</A> for more information. It is available from Biopython through
the <CODE>Bio.Entrez.epost()</CODE> function.</P><P>To give an example of when this is useful, suppose you have a long list of IDs
you want to download using EFetch (maybe sequences, maybe citations &#X2013;
anything). When you make a request with EFetch your list of IDs, the database
etc, are all turned into a long URL sent to the server. If your list of IDs is
long, this URL gets long, and long URLs can break (e.g. some proxies don&#X2019;t
cope well).</P><P>Instead, you can break this up into two steps, first uploading the list of IDs
using EPost (this uses an &#X201C;HTML post&#X201D; internally, rather than an &#X201C;HTML get&#X201D;,
getting round the long URL problem). With the history support, you can then
refer to this long list of IDs, and download the associated data with EFetch.</P><P>Let&#X2019;s look at a simple example to see how EPost works &#X2013; uploading some PubMed identifiers:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; id_list = ["19304878", "18606172", "16403221", "16377612", "14871861", "14630660"]
&gt;&gt;&gt; print Entrez.epost("pubmed", id=",".join(id_list)).read()
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE ePostResult PUBLIC "-//NLM//DTD ePostResult, 11 May 2002//EN"
 "http://www.ncbi.nlm.nih.gov/entrez/query/DTD/ePost_020511.dtd"&gt;
&lt;ePostResult&gt;
 &lt;QueryKey&gt;1&lt;/QueryKey&gt;
 &lt;WebEnv&gt;NCID_01_206841095_130.14.22.101_9001_1242061629&lt;/WebEnv&gt;
&lt;/ePostResult&gt;
</PRE><P>The returned XML includes two important strings, <CODE>QueryKey</CODE> and <CODE>WebEnv</CODE> which together define your history session.
You would extract these values for use with another Entrez call such as EFetch:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; id_list = ["19304878", "18606172", "16403221", "16377612", "14871861", "14630660"]
&gt;&gt;&gt; search_results = Entrez.read(Entrez.epost("pubmed", id=",".join(id_list)))
&gt;&gt;&gt; webenv = search_results["WebEnv"]
&gt;&gt;&gt; query_key = search_results["QueryKey"] 
</PRE><P>Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A> shows how to use the history feature.</P><!--TOC section ESummary: Retrieving summaries from primary IDs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc103">8.5</A>&#XA0;&#XA0;ESummary: Retrieving summaries from primary IDs</H2><!--SEC END --><P>
ESummary retrieves document summaries from a list of primary IDs (see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/esummary_help.html">ESummary help page</A> for more information). In Biopython, ESummary is available as <CODE>Bio.Entrez.esummary()</CODE>. Using the search result above, we can for example find out more about the journal with ID 30367:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.esummary(db="journals", id="30367")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record[0]["Id"]
'30367'
&gt;&gt;&gt; record[0]["Title"]
'Computational biology and chemistry'
&gt;&gt;&gt; record[0]["Publisher"]
'Pergamon,'
</PRE><!--TOC section EFetch: Downloading full records from Entrez-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc104">8.6</A>&#XA0;&#XA0;EFetch: Downloading full records from Entrez</H2><!--SEC END --><P>
<A NAME="sec:efetch"></A></P><P>EFetch is what you use when you want to retrieve a full record from Entrez.
This covers several possible databases, as described on the main <A HREF="http://eutils.ncbi.nlm.nih.gov/entrez/query/static/efetch_help.html">EFetch Help page</A>.</P><P>For most of their databases, the NCBI support several different file formats. Requesting a specific file format from Entrez using <CODE>Bio.Entrez.efetch()</CODE> requires specifying the <CODE>rettype</CODE> and/or <CODE>retmode</CODE> optional arguments. The different combinations are described for each database type on the pages linked to on <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/efetch_help.html">NCBI efetch webpage</A> (e.g. <A HREF="http://eutils.ncbi.nlm.nih.gov/corehtml/query/static/efetchlit_help.html">literature</A>, <A HREF="http://eutils.ncbi.nlm.nih.gov/corehtml/query/static/efetchseq_help.html">sequences</A> and <A HREF="http://eutils.ncbi.nlm.nih.gov/corehtml/query/static/efetchtax_help.html">taxonomy</A>).</P><P>One common usage is downloading sequences in the FASTA or GenBank/GenPept plain text formats (which can then be parsed with <CODE>Bio.SeqIO</CODE>, see Sections&#XA0;<A HREF="#sec:SeqIO_GenBank_Online">5.3.1</A> and&#XA0;<A HREF="#sec:efetch">8.6</A>). From the <EM>Cypripedioideae</EM> example above, we can download GenBank record 186972394 using <CODE>Bio.Entrez.efetch</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.efetch(db="nucleotide", id="186972394", rettype="gb", retmode="text")
&gt;&gt;&gt; print handle.read()
LOCUS       EU490707                1302 bp    DNA     linear   PLN 05-MAY-2008
DEFINITION  Selenipedium aequinoctiale maturase K (matK) gene, partial cds;
            chloroplast.
ACCESSION   EU490707
VERSION     EU490707.1  GI:186972394
KEYWORDS    .
SOURCE      chloroplast Selenipedium aequinoctiale
  ORGANISM  Selenipedium aequinoctiale
            Eukaryota; Viridiplantae; Streptophyta; Embryophyta; Tracheophyta;
            Spermatophyta; Magnoliophyta; Liliopsida; Asparagales; Orchidaceae;
            Cypripedioideae; Selenipedium.
REFERENCE   1  (bases 1 to 1302)
  AUTHORS   Neubig,K.M., Whitten,W.M., Carlsward,B.S., Blanco,M.A.,
            Endara,C.L., Williams,N.H. and Moore,M.J.
  TITLE     Phylogenetic utility of ycf1 in orchids
  JOURNAL   Unpublished
REFERENCE   2  (bases 1 to 1302)
  AUTHORS   Neubig,K.M., Whitten,W.M., Carlsward,B.S., Blanco,M.A.,
            Endara,C.L., Williams,N.H. and Moore,M.J.
  TITLE     Direct Submission
  JOURNAL   Submitted (14-FEB-2008) Department of Botany, University of
            Florida, 220 Bartram Hall, Gainesville, FL 32611-8526, USA
FEATURES             Location/Qualifiers
     source          1..1302
                     /organism="Selenipedium aequinoctiale"
                     /organelle="plastid:chloroplast"
                     /mol_type="genomic DNA"
                     /specimen_voucher="FLAS:Blanco 2475"
                     /db_xref="taxon:256374"
     gene            &lt;1..&gt;1302
                     /gene="matK"
     CDS             &lt;1..&gt;1302
                     /gene="matK"
                     /codon_start=1
                     /transl_table=11
                     /product="maturase K"
                     /protein_id="ACC99456.1"
                     /db_xref="GI:186972395"
                     /translation="IFYEPVEIFGYDNKSSLVLVKRLITRMYQQNFLISSVNDSNQKG
                     FWGHKHFFSSHFSSQMVSEGFGVILEIPFSSQLVSSLEEKKIPKYQNLRSIHSIFPFL
                     EDKFLHLNYVSDLLIPHPIHLEILVQILQCRIKDVPSLHLLRLLFHEYHNLNSLITSK
                     KFIYAFSKRKKRFLWLLYNSYVYECEYLFQFLRKQSSYLRSTSSGVFLERTHLYVKIE
                     HLLVVCCNSFQRILCFLKDPFMHYVRYQGKAILASKGTLILMKKWKFHLVNFWQSYFH
                     FWSQPYRIHIKQLSNYSFSFLGYFSSVLENHLVVRNQMLENSFIINLLTKKFDTIAPV
                     ISLIGSLSKAQFCTVLGHPISKPIWTDFSDSDILDRFCRICRNLCRYHSGSSKKQVLY
                     RIKYILRLSCARTLARKHKSTVRTFMRRLGSGLLEEFFMEEE"
ORIGIN      
        1 attttttacg aacctgtgga aatttttggt tatgacaata aatctagttt agtacttgtg
       61 aaacgtttaa ttactcgaat gtatcaacag aattttttga tttcttcggt taatgattct
      121 aaccaaaaag gattttgggg gcacaagcat tttttttctt ctcatttttc ttctcaaatg
      181 gtatcagaag gttttggagt cattctggaa attccattct cgtcgcaatt agtatcttct
      241 cttgaagaaa aaaaaatacc aaaatatcag aatttacgat ctattcattc aatatttccc
      301 tttttagaag acaaattttt acatttgaat tatgtgtcag atctactaat accccatccc
      361 atccatctgg aaatcttggt tcaaatcctt caatgccgga tcaaggatgt tccttctttg
      421 catttattgc gattgctttt ccacgaatat cataatttga atagtctcat tacttcaaag
      481 aaattcattt acgccttttc aaaaagaaag aaaagattcc tttggttact atataattct
      541 tatgtatatg aatgcgaata tctattccag tttcttcgta aacagtcttc ttatttacga
      601 tcaacatctt ctggagtctt tcttgagcga acacatttat atgtaaaaat agaacatctt
      661 ctagtagtgt gttgtaattc ttttcagagg atcctatgct ttctcaagga tcctttcatg
      721 cattatgttc gatatcaagg aaaagcaatt ctggcttcaa agggaactct tattctgatg
      781 aagaaatgga aatttcatct tgtgaatttt tggcaatctt attttcactt ttggtctcaa
      841 ccgtatagga ttcatataaa gcaattatcc aactattcct tctcttttct ggggtatttt
      901 tcaagtgtac tagaaaatca tttggtagta agaaatcaaa tgctagagaa ttcatttata
      961 ataaatcttc tgactaagaa attcgatacc atagccccag ttatttctct tattggatca
     1021 ttgtcgaaag ctcaattttg tactgtattg ggtcatccta ttagtaaacc gatctggacc
     1081 gatttctcgg attctgatat tcttgatcga ttttgccgga tatgtagaaa tctttgtcgt
     1141 tatcacagcg gatcctcaaa aaaacaggtt ttgtatcgta taaaatatat acttcgactt
     1201 tcgtgtgcta gaactttggc acggaaacat aaaagtacag tacgcacttt tatgcgaaga
     1261 ttaggttcgg gattattaga agaattcttt atggaagaag aa
//
</PRE><P>The arguments <CODE>rettype="gb"</CODE> and <CODE>retmode="text"</CODE> let us download this record in the GenBank format.</P><P>Note that until Easter 2009, the Entrez EFetch API let you use &#X201C;genbank&#X201D; as the
return type, however the NCBI now insist on using the official return types of
&#X201C;gb&#X201D; or &#X201C;gbwithparts&#X201D; (or &#X201C;gp&#X201D; for proteins) as described on online.
Also not that until Feb 2012, the Entrez EFetch API would default to returning
plain text files, but now defaults to XML.</P><P>Alternatively, you could for example use <CODE>rettype="fasta"</CODE> to get the Fasta-format; see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/efetchseq_help.html">EFetch Sequences Help page</A> for other options. Remember &#X2013; the available formats depend on which database you are downloading from - see the main <A HREF="http://eutils.ncbi.nlm.nih.gov/entrez/query/static/efetch_help.html">EFetch Help page</A>.</P><P>If you fetch the record in one of the formats accepted by <CODE>Bio.SeqIO</CODE> (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>), you could directly parse it into a <CODE>SeqRecord</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez, SeqIO
&gt;&gt;&gt; handle = Entrez.efetch(db="nucleotide", id="186972394",rettype="gb", retmode="text")
&gt;&gt;&gt; record = SeqIO.read(handle, "genbank")
&gt;&gt;&gt; handle.close()
&gt;&gt;&gt; print record
ID: EU490707.1
Name: EU490707
Description: Selenipedium aequinoctiale maturase K (matK) gene, partial cds; chloroplast.
Number of features: 3
...
Seq('ATTTTTTACGAACCTGTGGAAATTTTTGGTTATGACAATAAATCTAGTTTAGTA...GAA', IUPACAmbiguousDNA())</PRE><P>Note that a more typical use would be to save the sequence data to a local file, and <EM>then</EM> parse it with <CODE>Bio.SeqIO</CODE>. This can save you having to re-download the same file repeatedly while working on your script, and places less load on the NCBI&#X2019;s servers. For example:</P><PRE CLASS="verbatim">import os
from Bio import SeqIO
from Bio import Entrez
Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
filename = "gi_186972394.gbk"
if not os.path.isfile(filename):
    # Downloading...
    net_handle = Entrez.efetch(db="nucleotide",id="186972394",rettype="gb", retmode="text")
    out_handle = open(filename, "w")
    out_handle.write(net_handle.read())
    out_handle.close()
    net_handle.close()
    print "Saved"

print "Parsing..."
record = SeqIO.read(filename, "genbank")
print record
</PRE><P>To get the output in XML format, which you can parse using the <CODE>Bio.Entrez.read()</CODE> function, use <CODE>retmode="xml"</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.efetch(db="nucleotide", id="186972394", retmode="xml")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; handle.close()
&gt;&gt;&gt; record[0]["GBSeq_definition"] 
'Selenipedium aequinoctiale maturase K (matK) gene, partial cds; chloroplast'
&gt;&gt;&gt; record[0]["GBSeq_source"] 
'chloroplast Selenipedium aequinoctiale'
</PRE><P>So, that dealt with sequences. For examples of parsing file formats specific to the other databases (e.g. the <CODE>MEDLINE</CODE> format used in PubMed), see Section&#XA0;<A HREF="#sec:entrez-specialized-parsers">8.12</A>.</P><P>If you want to perform a search with <CODE>Bio.Entrez.esearch()</CODE>, and then download the records with <CODE>Bio.Entrez.efetch()</CODE>, you should use the WebEnv history feature &#X2013; see Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A>.</P><!--TOC section ELink: Searching for related items in NCBI Entrez-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc105">8.7</A>&#XA0;&#XA0;ELink: Searching for related items in NCBI Entrez</H2><!--SEC END --><P>
<A NAME="sec:elink"></A></P><P>ELink, available from Biopython as <CODE>Bio.Entrez.elink()</CODE>, can be used to find related items in the NCBI Entrez databases. For example, you can us this to find nucleotide entries for an entry in the gene database,
and other cool stuff.</P><P>Let&#X2019;s use ELink to find articles related to the Biopython application note published in <I>Bioinformatics</I> in 2009. The PubMed ID of this article is 19304878:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"
&gt;&gt;&gt; pmid = "19304878"
&gt;&gt;&gt; record = Entrez.read(Entrez.elink(dbfrom="pubmed", id=pmid))
</PRE><P>The <CODE>record</CODE> variable consists of a Python list, one for each database in which we searched. Since we specified only one PubMed ID to search for, <CODE>record</CODE> contains only one item. This item is a dictionary containing information about our search term, as well as all the related items that were found:</P><PRE CLASS="verbatim">&gt;&gt;&gt; record[0]["DbFrom"]
'pubmed'
&gt;&gt;&gt; record[0]["IdList"]
['19304878']
</PRE><P>The <CODE>"LinkSetDb"</CODE> key contains the search results, stored as a list consisting of one item for each target database. In our search results, we only find hits in the PubMed database (although sub-diveded into categories):</P><PRE CLASS="verbatim">&gt;&gt;&gt; len(record[0]["LinkSetDb"])
5
&gt;&gt;&gt; for linksetdb in record[0]["LinkSetDb"]:
...     print linksetdb["DbTo"], linksetdb["LinkName"], len(linksetdb["Link"])
... 
pubmed pubmed_pubmed 110
pubmed pubmed_pubmed_combined 6
pubmed pubmed_pubmed_five 6
pubmed pubmed_pubmed_reviews 5
pubmed pubmed_pubmed_reviews_five 5
</PRE><P>The actual search results are stored as under the <CODE>"Link"</CODE> key. In total, 110 items were found under
standard search.
Let&#X2019;s now at the first search result:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; record[0]["LinkSetDb"][0]["Link"][0]
{u'Id': '19304878'}
</PRE><P>This is the article we searched for, which doesn&#X2019;t help us much, so let&#X2019;s look at the second search result:</P><PRE CLASS="verbatim">&gt;&gt;&gt; record[0]["LinkSetDb"][0]["Link"][1]
{u'Id': '14630660'}
</PRE><P>This paper, with PubMed ID 14630660, is about the Biopython PDB parser.</P><P>We can use a loop to print out all PubMed IDs:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for link in record[0]["LinkSetDb"][0]["Link"] : print link["Id"]
19304878
14630660
18689808
17121776
16377612
12368254
......
</PRE><P>Now that was nice, but personally I am often more interested to find out if a paper has been cited.
Well, ELink can do that too &#X2013; at least for journals in Pubmed Central (see Section&#XA0;<A HREF="#sec:elink-citations">8.15.3</A>).</P><P>For help on ELink, see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/elink_help.html">ELink help page</A>.
There is an entire sub-page just for the <A HREF="http://eutils.ncbi.nlm.nih.gov/corehtml/query/static/entrezlinks.html">link names</A>, describing how different databases can be cross referenced.</P><!--TOC section EGQuery: Global Query - counts for search terms-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc106">8.8</A>&#XA0;&#XA0;EGQuery: Global Query - counts for search terms</H2><!--SEC END --><P>
EGQuery provides counts for a search term in each of the Entrez databases (i.e. a global query). This is particularly useful to find out how many items your search terms would find in each database without actually performing lots of separate searches with ESearch (see the example in <A HREF="#subsec:entrez_example_genbank">8.14.2</A> below).</P><P>In this example, we use <CODE>Bio.Entrez.egquery()</CODE> to obtain the counts for &#X201C;Biopython&#X201D;:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.egquery(term="biopython")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; for row in record["eGQueryResult"]: print row["DbName"], row["Count"]
...
pubmed 6
pmc 62
journals 0
...
</PRE><P>See the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/egquery_help.html">EGQuery help page</A> for more information.</P><!--TOC section ESpell: Obtaining spelling suggestions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc107">8.9</A>&#XA0;&#XA0;ESpell: Obtaining spelling suggestions</H2><!--SEC END --><P>
ESpell retrieves spelling suggestions. In this example, we use <CODE>Bio.Entrez.espell()</CODE> to obtain the correct spelling of Biopython:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.espell(term="biopythooon")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["Query"]
'biopythooon'
&gt;&gt;&gt; record["CorrectedQuery"]
'biopython'
</PRE><P>See the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/espell_help.html">ESpell help page</A> for more information.
The main use of this is for GUI tools to provide automatic suggestions for search terms.</P><!--TOC section Parsing huge Entrez XML files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc108">8.10</A>&#XA0;&#XA0;Parsing huge Entrez XML files</H2><!--SEC END --><P>The <CODE>Entrez.read</CODE> function reads the entire XML file returned by Entrez into a single Python object, which is kept in memory. To parse Entrez XML files too large to fit in memory, you can use the function <CODE>Entrez.parse</CODE>. This is a generator function that reads records in the XML file one by one. This function is only useful if the XML file reflects a Python list object (in other words, if <CODE>Entrez.read</CODE> on a computer with infinite memory resources would return a Python list).</P><P>For example, you can download the entire Entrez Gene database for a given organism as a file from NCBI&#X2019;s ftp site. These files can be very large. As an example, on September 4, 2009, the file <CODE>Homo_sapiens.ags.gz</CODE>, containing the Entrez Gene database for human, had a size of 116576 kB. This file, which is in the <CODE>ASN</CODE> format, can be converted into an XML file using NCBI&#X2019;s <CODE>gene2xml</CODE> program (see NCBI&#X2019;s ftp site for more information):</P><PRE CLASS="verbatim">gene2xml -b T -i Homo_sapiens.ags -o Homo_sapiens.xml
</PRE><P>The resulting XML file has a size of 6.1 GB. Attempting <CODE>Entrez.read</CODE> on this file will result in a <CODE>MemoryError</CODE> on many computers.</P><P>The XML file <CODE>Homo_sapiens.xml</CODE> consists of a list of Entrez gene records, each corresponding to one Entrez gene in human. <CODE>Entrez.parse</CODE> retrieves these gene records one by one. You can then print out or store the relevant information in each record by iterating over the records. For example, this script iterates over the Entrez gene records and prints out the gene numbers and names for all current genes:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = open("Homo_sapiens.xml")
&gt;&gt;&gt; records = Entrez.parse(handle)

&gt;&gt;&gt; for record in records:
...     status = record['Entrezgene_track-info']['Gene-track']['Gene-track_status']
...     if status.attributes['value']=='discontinued':
...         continue
...     geneid = record['Entrezgene_track-info']['Gene-track']['Gene-track_geneid']
...     genename = record['Entrezgene_gene']['Gene-ref']['Gene-ref_locus']
...     print geneid, genename
</PRE><P>This will print:
</P><PRE CLASS="verbatim">1 A1BG
2 A2M
3 A2MP
8 AA
9 NAT1
10 NAT2
11 AACP
12 SERPINA3
13 AADAC
14 AAMP
15 AANAT
16 AARS
17 AAVS1
...
</PRE><!--TOC section Handling errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc109">8.11</A>&#XA0;&#XA0;Handling errors</H2><!--SEC END --><P>Three things can go wrong when parsing an XML file:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The file may not be an XML file to begin with;
</LI><LI CLASS="li-itemize">The file may end prematurely or otherwise be corrupted;
</LI><LI CLASS="li-itemize">The file may be correct XML, but contain items that are not represented in the associated DTD.
</LI></UL><P>The first case occurs if, for example, you try to parse a Fasta file as if it were an XML file:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = open("NC_005816.fna") # a Fasta file
&gt;&gt;&gt; record = Entrez.read(handle)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/local/lib/python2.7/site-packages/Bio/Entrez/__init__.py", line 257, in read
    record = handler.read(handle)
  File "/usr/local/lib/python2.7/site-packages/Bio/Entrez/Parser.py", line 164, in read
    raise NotXMLError(e)
Bio.Entrez.Parser.NotXMLError: Failed to parse the XML data (syntax error: line 1, column 0). Please make sure that the input data are in XML format.
</PRE><P>Here, the parser didn&#X2019;t find the <CODE>&lt;?xml ...</CODE> tag with which an XML file is supposed to start, and therefore decides (correctly) that the file is not an XML file.</P><P>When your file is in the XML format but is corrupted (for example, by ending prematurely), the parser will raise a CorruptedXMLError.
Here is an example of an XML file that ends prematurely:
</P><PRE CLASS="verbatim">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE eInfoResult PUBLIC "-//NLM//DTD eInfoResult, 11 May 2002//EN" "http://www.ncbi.nlm.nih.gov/entrez/query/DTD/eInfo_020511.dtd"&gt;
&lt;eInfoResult&gt;
&lt;DbList&gt;
        &lt;DbName&gt;pubmed&lt;/DbName&gt;
        &lt;DbName&gt;protein&lt;/DbName&gt;
        &lt;DbName&gt;nucleotide&lt;/DbName&gt;
        &lt;DbName&gt;nuccore&lt;/DbName&gt;
        &lt;DbName&gt;nucgss&lt;/DbName&gt;
        &lt;DbName&gt;nucest&lt;/DbName&gt;
        &lt;DbName&gt;structure&lt;/DbName&gt;
        &lt;DbName&gt;genome&lt;/DbName&gt;
        &lt;DbName&gt;books&lt;/DbName&gt;
        &lt;DbName&gt;cancerchromosomes&lt;/DbName&gt;
        &lt;DbName&gt;cdd&lt;/DbName&gt;
</PRE><P>which will generate the following traceback:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; Entrez.read(handle)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/local/lib/python2.7/site-packages/Bio/Entrez/__init__.py", line 257, in read
    record = handler.read(handle)
  File "/usr/local/lib/python2.7/site-packages/Bio/Entrez/Parser.py", line 160, in read
    raise CorruptedXMLError(e)
Bio.Entrez.Parser.CorruptedXMLError: Failed to parse the XML data (no element found: line 16, column 0). Please make sure that the input data are not corrupted.

&gt;&gt;&gt;
</PRE><P>Note that the error message tells you at what point in the XML file the error was detected.</P><P>The third type of error occurs if the XML file contains tags that do not have a description in the corresponding DTD file. This is an example of such an XML file:</P><PRE CLASS="verbatim">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE eInfoResult PUBLIC "-//NLM//DTD eInfoResult, 11 May 2002//EN" "http://www.ncbi.nlm.nih.gov/entrez/query/DTD/eInfo_020511.dtd"&gt;
&lt;eInfoResult&gt;
        &lt;DbInfo&gt;
        &lt;DbName&gt;pubmed&lt;/DbName&gt;
        &lt;MenuName&gt;PubMed&lt;/MenuName&gt;
        &lt;Description&gt;PubMed bibliographic record&lt;/Description&gt;
        &lt;Count&gt;20161961&lt;/Count&gt;
        &lt;LastUpdate&gt;2010/09/10 04:52&lt;/LastUpdate&gt;
        &lt;FieldList&gt;
                &lt;Field&gt;
...
                &lt;/Field&gt;
        &lt;/FieldList&gt;
        &lt;DocsumList&gt;
                &lt;Docsum&gt;
                        &lt;DsName&gt;PubDate&lt;/DsName&gt;
                        &lt;DsType&gt;4&lt;/DsType&gt;
                        &lt;DsTypeName&gt;string&lt;/DsTypeName&gt;
                &lt;/Docsum&gt;
                &lt;Docsum&gt;
                        &lt;DsName&gt;EPubDate&lt;/DsName&gt;
...
        &lt;/DbInfo&gt;
&lt;/eInfoResult&gt;
</PRE><P>In this file, for some reason the tag <CODE>&lt;DocsumList&gt;</CODE> (and several others) are not listed in the DTD file <CODE>eInfo_020511.dtd</CODE>, which is specified on the second line as the DTD for this XML file. By default, the parser will stop and raise a ValidationError if it cannot find some tag in the DTD:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = open("einfo3.xml")
&gt;&gt;&gt; record = Entrez.read(handle)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/usr/local/lib/python2.7/site-packages/Bio/Entrez/__init__.py", line 257, in read
    record = handler.read(handle)
  File "/usr/local/lib/python2.7/site-packages/Bio/Entrez/Parser.py", line 154, in read
    self.parser.ParseFile(handle)
  File "/usr/local/lib/python2.7/site-packages/Bio/Entrez/Parser.py", line 246, in startElementHandler
    raise ValidationError(name)
Bio.Entrez.Parser.ValidationError: Failed to find tag 'DocsumList' in the DTD. To skip all tags that are not represented in the DTD, please call Bio.Entrez.read or Bio.Entrez.parse with validate=False.
</PRE><P>Optionally, you can instruct the parser to skip such tags instead of raising a ValidationError. This is done by calling <CODE>Entrez.read</CODE> or <CODE>Entrez.parse</CODE> with the argument <CODE>validate</CODE> equal to False:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = open("einfo3.xml")
&gt;&gt;&gt; record = Entrez.read(handle,validate=False)
&gt;&gt;&gt;
</PRE><P>Of course, the information contained in the XML tags that are not in the DTD are not present in the record returned by <CODE>Entrez.read</CODE>.</P><!--TOC section Specialized parsers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc110">8.12</A>&#XA0;&#XA0;Specialized parsers</H2><!--SEC END --><P>
<A NAME="sec:entrez-specialized-parsers"></A></P><P>The <CODE>Bio.Entrez.read()</CODE> function can parse most (if not all) XML output returned by Entrez. Entrez typically allows you to retrieve records in other formats, which may have some advantages compared to the XML format in terms of readability (or download size).</P><P>To request a specific file format from Entrez using <CODE>Bio.Entrez.efetch()</CODE> requires specifying the <CODE>rettype</CODE> and/or <CODE>retmode</CODE> optional arguments. The different combinations are described for each database type on the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/efetch_help.html">NCBI efetch webpage</A>.</P><P>One obvious case is you may prefer to download sequences in the FASTA or GenBank/GenPept plain text formats (which can then be parsed with <CODE>Bio.SeqIO</CODE>, see Sections&#XA0;<A HREF="#sec:SeqIO_GenBank_Online">5.3.1</A> and&#XA0;<A HREF="#sec:efetch">8.6</A>). For the literature databases, Biopython contains a parser for the <CODE>MEDLINE</CODE> format used in PubMed.</P><!--TOC subsection Parsing Medline records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc111">8.12.1</A>&#XA0;&#XA0;Parsing Medline records</H3><!--SEC END --><P>
<A NAME="subsec:entrez-and-medline"></A>
You can find the Medline parser in <CODE>Bio.Medline</CODE>. Suppose we want to parse the file <CODE>pubmed_result1.txt</CODE>, containing one Medline record. You can find this file in Biopython&#X2019;s <CODE>Tests\Medline</CODE> directory. The file looks like this:</P><PRE CLASS="verbatim">PMID- 12230038
OWN - NLM
STAT- MEDLINE
DA  - 20020916
DCOM- 20030606
LR  - 20041117
PUBM- Print
IS  - 1467-5463 (Print)
VI  - 3
IP  - 3
DP  - 2002 Sep
TI  - The Bio* toolkits--a brief overview.
PG  - 296-302
AB  - Bioinformatics research is often difficult to do with commercial software. The
      Open Source BioPerl, BioPython and Biojava projects provide toolkits with
...
</PRE><P>We first open the file and then parse it:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Medline
&gt;&gt;&gt; input = open("pubmed_result1.txt")
&gt;&gt;&gt; record = Medline.read(input)
</PRE><P>The <CODE>record</CODE> now contains the Medline record as a Python dictionary:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; record["PMID"]
'12230038'
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; record["AB"]
'Bioinformatics research is often difficult to do with commercial software.
The Open Source BioPerl, BioPython and Biojava projects provide toolkits with
multiple functionality that make it easier to create customised pipelines or
analysis. This review briefly compares the quirks of the underlying languages
and the functionality, documentation, utility and relative advantages of the
Bio counterparts, particularly from the point of view of the beginning
biologist programmer.'
</PRE><P>The key names used in a Medline record can be rather obscure; use
</P><PRE CLASS="verbatim">&gt;&gt;&gt; help(record)
</PRE><P>for a brief summary.</P><P>To parse a file containing multiple Medline records, you can use the <CODE>parse</CODE> function instead:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Medline
&gt;&gt;&gt; input = open("pubmed_result2.txt")
&gt;&gt;&gt; records = Medline.parse(input)
&gt;&gt;&gt; for record in records:
...     print record["TI"]
A high level interface to SCOP and ASTRAL implemented in python.
GenomeDiagram: a python package for the visualization of large-scale genomic data.
Open source clustering software.
PDB file parser and structure class implemented in Python.
</PRE><P>Instead of parsing Medline records stored in files, you can also parse Medline records downloaded by <CODE>Bio.Entrez.efetch</CODE>. For example, let&#X2019;s look at all Medline records in PubMed related to Biopython:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.esearch(db="pubmed",term="biopython")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["IdList"]
['19304878', '18606172', '16403221', '16377612', '14871861', '14630660', '12230038']
</PRE><P>We now use <CODE>Bio.Entrez.efetch</CODE> to download these Medline records:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; idlist = record["IdList"]
&gt;&gt;&gt; handle = Entrez.efetch(db="pubmed",id=idlist,rettype="medline",retmode="text")
</PRE><P>Here, we specify <CODE>rettype="medline", retmode="text"</CODE> to obtain the Medline records in plain-text Medline format. Now we use <CODE>Bio.Medline</CODE> to parse these records:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Medline
&gt;&gt;&gt; records = Medline.parse(handle)
&gt;&gt;&gt; for record in records:
...     print record["AU"]
['Cock PJ', 'Antao T', 'Chang JT', 'Chapman BA', 'Cox CJ', 'Dalke A', ..., 'de Hoon MJ']
['Munteanu CR', 'Gonzalez-Diaz H', 'Magalhaes AL']
['Casbon JA', 'Crooks GE', 'Saqi MA']
['Pritchard L', 'White JA', 'Birch PR', 'Toth IK']
['de Hoon MJ', 'Imoto S', 'Nolan J', 'Miyano S']
['Hamelryck T', 'Manderick B']
['Mangalam H']
</PRE><P>For comparison, here we show an example using the XML format:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; idlist = record["IdList"]
&gt;&gt;&gt; handle = Entrez.efetch(db="pubmed",id=idlist,rettype="medline",retmode="xml")
&gt;&gt;&gt; records = Entrez.read(handle)
&gt;&gt;&gt; for record in records:
...     print record["MedlineCitation"]["Article"]["ArticleTitle"]
Biopython: freely available Python tools for computational molecular biology and
 bioinformatics.
Enzymes/non-enzymes classification model complexity based on composition, sequence,
 3D and topological indices.
A high level interface to SCOP and ASTRAL implemented in python.
GenomeDiagram: a python package for the visualization of large-scale genomic data.
Open source clustering software.
PDB file parser and structure class implemented in Python.
The Bio* toolkits--a brief overview.
</PRE><P>Note that in both of these examples, for simplicity we have naively combined ESearch and EFetch.
In this situation, the NCBI would expect you to use their history feature,
as illustrated in Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A>.</P><!--TOC subsection Parsing GEO records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc112">8.12.2</A>&#XA0;&#XA0;Parsing GEO records</H3><!--SEC END --><P>GEO (<A HREF="http://www.ncbi.nlm.nih.gov/geo/">Gene Expression Omnibus</A>)
is a data repository of high-throughput gene expression and hybridization
array data. The <CODE>Bio.Geo</CODE> module can be used to parse GEO-formatted
data.</P><P>The following code fragment shows how to parse the example GEO file
<CODE>GSE16.txt</CODE> into a record and print the record:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Geo
&gt;&gt;&gt; handle = open("GSE16.txt")
&gt;&gt;&gt; records = Geo.parse(handle)
&gt;&gt;&gt; for record in records:
...     print record
</PRE><P>You can search the &#X201C;gds&#X201D; database (GEO datasets) with ESearch:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com" # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.esearch(db="gds",term="GSE16")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["Count"]
2
&gt;&gt;&gt; record["IdList"]
['200000016', '100000028']
</PRE><P>From the Entrez website, UID &#X201C;200000016&#X201D; is GDS16 while the other hit
&#X201C;100000028&#X201D; is for the associated platform, GPL28. Unfortunately, at the
time of writing the NCBI don&#X2019;t seem to support downloading GEO files using
Entrez (not as XML, nor in the <I>Simple Omnibus Format in Text</I> (SOFT)
format).</P><P>However, it is actually pretty straight forward to download the GEO files by FTP
from <A HREF="ftp://ftp.ncbi.nih.gov/pub/geo/"><TT>ftp://ftp.ncbi.nih.gov/pub/geo/</TT></A> instead. In this case you might want
<A HREF="ftp://ftp.ncbi.nih.gov/pub/geo/DATA/SOFT/by_series/GSE16/GSE16_family.soft.gz"><TT>ftp://ftp.ncbi.nih.gov/pub/geo/DATA/SOFT/by_series/GSE16/GSE16_family.soft.gz</TT></A>
(a compressed file, see the Python module gzip).</P><!--TOC subsection Parsing UniGene records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">8.12.3</A>&#XA0;&#XA0;Parsing UniGene records</H3><!--SEC END --><P>UniGene is an NCBI database of the transcriptome, with each UniGene record showing the set of transcripts that are associated with a particular gene in a specific organism. A typical UniGene record looks like this:</P><PRE CLASS="verbatim">ID          Hs.2
TITLE       N-acetyltransferase 2 (arylamine N-acetyltransferase)
GENE        NAT2
CYTOBAND    8p22
GENE_ID     10
LOCUSLINK   10
HOMOL       YES
EXPRESS      bone| connective tissue| intestine| liver| liver tumor| normal| soft tissue/muscle tissue tumor| adult
RESTR_EXPR   adult
CHROMOSOME  8
STS         ACC=PMC310725P3 UNISTS=272646
STS         ACC=WIAF-2120 UNISTS=44576
STS         ACC=G59899 UNISTS=137181
...
STS         ACC=GDB:187676 UNISTS=155563
PROTSIM     ORG=10090; PROTGI=6754794; PROTID=NP_035004.1; PCT=76.55; ALN=288
PROTSIM     ORG=9796; PROTGI=149742490; PROTID=XP_001487907.1; PCT=79.66; ALN=288
PROTSIM     ORG=9986; PROTGI=126722851; PROTID=NP_001075655.1; PCT=76.90; ALN=288
...
PROTSIM     ORG=9598; PROTGI=114619004; PROTID=XP_519631.2; PCT=98.28; ALN=288

SCOUNT      38
SEQUENCE    ACC=BC067218.1; NID=g45501306; PID=g45501307; SEQTYPE=mRNA
SEQUENCE    ACC=NM_000015.2; NID=g116295259; PID=g116295260; SEQTYPE=mRNA
SEQUENCE    ACC=D90042.1; NID=g219415; PID=g219416; SEQTYPE=mRNA
SEQUENCE    ACC=D90040.1; NID=g219411; PID=g219412; SEQTYPE=mRNA
SEQUENCE    ACC=BC015878.1; NID=g16198419; PID=g16198420; SEQTYPE=mRNA
SEQUENCE    ACC=CR407631.1; NID=g47115198; PID=g47115199; SEQTYPE=mRNA
SEQUENCE    ACC=BG569293.1; NID=g13576946; CLONE=IMAGE:4722596; END=5'; LID=6989; SEQTYPE=EST; TRACE=44157214
...
SEQUENCE    ACC=AU099534.1; NID=g13550663; CLONE=HSI08034; END=5'; LID=8800; SEQTYPE=EST
//
</PRE><P>This particular record shows the set of transcripts (shown in the <CODE>SEQUENCE</CODE> lines) that originate from the human gene NAT2, encoding en N-acetyltransferase. The <CODE>PROTSIM</CODE> lines show proteins with significant similarity to NAT2, whereas the <CODE>STS</CODE> lines show the corresponding sequence-tagged sites in the genome.</P><P>To parse UniGene files, use the <CODE>Bio.UniGene</CODE> module:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import UniGene
&gt;&gt;&gt; input = open("myunigenefile.data")
&gt;&gt;&gt; record = UniGene.read(input)
</PRE><P>The <CODE>record</CODE> returned by <CODE>UniGene.read</CODE> is a Python object with attributes corresponding to the fields in the UniGene record. For example,
</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.ID
"Hs.2"
&gt;&gt;&gt; record.title
"N-acetyltransferase 2 (arylamine N-acetyltransferase)"
</PRE><P>The <CODE>EXPRESS</CODE> and <CODE>RESTR_EXPR</CODE> lines are stored as Python lists of strings:
</P><PRE CLASS="verbatim">['bone', 'connective tissue', 'intestine', 'liver', 'liver tumor', 'normal', 'soft tissue/muscle tissue tumor', 'adult']
</PRE><P>Specialized objects are returned for the <CODE>STS</CODE>, <CODE>PROTSIM</CODE>, and <CODE>SEQUENCE</CODE> lines, storing the keys shown in each line as attributes:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.sts[0].acc
'PMC310725P3'
&gt;&gt;&gt; record.sts[0].unists
'272646'
</PRE><P>and similarly for the <CODE>PROTSIM</CODE> and <CODE>SEQUENCE</CODE> lines.</P><P>To parse a file containing more than one UniGene record, use the <CODE>parse</CODE> function in <CODE>Bio.UniGene</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import UniGene
&gt;&gt;&gt; input = open("unigenerecords.data")
&gt;&gt;&gt; records = UniGene.parse(input)
&gt;&gt;&gt; for record in records:
...     print record.ID
</PRE><!--TOC section Using a proxy-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc114">8.13</A>&#XA0;&#XA0;Using a proxy</H2><!--SEC END --><P>Normally you won&#X2019;t have to worry about using a proxy, but if this is an issue
on your network here is how to deal with it. Internally, <CODE>Bio.Entrez</CODE>
uses the standard Python library <CODE>urllib</CODE> for accessing the NCBI servers.
This will check an environment variable called <CODE>http_proxy</CODE> to configure
any simple proxy automatically. Unfortunately this module does not support
the use of proxies which require authentication.</P><P>You may choose to set the <CODE>http_proxy</CODE> environment variable once (how you
do this will depend on your operating system). Alternatively you can set this
within Python at the start of your script, for example:</P><PRE CLASS="verbatim">import os
os.environ["http_proxy"] = "http://proxyhost.example.com:8080"
</PRE><P>See the <A HREF="http://www.python.org/doc/lib/module-urllib.html">urllib documentation</A> for more details.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc115">8.14</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>
<A NAME="sec:entrez_examples"></A></P><!--TOC subsection PubMed and Medline-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc116">8.14.1</A>&#XA0;&#XA0;PubMed and Medline</H3><!--SEC END --><P>
<A NAME="subsec:pub_med"></A></P><P>If you are in the medical field or interested in human issues (and many times even if you are not!), PubMed (<A HREF="http://www.ncbi.nlm.nih.gov/PubMed/"><TT>http://www.ncbi.nlm.nih.gov/PubMed/</TT></A>) is an excellent source of all kinds of goodies. So like other things, we&#X2019;d like to be able to grab information from it and use it in Python scripts.</P><P>In this example, we will query PubMed for all articles having to do with orchids (see section&#XA0;<A HREF="#sec:orchids">2.3</A> for our motivation). We first check how many of such articles there are:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.egquery(term="orchid")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; for row in record["eGQueryResult"]:
...     if row["DbName"]=="pubmed":
...         print row["Count"]
463
</PRE><P>Now we use the <CODE>Bio.Entrez.efetch</CODE> function to download the PubMed IDs of these 463 articles:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.esearch(db="pubmed", term="orchid", retmax=463)
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; idlist = record["IdList"]
&gt;&gt;&gt; print idlist
</PRE><P>This returns a Python list containing all of the PubMed IDs of articles related to orchids:
</P><PRE CLASS="verbatim">['18680603', '18665331', '18661158', '18627489', '18627452', '18612381',
'18594007', '18591784', '18589523', '18579475', '18575811', '18575690',
...
</PRE><P>Now that we&#X2019;ve got them, we obviously want to get the corresponding Medline records and extract the information from them. Here, we&#X2019;ll download the Medline records in the Medline flat-file format, and use the <CODE>Bio.Medline</CODE> module to parse them:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Medline
&gt;&gt;&gt; handle = Entrez.efetch(db="pubmed", id=idlist, rettype="medline",
                           retmode="text")
&gt;&gt;&gt; records = Medline.parse(handle)
</PRE><P>NOTE - We&#X2019;ve just done a separate search and fetch here, the NCBI much prefer you to take advantage of their history support in this situation. See Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A>.</P><P>Keep in mind that <CODE>records</CODE> is an iterator, so you can iterate through the records only once. If you want to save the records, you can convert them to a list:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; records = list(records)
</PRE><P>Let&#X2019;s now iterate over the records to print out some information about each record:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for record in records:
...     print "title:", record.get("TI", "?")
...     print "authors:", record.get("AU", "?")
...     print "source:", record.get("SO", "?")
...     print
</PRE><P>The output for this looks like:
</P><PRE CLASS="verbatim">title: Sex pheromone mimicry in the early spider orchid (ophrys sphegodes):
patterns of hydrocarbons as the key mechanism for pollination by sexual
deception [In Process Citation]
authors: ['Schiestl FP', 'Ayasse M', 'Paulus HF', 'Lofstedt C', 'Hansson BS',
'Ibarra F', 'Francke W']
source: J Comp Physiol [A] 2000 Jun;186(6):567-74
</PRE><P>Especially interesting to note is the list of authors, which is returned as a standard Python list. This makes it easy to manipulate and search using standard Python tools. For instance, we could loop through a whole bunch of entries searching for a particular author with code like the following:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; search_author = "Waits T"

&gt;&gt;&gt; for record in records:
...     if not "AU" in record:
...         continue
...     if search_author in record["AU"]:
...         print "Author %s found: %s" % (search_author, record["SO"])
</PRE><P>Hopefully this section gave you an idea of the power and flexibility of the Entrez and Medline interfaces and how they can be used together.</P><!--TOC subsection Searching, downloading, and parsing Entrez Nucleotide records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc117">8.14.2</A>&#XA0;&#XA0;Searching, downloading, and parsing Entrez Nucleotide records</H3><!--SEC END --><P>
<A NAME="subsec:entrez_example_genbank"></A></P><P>Here we&#X2019;ll show a simple example of performing a remote Entrez query. In section&#XA0;<A HREF="#sec:orchids">2.3</A> of the parsing examples, we talked about using NCBI&#X2019;s Entrez website to search the NCBI nucleotide databases for info on Cypripedioideae, our friends the lady slipper orchids. Now, we&#X2019;ll look at how to automate that process using a Python script. In this example, we&#X2019;ll just show how to connect, get the results, and parse them, with the Entrez module doing all of the work.</P><P>First, we use EGQuery to find out the number of results we will get before actually downloading them. EGQuery will tell us how many search results were found in each of the databases, but for this example we are only interested in nucleotides:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.egquery(term="Cypripedioideae")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; for row in record["eGQueryResult"]:
...     if row["DbName"]=="nuccore":
...         print row["Count"]
814
</PRE><P>So, we expect to find 814 Entrez Nucleotide records (this is the number I obtained in 2008; it is likely to increase in the future). If you find some ridiculously high number of hits, you may want to reconsider if you really want to download all of them, which is our next step:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.esearch(db="nucleotide", term="Cypripedioideae", retmax=814)
&gt;&gt;&gt; record = Entrez.read(handle)
</PRE><P>Here, <CODE>record</CODE> is a Python dictionary containing the search results and some auxiliary information. Just for information, let&#X2019;s look at what is stored in this dictionary:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record.keys()
[u'Count', u'RetMax', u'IdList', u'TranslationSet', u'RetStart', u'QueryTranslation']
</PRE><P>First, let&#X2019;s check how many results were found:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record["Count"]
'814'
</PRE><P>which is the number we expected. The 814 results are stored in <CODE>record['IdList']</CODE>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print len(record["IdList"])
814
</PRE><P>Let&#X2019;s look at the first five results:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record["IdList"][:5]
['187237168', '187372713', '187372690', '187372688', '187372686']
</PRE><P><A NAME="sec:entrez-batched-efetch"></A>
We can download these records using <CODE>efetch</CODE>.
While you could download these records one by one, to reduce the load on NCBI&#X2019;s servers, it is better to fetch a bunch of records at the same time, shown below.
However, in this situation you should ideally be using the history feature described later in Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A>.</P><PRE CLASS="verbatim">&gt;&gt;&gt; idlist = ",".join(record["IdList"][:5])
&gt;&gt;&gt; print idlist
187237168,187372713,187372690,187372688,187372686
&gt;&gt;&gt; handle = Entrez.efetch(db="nucleotide", id=idlist, retmode="xml")
&gt;&gt;&gt; records = Entrez.read(handle)
&gt;&gt;&gt; print len(records)
5
</PRE><P>Each of these records corresponds to one GenBank record.
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print records[0].keys()
[u'GBSeq_moltype', u'GBSeq_source', u'GBSeq_sequence',
 u'GBSeq_primary-accession', u'GBSeq_definition', u'GBSeq_accession-version',
 u'GBSeq_topology', u'GBSeq_length', u'GBSeq_feature-table',
 u'GBSeq_create-date', u'GBSeq_other-seqids', u'GBSeq_division',
 u'GBSeq_taxonomy', u'GBSeq_references', u'GBSeq_update-date',
 u'GBSeq_organism', u'GBSeq_locus', u'GBSeq_strandedness']

&gt;&gt;&gt; print records[0]["GBSeq_primary-accession"]
DQ110336

&gt;&gt;&gt; print records[0]["GBSeq_other-seqids"]
['gb|DQ110336.1|', 'gi|187237168']

&gt;&gt;&gt; print records[0]["GBSeq_definition"]
Cypripedium calceolus voucher Davis 03-03 A maturase (matR) gene, partial cds;
mitochondrial

&gt;&gt;&gt; print records[0]["GBSeq_organism"]
Cypripedium calceolus
</PRE><P>You could use this to quickly set up searches &#X2013; but for heavy usage, see Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A>.</P><!--TOC subsection Searching, downloading, and parsing GenBank records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc118">8.14.3</A>&#XA0;&#XA0;Searching, downloading, and parsing GenBank records</H3><!--SEC END --><P>
<A NAME="sec:entrez-search-fetch-genbank"></A></P><P>The GenBank record format is a very popular method of holding information about sequences, sequence features, and other associated sequence information. The format is a good way to get information from the NCBI databases at <A HREF="http://www.ncbi.nlm.nih.gov/"><TT>http://www.ncbi.nlm.nih.gov/</TT></A>.</P><P>In this example we&#X2019;ll show how to query the NCBI databases,to retrieve the records from the query, and then parse them using <CODE>Bio.SeqIO</CODE> - something touched on in Section&#XA0;<A HREF="#sec:SeqIO_GenBank_Online">5.3.1</A>.
For simplicity, this example <EM>does not</EM> take advantage of the WebEnv history feature &#X2013; see Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A> for this.</P><P>First, we want to make a query and find out the ids of the records to retrieve. Here we&#X2019;ll do a quick search for one of our favorite organisms, <EM>Opuntia</EM> (prickly-pear cacti). We can do quick search and get back the GIs (GenBank identifiers) for all of the corresponding records. First we check how many records there are:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.egquery(term="Opuntia AND rpl16")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; for row in record["eGQueryResult"]:
...     if row["DbName"]=="nuccore":
...         print row["Count"]
...
9
</PRE><P>Now we download the list of GenBank identifiers:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.esearch(db="nuccore", term="Opuntia AND rpl16")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; gi_list = record["IdList"]
&gt;&gt;&gt; gi_list
['57240072', '57240071', '6273287', '6273291', '6273290', '6273289', '6273286',
'6273285', '6273284']
</PRE><P>Now we use these GIs to download the GenBank records - note that with older versions of Biopython you had to supply a comma separated list of GI numbers to Entrez, as of Biopython 1.59 you can pass a list and this is converted for you:</P><PRE CLASS="verbatim">&gt;&gt;&gt; gi_str = ",".join(gi_list)
&gt;&gt;&gt; handle = Entrez.efetch(db="nuccore", id=gi_str, rettype="gb", retmode="text")
</PRE><P>If you want to look at the raw GenBank files, you can read from this handle and print out the result:</P><PRE CLASS="verbatim">&gt;&gt;&gt; text = handle.read()
&gt;&gt;&gt; print text
LOCUS       AY851612                 892 bp    DNA     linear   PLN 10-APR-2007
DEFINITION  Opuntia subulata rpl16 gene, intron; chloroplast.
ACCESSION   AY851612
VERSION     AY851612.1  GI:57240072
KEYWORDS    .
SOURCE      chloroplast Austrocylindropuntia subulata
  ORGANISM  Austrocylindropuntia subulata
            Eukaryota; Viridiplantae; Streptophyta; Embryophyta; Tracheophyta;
            Spermatophyta; Magnoliophyta; eudicotyledons; core eudicotyledons;
            Caryophyllales; Cactaceae; Opuntioideae; Austrocylindropuntia.
REFERENCE   1  (bases 1 to 892)
  AUTHORS   Butterworth,C.A. and Wallace,R.S.
...
</PRE><P>In this case, we are just getting the raw records. To get the records in a more Python-friendly form, we can use <CODE>Bio.SeqIO</CODE> to parse the GenBank data into <CODE>SeqRecord</CODE> objects, including <CODE>SeqFeature</CODE> objects (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; handle = Entrez.efetch(db="nuccore", id=gi_str, rettype="gb", retmode="text")
&gt;&gt;&gt; records = SeqIO.parse(handle, "gb")
</PRE><P>We can now step through the records and look at the information we are interested in:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for record in records: 
&gt;&gt;&gt; ...    print "%s, length %i, with %i features" \
&gt;&gt;&gt; ...           % (record.name, len(record), len(record.features))
AY851612, length 892, with 3 features
AY851611, length 881, with 3 features
AF191661, length 895, with 3 features
AF191665, length 902, with 3 features
AF191664, length 899, with 3 features
AF191663, length 899, with 3 features
AF191660, length 893, with 3 features
AF191659, length 894, with 3 features
AF191658, length 896, with 3 features
</PRE><P>Using these automated query retrieval functionality is a big plus over doing things by hand. Although the module should obey the NCBI&#X2019;s max three queries per second rule, the NCBI have other recommendations like avoiding peak hours. See Section&#XA0;<A HREF="#sec:entrez-guidelines">8.1</A>.
In particular, please note that for simplicity, this example does not use the WebEnv history feature. You should use this for any non-trivial search and download work, see Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A>.</P><P>Finally, if plan to repeat your analysis, rather than downloading the files from the NCBI and parsing them immediately (as shown in this example), you should just download the records <EM>once</EM> and save them to your hard disk, and then parse the local file.</P><!--TOC subsection Finding the lineage of an organism-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc119">8.14.4</A>&#XA0;&#XA0;Finding the lineage of an organism</H3><!--SEC END --><P>Staying with a plant example, let&#X2019;s now find the lineage of the Cypripedioideae orchid family. First, we search the Taxonomy database for Cypripedioideae, which yields exactly one NCBI taxonomy identifier:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"     # Always tell NCBI who you are
&gt;&gt;&gt; handle = Entrez.esearch(db="Taxonomy", term="Cypripedioideae")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["IdList"]
['158330']
&gt;&gt;&gt; record["IdList"][0]
'158330'
</PRE><P>Now, we use <CODE>efetch</CODE> to download this entry in the Taxonomy database, and then parse it:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.efetch(db="Taxonomy", id="158330", retmode="xml")
&gt;&gt;&gt; records = Entrez.read(handle)
</PRE><P>Again, this record stores lots of information:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; records[0].keys()
[u'Lineage', u'Division', u'ParentTaxId', u'PubDate', u'LineageEx',
 u'CreateDate', u'TaxId', u'Rank', u'GeneticCode', u'ScientificName',
 u'MitoGeneticCode', u'UpdateDate']
</PRE><P>We can get the lineage directly from this record:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; records[0]["Lineage"]
'cellular organisms; Eukaryota; Viridiplantae; Streptophyta; Streptophytina;
 Embryophyta; Tracheophyta; Euphyllophyta; Spermatophyta; Magnoliophyta;
 Liliopsida; Asparagales; Orchidaceae'
</PRE><P>The record data contains much more than just the information shown here - for example look under <TT>"LineageEx"</TT> instead of <TT>"Lineage"</TT> and you&#X2019;ll get the NCBI taxon identifiers of the lineage entries too.</P><!--TOC section Using the history and WebEnv-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc120">8.15</A>&#XA0;&#XA0;Using the history and WebEnv</H2><!--SEC END --><P>
<A NAME="sec:entrez-webenv"></A></P><P>Often you will want to make a series of linked queries. Most typically,
running a search, perhaps refining the search, and then retrieving detailed
search results. You <EM>can</EM> do this by making a series of separate calls
to Entrez. However, the NCBI prefer you to take advantage of their history
support - for example combining ESearch and EFetch.</P><P>Another typical use of the history support would be to combine EPost and
EFetch. You use EPost to upload a list of identifiers, which starts a new
history session. You then download the records with EFetch by referring
to the session (instead of the identifiers).</P><!--TOC subsection Searching for and downloading sequences using the history-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc121">8.15.1</A>&#XA0;&#XA0;Searching for and downloading sequences using the history</H3><!--SEC END --><P>
Suppose we want to search and download all the <I>Opuntia</I> rpl16
nucleotide sequences, and store them in a FASTA file. As shown in
Section&#XA0;<A HREF="#sec:entrez-search-fetch-genbank">8.14.3</A>, we can naively combine
<CODE>Bio.Entrez.esearch()</CODE> to get a list of GI numbers, and then call
<CODE>Bio.Entrez.efetch()</CODE> to download them all.</P><P>However, the approved approach is to run the search with the history
feature. Then, we can fetch the results by reference to the search
results - which the NCBI can anticipate and cache.</P><P>To do this, call <CODE>Bio.Entrez.esearch()</CODE> as normal, but with the
additional argument of <CODE>usehistory="y"</CODE>,</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "history.user@example.com"
&gt;&gt;&gt; search_handle = Entrez.esearch(db="nucleotide",term="Opuntia[orgn] and rpl16",
                                   usehistory="y")
&gt;&gt;&gt; search_results = Entrez.read(search_handle)
&gt;&gt;&gt; search_handle.close()
</PRE><P>When you get the XML output back, it will still include the usual search results:</P><PRE CLASS="verbatim">&gt;&gt;&gt; gi_list = search_results["IdList"]
&gt;&gt;&gt; count = int(search_results["Count"])
&gt;&gt;&gt; assert count == len(gi_list)
</PRE><P>However, you also get given two additional pieces of information, the <TT>WebEnv</TT> session cookie, and the <TT>QueryKey</TT>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; webenv = search_results["WebEnv"]
&gt;&gt;&gt; query_key = search_results["QueryKey"] 
</PRE><P>Having stored these values in variables <TT>session_cookie</TT> and <TT>query_key</TT> we can use them as parameters to <CODE>Bio.Entrez.efetch()</CODE> instead of giving the GI numbers as identifiers. </P><P>While for small searches you might be OK downloading everything at once, it is better to download in batches. You use the <TT>retstart</TT> and <TT>retmax</TT> parameters to specify which range of search results you want returned (starting entry using zero-based counting, and maximum number of results to return). For example,</P><PRE CLASS="verbatim">batch_size = 3
out_handle = open("orchid_rpl16.fasta", "w")
for start in range(0,count,batch_size):
    end = min(count, start+batch_size)
    print "Going to download record %i to %i" % (start+1, end)
    fetch_handle = Entrez.efetch(db="nucleotide", rettype="fasta", retmode="text",
                                 retstart=start, retmax=batch_size,
                                 webenv=webenv, query_key=query_key)
    data = fetch_handle.read()
    fetch_handle.close()
    out_handle.write(data)
out_handle.close()
</PRE><P>For illustrative purposes, this example downloaded the FASTA records in batches of three. Unless you are downloading genomes or chromosomes, you would normally pick a larger batch size.</P><!--TOC subsection Searching for and downloading abstracts using the history-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc122">8.15.2</A>&#XA0;&#XA0;Searching for and downloading abstracts using the history</H3><!--SEC END --><P>
Here is another history example, searching for papers published in the last year about the <I>Opuntia</I>, and then downloading them into a file in MedLine format:</P><PRE CLASS="verbatim">from Bio import Entrez
Entrez.email = "history.user@example.com"
search_results = Entrez.read(Entrez.esearch(db="pubmed",
                                            term="Opuntia[ORGN]",
                                            reldate=365, datetype="pdat",
                                            usehistory="y"))
count = int(search_results["Count"])
print "Found %i results" % count

batch_size = 10
out_handle = open("recent_orchid_papers.txt", "w")
for start in range(0,count,batch_size):
    end = min(count, start+batch_size)
    print "Going to download record %i to %i" % (start+1, end)
    fetch_handle = Entrez.efetch(db="pubmed",
                                 rettype="medline", retmode="text",
                                 retstart=start, retmax=batch_size,
                                 webenv=search_results["WebEnv"],
                                 query_key=search_results["QueryKey"])
    data = fetch_handle.read()
    fetch_handle.close()
    out_handle.write(data)
out_handle.close()
</PRE><P>At the time of writing, this gave 28 matches - but because this is a date dependent search, this will of course vary. As described in Section&#XA0;<A HREF="#subsec:entrez-and-medline">8.12.1</A> above, you can then use <CODE>Bio.Medline</CODE> to parse the saved records.</P><!--TOC subsection Searching for citations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc123">8.15.3</A>&#XA0;&#XA0;Searching for citations</H3><!--SEC END --><P>
<A NAME="sec:elink-citations"></A></P><P>Back in Section&#XA0;<A HREF="#sec:elink">8.7</A> we mentioned ELink can be used to search for citations of a given paper.
Unfortunately this only covers journals indexed for PubMed Central
(doing it for all the journals in PubMed would mean a lot more work for the NIH).
Let&#X2019;s try this for the Biopython PDB parser paper, PubMed ID 14630660:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; Entrez.email = "A.N.Other@example.com"
&gt;&gt;&gt; pmid = "14630660"
&gt;&gt;&gt; results = Entrez.read(Entrez.elink(dbfrom="pubmed", db="pmc",
...                                    LinkName="pubmed_pmc_refs", from_uid=pmid))
&gt;&gt;&gt; pmc_ids = [link["Id"] for link in results[0]["LinkSetDb"][0]["Link"]]
&gt;&gt;&gt; pmc_ids
['2744707', '2705363', '2682512', ..., '1190160']
</PRE><P>Great - eleven articles. But why hasn&#X2019;t the Biopython application note been
found (PubMed ID 19304878)? Well, as you might have guessed from the variable
names, there are not actually PubMed IDs, but PubMed Central IDs. Our
application note is the third citing paper in that list, PMCID 2682512.</P><P>So, what if (like me) you&#X2019;d rather get back a list of PubMed IDs? Well we
can call ELink again to translate them. This becomes a two step process,
so by now you should expect to use the history feature to accomplish it
(Section&#XA0;<A HREF="#sec:entrez-webenv">8.15</A>).</P><P>But first, taking the more straightforward approach of making a second
(separate) call to ELink:</P><PRE CLASS="verbatim">&gt;&gt;&gt; results2 = Entrez.read(Entrez.elink(dbfrom="pmc", db="pubmed", LinkName="pmc_pubmed",
...                                     from_uid=",".join(pmc_ids)))
&gt;&gt;&gt; pubmed_ids = [link["Id"] for link in results2[0]["LinkSetDb"][0]["Link"]]
&gt;&gt;&gt; pubmed_ids
['19698094', '19450287', '19304878', ..., '15985178']
</PRE><P>This time you can immediately spot the Biopython application note
as the third hit (PubMed ID 19304878).</P><P>Now, let&#X2019;s do that all again but with the history &#X2026;<I>TODO</I>.</P><P>And finally, don&#X2019;t forget to include your <EM>own</EM> email address in the Entrez calls.</P><!--TOC chapter Swiss-Prot and ExPASy-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc124">Chapter&#XA0;9</A>&#XA0;&#XA0;Swiss-Prot and ExPASy</H1><!--SEC END --><P>
<A NAME="chapter:swiss_prot"></A></P><!--TOC section Parsing Swiss-Prot files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc125">9.1</A>&#XA0;&#XA0;Parsing Swiss-Prot files</H2><!--SEC END --><P>Swiss-Prot (<A HREF="http://www.expasy.org/sprot"><TT>http://www.expasy.org/sprot</TT></A>) is a hand-curated database of protein sequences. Biopython can parse the &#X201C;plain text&#X201D; Swiss-Prot file format, which is still used for the UniProt Knowledgebase which combined Swiss-Prot, TrEMBL and PIR-PSD. We do not (yet) support the UniProtKB XML file format.</P><!--TOC subsection Parsing Swiss-Prot records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc126">9.1.1</A>&#XA0;&#XA0;Parsing Swiss-Prot records</H3><!--SEC END --><P>In Section&#XA0;<A HREF="#sec:SeqIO_ExPASy_and_SwissProt">5.3.2</A>, we described how to extract the sequence of a Swiss-Prot record as a <CODE>SeqRecord</CODE> object. Alternatively, you can store the Swiss-Prot record in a <CODE>Bio.SwissProt.Record</CODE> object, which in fact stores the complete information contained in the Swiss-Prot record. In this Section, we describe how to extract <CODE>Bio.SwissProt.Record</CODE> objects from a Swiss-Prot file.</P><P>To parse a Swiss-Prot record, we first get a handle to a Swiss-Prot record. There are several ways to do so, depending on where and how the Swiss-Prot record is stored:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Open a Swiss-Prot file locally:<BR>
<CODE>&gt;&gt;&gt; handle = open("myswissprotfile.dat")</CODE>
</LI><LI CLASS="li-itemize">Open a gzipped Swiss-Prot file:
<PRE CLASS="verbatim">&gt;&gt;&gt; import gzip
&gt;&gt;&gt; handle = gzip.open("myswissprotfile.dat.gz")
</PRE></LI><LI CLASS="li-itemize">Open a Swiss-Prot file over the internet:
<PRE CLASS="verbatim">&gt;&gt;&gt; import urllib
&gt;&gt;&gt; handle = urllib.urlopen("http://www.somelocation.org/data/someswissprotfile.dat")
</PRE></LI><LI CLASS="li-itemize">Open a Swiss-Prot file over the internet from the ExPASy database
(see section <A HREF="#subsec:expasy_swissprot">9.5.1</A>):
<PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; handle = ExPASy.get_sprot_raw(myaccessionnumber)
</PRE></LI></UL><P>
The key point is that for the parser, it doesn&#X2019;t matter how the handle was created, as long as it points to data in the Swiss-Prot format.</P><P>We can use <CODE>Bio.SeqIO</CODE> as described in Section&#XA0;<A HREF="#sec:SeqIO_ExPASy_and_SwissProt">5.3.2</A> to get file format agnostic <CODE>SeqRecord</CODE> objects. Alternatively, we can use <CODE>Bio.SwissProt</CODE> get <CODE>Bio.SwissProt.Record</CODE> objects, which are a much closer match to the underlying file format.</P><P>To read one Swiss-Prot record from the handle, we use the function <CODE>read()</CODE>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SwissProt
&gt;&gt;&gt; record = SwissProt.read(handle)
</PRE><P>This function should be used if the handle points to exactly one Swiss-Prot record. It raises a <CODE>ValueError</CODE> if no Swiss-Prot record was found, and also if more than one record was found.</P><P>We can now print out some information about this record:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record.description
'RecName: Full=Chalcone synthase 3; EC=2.3.1.74; AltName: Full=Naringenin-chalcone synthase 3;'
&gt;&gt;&gt; for ref in record.references:
...     print "authors:", ref.authors
...     print "title:", ref.title
...
authors: Liew C.F., Lim S.H., Loh C.S., Goh C.J.;
title: "Molecular cloning and sequence analysis of chalcone synthase cDNAs of
Bromheadia finlaysoniana.";
&gt;&gt;&gt; print record.organism_classification
['Eukaryota', 'Viridiplantae', 'Streptophyta', 'Embryophyta', ..., 'Bromheadia']
</PRE><P>To parse a file that contains more than one Swiss-Prot record, we use the <CODE>parse</CODE> function instead. This function allows us to iterate over the records in the file.</P><P>For example, let&#X2019;s parse the full Swiss-Prot database and collect all the descriptions.
You can download this from the <A HREF="ftp://ftp.expasy.org/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.dat.gz">ExPAYs FTP site</A> as a single gzipped-file <CODE>uniprot_sprot.dat.gz</CODE> (about 300MB). This is a compressed file containing a single file, <CODE>uniprot_sprot.dat</CODE> (over 1.5GB).</P><P>As described at the start of this section, you can use the Python library <CODE>gzip</CODE> to open and uncompress a <TT>.gz</TT> file, like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import gzip
&gt;&gt;&gt; handle = gzip.open("uniprot_sprot.dat.gz")
</PRE><P>However, uncompressing a large file takes time, and each time you open the file for reading in this way, it has to be decompressed on the fly. So, if you can spare the disk space you&#X2019;ll save time in the long run if you first decompress the file to disk, to get the <CODE>uniprot_sprot.dat</CODE> file inside. Then you can open the file for reading as usual:</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = open("uniprot_sprot.dat")
</PRE><P>As of June 2009, the full Swiss-Prot database downloaded from ExPASy contained 468851 Swiss-Prot records. One concise way to build up a list of the record descriptions is with a list comprehension: 
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SwissProt
&gt;&gt;&gt; handle = open("uniprot_sprot.dat")
&gt;&gt;&gt; descriptions = [record.description for record in SwissProt.parse(handle)]
&gt;&gt;&gt; len(descriptions)
468851
&gt;&gt;&gt; descriptions[:5]
['RecName: Full=Protein MGF 100-1R;',
 'RecName: Full=Protein MGF 100-1R;',
 'RecName: Full=Protein MGF 100-1R;',
 'RecName: Full=Protein MGF 100-1R;',
 'RecName: Full=Protein MGF 100-2L;']

</PRE><P>Or, using a for loop over the record iterator:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SwissProt
&gt;&gt;&gt; descriptions = []
&gt;&gt;&gt; handle = open("uniprot_sprot.dat")
&gt;&gt;&gt; for record in SwissProt.parse(handle):
...     descriptions.append(record.description)
...
&gt;&gt;&gt; len(descriptions)
468851
</PRE><P>Because this is such a large input file, either way takes about eleven minutes on my new desktop computer (using the uncompressed <CODE>uniprot_sprot.dat</CODE> file as input).</P><P>It is equally easy to extract any kind of information you&#X2019;d like from Swiss-Prot records. To see the members of a Swiss-Prot record, use
</P><PRE CLASS="verbatim">&gt;&gt;&gt; dir(record)
['__doc__', '__init__', '__module__', 'accessions', 'annotation_update',
'comments', 'created', 'cross_references', 'data_class', 'description',
'entry_name', 'features', 'gene_name', 'host_organism', 'keywords',
'molecule_type', 'organelle', 'organism', 'organism_classification',
'references', 'seqinfo', 'sequence', 'sequence_length',
'sequence_update', 'taxonomy_id']
</PRE><!--TOC subsection Parsing the Swiss-Prot keyword and category list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc127">9.1.2</A>&#XA0;&#XA0;Parsing the Swiss-Prot keyword and category list</H3><!--SEC END --><P>Swiss-Prot also distributes a file <CODE>keywlist.txt</CODE>, which lists the keywords and categories used in Swiss-Prot. The file contains entries in the following form:</P><PRE CLASS="verbatim">ID   2Fe-2S.
AC   KW-0001
DE   Protein which contains at least one 2Fe-2S iron-sulfur cluster: 2 iron
DE   atoms complexed to 2 inorganic sulfides and 4 sulfur atoms of
DE   cysteines from the protein.
SY   Fe2S2; [2Fe-2S] cluster; [Fe2S2] cluster; Fe2/S2 (inorganic) cluster;
SY   Di-mu-sulfido-diiron; 2 iron, 2 sulfur cluster binding.
GO   GO:0051537; 2 iron, 2 sulfur cluster binding
HI   Ligand: Iron; Iron-sulfur; 2Fe-2S.
HI   Ligand: Metal-binding; 2Fe-2S.
CA   Ligand.
//
ID   3D-structure.
AC   KW-0002
DE   Protein, or part of a protein, whose three-dimensional structure has
DE   been resolved experimentally (for example by X-ray crystallography or
DE   NMR spectroscopy) and whose coordinates are available in the PDB
DE   database. Can also be used for theoretical models.
HI   Technical term: 3D-structure.
CA   Technical term.
//
ID   3Fe-4S.
...
</PRE><P>The entries in this file can be parsed by the <CODE>parse</CODE> function in the <CODE>Bio.SwissProt.KeyWList</CODE> module. Each entry is then stored as a <CODE>Bio.SwissProt.KeyWList.Record</CODE>, which is a Python dictionary.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.SwissProt import KeyWList
&gt;&gt;&gt; handle = open("keywlist.txt")
&gt;&gt;&gt; records = KeyWList.parse(handle)
&gt;&gt;&gt; for record in records:
...     print record['ID']
...     print record['DE']
</PRE><P>This prints
</P><PRE CLASS="verbatim">2Fe-2S.
Protein which contains at least one 2Fe-2S iron-sulfur cluster: 2 iron atoms
complexed to 2 inorganic sulfides and 4 sulfur atoms of cysteines from the
protein.
...
</PRE><!--TOC section Parsing Prosite records-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc128">9.2</A>&#XA0;&#XA0;Parsing Prosite records</H2><!--SEC END --><P>Prosite is a database containing protein domains, protein families, functional sites, as well as the patterns and profiles to recognize them. Prosite was developed in parallel with Swiss-Prot. In Biopython, a Prosite record is represented by the <CODE>Bio.ExPASy.Prosite.Record</CODE> class, whose members correspond to the different fields in a Prosite record.</P><P>In general, a Prosite file can contain more than one Prosite records. For example, the full set of Prosite records, which can be downloaded as a single file (<CODE>prosite.dat</CODE>) from the <A HREF="ftp://ftp.expasy.org/databases/prosite/prosite.dat">ExPASy FTP site</A>, contains 2073 records (version 20.24 released on 4 December 2007). To parse such a file, we again make use of an iterator:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.ExPASy import Prosite
&gt;&gt;&gt; handle = open("myprositefile.dat")
&gt;&gt;&gt; records = Prosite.parse(handle)
</PRE><P>We can now take the records one at a time and print out some information. For example, using the file containing the complete Prosite database, we&#X2019;d find
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.ExPASy import Prosite
&gt;&gt;&gt; handle = open("prosite.dat")
&gt;&gt;&gt; records = Prosite.parse(handle)
&gt;&gt;&gt; record = records.next()
&gt;&gt;&gt; record.accession
'PS00001'
&gt;&gt;&gt; record.name
'ASN_GLYCOSYLATION'
&gt;&gt;&gt; record.pdoc
'PDOC00001'
&gt;&gt;&gt; record = records.next()
&gt;&gt;&gt; record.accession
'PS00004'
&gt;&gt;&gt; record.name
'CAMP_PHOSPHO_SITE'
&gt;&gt;&gt; record.pdoc
'PDOC00004'
&gt;&gt;&gt; record = records.next()
&gt;&gt;&gt; record.accession
'PS00005'
&gt;&gt;&gt; record.name
'PKC_PHOSPHO_SITE'
&gt;&gt;&gt; record.pdoc
'PDOC00005'
</PRE><P>and so on. If you&#X2019;re interested in how many Prosite records there are, you could use
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.ExPASy import Prosite
&gt;&gt;&gt; handle = open("prosite.dat")
&gt;&gt;&gt; records = Prosite.parse(handle)
&gt;&gt;&gt; n = 0
&gt;&gt;&gt; for record in records: n+=1
...
&gt;&gt;&gt; print n
2073
</PRE><P>To read exactly one Prosite from the handle, you can use the <CODE>read</CODE> function:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.ExPASy import Prosite
&gt;&gt;&gt; handle = open("mysingleprositerecord.dat")
&gt;&gt;&gt; record = Prosite.read(handle)
</PRE><P>This function raises a ValueError if no Prosite record is found, and also if more than one Prosite record is found.</P><!--TOC section Parsing Prosite documentation records-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc129">9.3</A>&#XA0;&#XA0;Parsing Prosite documentation records</H2><!--SEC END --><P>In the Prosite example above, the <CODE>record.pdoc</CODE> accession numbers <CODE>'PDOC00001'</CODE>, <CODE>'PDOC00004'</CODE>, <CODE>'PDOC00005'</CODE> and so on refer to Prosite documentation. The Prosite documentation records are available from ExPASy as individual files, and as one file (<CODE>prosite.doc</CODE>) containing all Prosite documentation records.</P><P>We use the parser in <CODE>Bio.ExPASy.Prodoc</CODE> to parse Prosite documentation records. For example, to create a list of all accession numbers of Prosite documentation record, you can use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.ExPASy import Prodoc
&gt;&gt;&gt; handle = open("prosite.doc")
&gt;&gt;&gt; records = Prodoc.parse(handle)
&gt;&gt;&gt; accessions = [record.accession for record in records]
</PRE><P>Again a <CODE>read()</CODE> function is provided to read exactly one Prosite documentation record from the handle.</P><!--TOC section Parsing Enzyme records-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc130">9.4</A>&#XA0;&#XA0;Parsing Enzyme records</H2><!--SEC END --><P>ExPASy&#X2019;s Enzyme database is a repository of information on enzyme nomenclature. A typical Enzyme record looks as follows:</P><PRE CLASS="verbatim">ID   3.1.1.34
DE   Lipoprotein lipase.
AN   Clearing factor lipase.
AN   Diacylglycerol lipase.
AN   Diglyceride lipase.
CA   Triacylglycerol + H(2)O = diacylglycerol + a carboxylate.
CC   -!- Hydrolyzes triacylglycerols in chylomicrons and very low-density
CC       lipoproteins (VLDL).
CC   -!- Also hydrolyzes diacylglycerol.
PR   PROSITE; PDOC00110;
DR   P11151, LIPL_BOVIN ;  P11153, LIPL_CAVPO ;  P11602, LIPL_CHICK ;
DR   P55031, LIPL_FELCA ;  P06858, LIPL_HUMAN ;  P11152, LIPL_MOUSE ;
DR   O46647, LIPL_MUSVI ;  P49060, LIPL_PAPAN ;  P49923, LIPL_PIG   ;
DR   Q06000, LIPL_RAT   ;  Q29524, LIPL_SHEEP ;
//
</PRE><P>In this example, the first line shows the EC (Enzyme Commission) number of lipoprotein lipase (second line). Alternative names of lipoprotein lipase are "clearing factor lipase", "diacylglycerol lipase", and "diglyceride lipase" (lines 3 through 5). The line starting with "CA" shows the catalytic activity of this enzyme. Comment lines start with "CC". The "PR" line shows references to the Prosite Documentation records, and the "DR" lines show references to Swiss-Prot records. Not of these entries are necessarily present in an Enzyme record.</P><P>In Biopython, an Enzyme record is represented by the <CODE>Bio.ExPASy.Enzyme.Record</CODE> class. This record derives from a Python dictionary and has keys corresponding to the two-letter codes used in Enzyme files. To read an Enzyme file containing one Enzyme record, use the <CODE>read</CODE> function in <CODE>Bio.ExPASy.Enzyme</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.ExPASy import Enzyme
&gt;&gt;&gt; handle = open("lipoprotein.txt")
&gt;&gt;&gt; record = Enzyme.read(handle)
&gt;&gt;&gt; record["ID"]
'3.1.1.34'
&gt;&gt;&gt; record["DE"]
'Lipoprotein lipase.'
&gt;&gt;&gt; record["AN"]
['Clearing factor lipase.', 'Diacylglycerol lipase.', 'Diglyceride lipase.']
&gt;&gt;&gt; record["CA"]
'Triacylglycerol + H(2)O = diacylglycerol + a carboxylate.'
&gt;&gt;&gt; record["PR"]
['PDOC00110']
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; record["CC"]
['Hydrolyzes triacylglycerols in chylomicrons and very low-density lipoproteins
(VLDL).', 'Also hydrolyzes diacylglycerol.']
&gt;&gt;&gt; record["DR"]
[['P11151', 'LIPL_BOVIN'], ['P11153', 'LIPL_CAVPO'], ['P11602', 'LIPL_CHICK'],
['P55031', 'LIPL_FELCA'], ['P06858', 'LIPL_HUMAN'], ['P11152', 'LIPL_MOUSE'],
['O46647', 'LIPL_MUSVI'], ['P49060', 'LIPL_PAPAN'], ['P49923', 'LIPL_PIG'],
['Q06000', 'LIPL_RAT'], ['Q29524', 'LIPL_SHEEP']]
</PRE><P>The <CODE>read</CODE> function raises a ValueError if no Enzyme record is found, and also if more than one Enzyme record is found.</P><P>The full set of Enzyme records can be downloaded as a single file (<CODE>enzyme.dat</CODE>) from the <A HREF="ftp://ftp.expasy.org/databases/enzyme/enzyme.dat">ExPASy FTP site</A>, containing 4877 records (release of 3 March 2009). To parse such a file containing multiple Enzyme records, use the <CODE>parse</CODE> function in <CODE>Bio.ExPASy.Enzyme</CODE> to obtain an iterator:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.ExPASy import Enzyme
&gt;&gt;&gt; handle = open("enzyme.dat")
&gt;&gt;&gt; records = Enzyme.parse(handle)
</PRE><P>We can now iterate over the records one at a time. For example, we can make a list of all EC numbers for which an Enzyme record is available:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; ecnumbers = [record["ID"] for record in records]
</PRE><!--TOC section Accessing the ExPASy server-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc131">9.5</A>&#XA0;&#XA0;Accessing the ExPASy server</H2><!--SEC END --><P>Swiss-Prot, Prosite, and Prosite documentation records can be downloaded from the ExPASy web server at <A HREF="http://www.expasy.org"><TT>http://www.expasy.org</TT></A>. Six kinds of queries are available from ExPASy:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>get_prodoc_entry</B></DT><DD CLASS="dd-description">To download a Prosite documentation record in HTML format
</DD><DT CLASS="dt-description"><B>get_prosite_entry</B></DT><DD CLASS="dd-description">To download a Prosite record in HTML format
</DD><DT CLASS="dt-description"><B>get_prosite_raw</B></DT><DD CLASS="dd-description">To download a Prosite or Prosite documentation record in raw format
</DD><DT CLASS="dt-description"><B>get_sprot_raw</B></DT><DD CLASS="dd-description">To download a Swiss-Prot record in raw format
</DD><DT CLASS="dt-description"><B>sprot_search_ful</B></DT><DD CLASS="dd-description">To search for a Swiss-Prot record
</DD><DT CLASS="dt-description"><B>sprot_search_de</B></DT><DD CLASS="dd-description">To search for a Swiss-Prot record
</DD></DL><P>
To access this web server from a Python script, we use the <CODE>Bio.ExPASy</CODE> module.</P><!--TOC subsection Retrieving a Swiss-Prot record-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc132">9.5.1</A>&#XA0;&#XA0;Retrieving a Swiss-Prot record</H3><!--SEC END --><P>
<A NAME="subsec:expasy_swissprot"></A></P><P>Let&#X2019;s say we are looking at chalcone synthases for Orchids (see section&#XA0;<A HREF="#sec:orchids">2.3</A> for some justification for looking for interesting things about orchids). Chalcone synthase is involved in flavanoid biosynthesis in plants, and flavanoids make lots of cool things like pigment colors and UV protectants. </P><P>If you do a search on Swiss-Prot, you can find three orchid proteins for Chalcone Synthase, id numbers O23729, O23730, O23731. Now, let&#X2019;s write a script which grabs these, and parses out some interesting information.</P><P>First, we grab the records, using the <CODE>get_sprot_raw()</CODE> function of <CODE>Bio.ExPASy</CODE>. This function is very nice since you can feed it an id and get back a handle to a raw text record (no html to mess with!). We can the use <CODE>Bio.SwissProt.read</CODE> to pull out the Swiss-Prot record, or <CODE>Bio.SeqIO.read</CODE> to get a SeqRecord. The following code accomplishes what I just wrote:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; from Bio import SwissProt

&gt;&gt;&gt; accessions = ["O23729", "O23730", "O23731"]
&gt;&gt;&gt; records = []

&gt;&gt;&gt; for accession in accessions:
...     handle = ExPASy.get_sprot_raw(accession)
...     record = SwissProt.read(handle)
...     records.append(record)
</PRE><P>If the accession number you provided to <CODE>ExPASy.get_sprot_raw</CODE> does not exist, then <CODE>SwissProt.read(handle)</CODE> will raise a <CODE>ValueError</CODE>. You can catch <CODE>ValueException</CODE> exceptions to detect invalid accession numbers:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for accession in accessions:
...     handle = ExPASy.get_sprot_raw(accession)
...     try:
...         record = SwissProt.read(handle)
...     except ValueException:
...         print "WARNING: Accession %s not found" % accession
...     records.append(record)
</PRE><!--TOC subsection Searching Swiss-Prot-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc133">9.5.2</A>&#XA0;&#XA0;Searching Swiss-Prot</H3><!--SEC END --><P>Now, you may remark that I knew the records&#X2019; accession numbers
beforehand. Indeed, <CODE>get_sprot_raw()</CODE> needs either the entry name
or an accession number. When you don&#X2019;t have them handy, you can use
one of the <CODE>sprot_search_de()</CODE> or <CODE>sprot_search_ful()</CODE>
functions.</P><P><CODE>sprot_search_de()</CODE> searches in the ID, DE, GN, OS and OG lines;
<CODE>sprot_search_ful()</CODE> searches in (nearly) all the fields. They
are detailed on
<A HREF="http://www.expasy.org/cgi-bin/sprot-search-de"><TT>http://www.expasy.org/cgi-bin/sprot-search-de</TT></A> and
<A HREF="http://www.expasy.org/cgi-bin/sprot-search-ful"><TT>http://www.expasy.org/cgi-bin/sprot-search-ful</TT></A>
respectively. Note that they don&#X2019;t search in TrEMBL by default
(argument <CODE>trembl</CODE>). Note also that they return html pages;
however, accession numbers are quite easily extractable:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; import re

&gt;&gt;&gt; handle = ExPASy.sprot_search_de("Orchid Chalcone Synthase")
&gt;&gt;&gt; # or:
&gt;&gt;&gt; # handle = ExPASy.sprot_search_ful("Orchid and {Chalcone Synthase}")
&gt;&gt;&gt; html_results = handle.read()
&gt;&gt;&gt; if "Number of sequences found" in html_results:
...     ids = re.findall(r'HREF="/uniprot/(\w+)"', html_results)
... else:
...     ids = re.findall(r'href="/cgi-bin/niceprot\.pl\?(\w+)"', html_results)
</PRE><!--TOC subsection Retrieving Prosite and Prosite documentation records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc134">9.5.3</A>&#XA0;&#XA0;Retrieving Prosite and Prosite documentation records</H3><!--SEC END --><P>Prosite and Prosite documentation records can be retrieved either in HTML format, or in raw format. To parse Prosite and Prosite documentation records with Biopython, you should retrieve the records in raw format. For other purposes, however, you may be interested in these records in HTML format.</P><P>To retrieve a Prosite or Prosite documentation record in raw format, use <CODE>get_prosite_raw()</CODE>. For example, to download a Prosite record and print it out in raw text format, use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; handle = ExPASy.get_prosite_raw('PS00001')
&gt;&gt;&gt; text = handle.read()
&gt;&gt;&gt; print text
</PRE><P>To retrieve a Prosite record and parse it into a <CODE>Bio.Prosite.Record</CODE> object, use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; from Bio import Prosite
&gt;&gt;&gt; handle = ExPASy.get_prosite_raw('PS00001')
&gt;&gt;&gt; record = Prosite.read(handle)
</PRE><P>The same function can be used to retrieve a Prosite documentation record and parse it into a <CODE>Bio.ExPASy.Prodoc.Record</CODE> object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; from Bio.ExPASy import Prodoc
&gt;&gt;&gt; handle = ExPASy.get_prosite_raw('PDOC00001')
&gt;&gt;&gt; record = Prodoc.read(handle)
</PRE><P>For non-existing accession numbers, <CODE>ExPASy.get_prosite_raw</CODE> returns a handle to an emptry string. When faced with an empty string, <CODE>Prosite.read</CODE> and <CODE>Prodoc.read</CODE> will raise a ValueError. You can catch these exceptions to detect invalid accession numbers.</P><P>The functions <CODE>get_prosite_entry()</CODE> and <CODE>get_prodoc_entry()</CODE> are used to download Prosite and Prosite documentation records in HTML format. To create a web page showing one Prosite record, you can use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; handle = ExPASy.get_prosite_entry('PS00001')
&gt;&gt;&gt; html = handle.read()
&gt;&gt;&gt; output = open("myprositerecord.html", "w")
&gt;&gt;&gt; output.write(html)
&gt;&gt;&gt; output.close()
</PRE><P>and similarly for a Prosite documentation record:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; handle = ExPASy.get_prodoc_entry('PDOC00001')
&gt;&gt;&gt; html = handle.read()
&gt;&gt;&gt; output = open("myprodocrecord.html", "w")
&gt;&gt;&gt; output.write(html)
&gt;&gt;&gt; output.close()
</PRE><P>For these functions, an invalid accession number returns an error message in HTML format.</P><!--TOC section Scanning the Prosite database-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc135">9.6</A>&#XA0;&#XA0;Scanning the Prosite database</H2><!--SEC END --><P><A HREF="http://www.expasy.org/tools/scanprosite/">ScanProsite</A> allows you to scan protein sequences online against the Prosite database by providing a UniProt or PDB sequence identifier or the sequence itself. For more information about ScanProsite, please see the <A HREF="http://www.expasy.org/tools/scanprosite/scanprosite-doc.html">ScanProsite documentation</A> as well as the <A HREF="http://www.expasy.org/tools/scanprosite/ScanPrositeREST.html">documentation for programmatic access of ScanProsite</A>.</P><P>You can use Biopython&#X2019;s <CODE>Bio.ExPASy.ScanProsite</CODE> module to scan the Prosite database from Python. This module both helps you to access ScanProsite programmatically, and to parse the results returned by ScanProsite. To scan for Prosite patterns in the following protein sequence:</P><PRE CLASS="verbatim">MEHKEVVLLLLLFLKSGQGEPLDDYVNTQGASLFSVTKKQLGAGSIEECAAKCEEDEEFT
CRAFQYHSKEQQCVIMAENRKSSIIIRMRDVVLFEKKVYLSECKTGNGKNYRGTMSKTKN
</PRE><P>you can use the following code:</P><PRE CLASS="verbatim">&gt;&gt;&gt; sequence = "MEHKEVVLLLLLFLKSGQGEPLDDYVNTQGASLFSVTKKQLGAGSIEECAAKCEEDEEFT
CRAFQYHSKEQQCVIMAENRKSSIIIRMRDVVLFEKKVYLSECKTGNGKNYRGTMSKTKN"
&gt;&gt;&gt; from Bio.ExPASy import ScanProsite
&gt;&gt;&gt; handle = ScanProsite.scan(seq=sequence)
</PRE><P>By executing <CODE>handle.read()</CODE>, you can obtain the search results in raw XML format. Instead, let&#X2019;s use <CODE>Bio.ExPASy.ScanProsite.read</CODE> to parse the raw XML into a Python object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result = ScanProsite.read(handle)
&gt;&gt;&gt; type(result)
&lt;class 'Bio.ExPASy.ScanProsite.Record'&gt;
</PRE><P>A <CODE>Bio.ExPASy.ScanProsite.Record</CODE> object is derived from a list, with each element in the list storing one ScanProsite hit. This object also stores the number of hits, as well as the number of search sequences, as returned by ScanProsite. This ScanProsite search resulted in six hits:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result.n_seq
1
&gt;&gt;&gt; result.n_match
6
&gt;&gt;&gt; len(result)
6
&gt;&gt;&gt; result[0]
{'signature_ac': u'PS50948', 'level': u'0', 'stop': 98, 'sequence_ac': u'USERSEQ1', 'start': 16, 'score': u'8.873'}
&gt;&gt;&gt; result[1]
{'start': 37, 'stop': 39, 'sequence_ac': u'USERSEQ1', 'signature_ac': u'PS00005'}
&gt;&gt;&gt; result[2]
{'start': 45, 'stop': 48, 'sequence_ac': u'USERSEQ1', 'signature_ac': u'PS00006'}
&gt;&gt;&gt; result[3]
{'start': 60, 'stop': 62, 'sequence_ac': u'USERSEQ1', 'signature_ac': u'PS00005'}
&gt;&gt;&gt; result[4]
{'start': 80, 'stop': 83, 'sequence_ac': u'USERSEQ1', 'signature_ac': u'PS00004'}
&gt;&gt;&gt; result[5]
{'start': 106, 'stop': 111, 'sequence_ac': u'USERSEQ1', 'signature_ac': u'PS00008'}
</PRE><P>Other ScanProsite parameters can be passed as keyword arguments; see the <A HREF="http://www.expasy.org/tools/scanprosite/ScanPrositeREST.html">documentation for programmatic access of ScanProsite</A> for more information. As an example, passing <CODE>lowscore=1</CODE> to include matches with low level scores lets use find one additional hit:</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = ScanProsite.scan(seq=sequence, lowscore=1)
&gt;&gt;&gt; result = ScanProsite.read(handle)
&gt;&gt;&gt; result.n_match
7
</PRE><!--TOC chapter Going 3D: The PDB module-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc136">Chapter&#XA0;10</A>&#XA0;&#XA0;Going 3D: The PDB module</H1><!--SEC END --><P>Biopython also allows you to explore the extensive realm of macromolecular structure.
Biopython comes with a PDBParser class that produces a Structure object. The Structure object
can be used to access the atomic data in the file in a convenient manner.</P><!--TOC section Structure representation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc137">10.1</A>&#XA0;&#XA0;Structure representation</H2><!--SEC END --><P>A macromolecular structure is represented using a structure, model chain,
residue, atom (or SMCRA) hierarchy.

The figure below


shows a UML
class diagram of the SMCRA data structure. Such a data structure is not
necessarily best suited for the representation of the macromolecular content of
a structure, but it is absolutely necessary for a good interpretation of the
data present in a file that describes the structure (typically a PDB or MMCIF
file). If this hierarchy cannot represent the contents of a structure file, it
is fairly certain that the file contains an error or at least does not describe
the structure unambiguously. If a SMCRA data structure cannot be generated,
there is reason to suspect a problem. Parsing a PDB file can thus be used to
detect likely problems. We will give several examples of this in section
<A HREF="#problem structures">10.5.1</A>.</P><P>
<IMG SRC="images/smcra.png" width=650, height=750>
<A NAME="fig:smcra"></A>
</P><P>Structure, Model, Chain and Residue are all subclasses of the Entity base class.
The Atom class only (partly) implements the Entity interface (because an Atom
does not have children).</P><P>For each Entity subclass, you can extract a child by using a unique id for that
child as a key (e.g. you can extract an Atom object from a Residue object by
using an atom name string as a key, you can extract a Chain object from a Model
object by using its chain identifier as a key).</P><P>Disordered atoms and residues are represented by DisorderedAtom and DisorderedResidue
classes, which are both subclasses of the DisorderedEntityWrapper base class.
They hide the complexity associated with disorder and behave exactly as Atom
and Residue objects.</P><P>In general, a child Entity object (i.e. Atom, Residue, Chain, Model) can be
extracted from its parent (i.e. Residue, Chain, Model, Structure, respectively)
by using an id as a key.</P><PRE CLASS="verbatim">child_entity=parent_entity[child_id]
</PRE><P>You can also get a list of all child Entities of a parent Entity object. Note
that this list is sorted in a specific way (e.g. according to chain identifier
for Chain objects in a Model object).</P><PRE CLASS="verbatim">child_list=parent_entity.get_list()
</PRE><P>You can also get the parent from a child.</P><PRE CLASS="verbatim">parent_entity=child_entity.get_parent()
</PRE><P>At all levels of the SMCRA hierarchy, you can also extract a <EM>full id</EM>.
The full id is a tuple containing all id&#X2019;s starting from the top object (Structure)
down to the current object. A full id for a Residue object e.g. is something
like:</P><PRE CLASS="verbatim">full_id=residue.get_full_id()

print full_id

("1abc", 0, "A", ("", 10, "A"))
</PRE><P>This corresponds to:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The Structure with id "1abc"
</LI><LI CLASS="li-itemize">The Model with id 0
</LI><LI CLASS="li-itemize">The Chain with id "A"
</LI><LI CLASS="li-itemize">The Residue with id (" ", 10, "A").
</LI></UL><P>
The Residue id indicates that the residue is not a hetero-residue (nor a water)
because it has a blank hetero field, that its sequence identifier is 10 and
that its insertion code is "A".</P><P>Some other useful methods:</P><PRE CLASS="verbatim"># get the entity's id

entity.get_id()

# check if there is a child with a given id

entity.has_id(entity_id)

# get number of children

nr_children=len(entity)
</PRE><P>It is possible to delete, rename, add, etc. child entities from a parent entity,
but this does not include any sanity checks (e.g. it is possible to add two
residues with the same id to one chain). This really should be done via a nice
Decorator class that includes integrity checking, but you can take a look at
the code (Entity.py) if you want to use the raw interface.</P><!--TOC subsection Structure-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc138">10.1.1</A>&#XA0;&#XA0;Structure</H3><!--SEC END --><P>The Structure object is at the top of the hierarchy. Its id is a user given
string. The Structure contains a number of Model children. Most crystal structures
(but not all) contain a single model, while NMR structures typically consist
of several models. Disorder in crystal structures of large parts of molecules
can also result in several models.</P><!--TOC subsubsection Constructing a Structure object-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.1.1.1&#XA0;&#XA0;Constructing a Structure object</H4><!--SEC END --><P>A Structure object is produced by a PDBParser object:</P><PRE CLASS="verbatim">from Bio.PDB.PDBParser import PDBParser

p=PDBParser(PERMISSIVE=1)

structure_id="1fat"

filename="pdb1fat.ent"

s=p.get_structure(structure_id, filename)
</PRE><P>The <TT>PERMISSIVE</TT> flag indicates that a number of common problems (see <A HREF="#problem structures">10.5.1</A>)
associated with PDB files will be ignored (but note that some atoms and/or residues
will be missing). If the flag is not present a <TT>PDBConstructionException</TT>
will be generated during the parse operation.</P><!--TOC subsubsection Header and trailer-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.1.1.2&#XA0;&#XA0;Header and trailer</H4><!--SEC END --><P>You can extract the header and trailer (simple lists of strings) of the PDB
file from the PDBParser object with the <TT>get_header</TT> and <TT>get_trailer</TT>
methods.</P><!--TOC subsection Model-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc139">10.1.2</A>&#XA0;&#XA0;Model</H3><!--SEC END --><P>The id of the Model object is an integer, which is derived from the position
of the model in the parsed file (they are automatically numbered starting from
0). The Model object stores a list of Chain children.</P><!--TOC subsubsection Example-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.1.2.1&#XA0;&#XA0;Example</H4><!--SEC END --><P>Get the first model from a Structure object.</P><PRE CLASS="verbatim">first_model=structure[0]
</PRE><!--TOC subsection Chain-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc140">10.1.3</A>&#XA0;&#XA0;Chain</H3><!--SEC END --><P>The id of a Chain object is derived from the chain identifier in the structure
file, and can be any string. Each Chain in a Model object has a unique id. The
Chain object stores a list of Residue children.</P><!--TOC subsubsection Example-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.1.3.1&#XA0;&#XA0;Example</H4><!--SEC END --><P>Get the Chain object with identifier &#X201C;A&#X201D; from a Model object.</P><PRE CLASS="verbatim">chain_A=model["A"]
</PRE><!--TOC subsection Residue-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc141">10.1.4</A>&#XA0;&#XA0;Residue</H3><!--SEC END --><P>Unsurprisingly, a Residue object stores a set of Atom children. In addition,
it also contains a string that specifies the residue name (e.g. &#X201C;ASN&#X201D;)
and the segment identifier of the residue (well known to X-PLOR users, but not
used in the construction of the SMCRA data structure).</P><P>The id of a Residue object is composed of three parts: the hetero field (hetfield),
the sequence identifier (resseq) and the insertion code (icode).</P><P>The hetero field is a string : it is &#X201C;W&#X201D; for waters, &#X201C;H_&#X201D; followed
by the residue name (e.g. &#X201C;H_FUC&#X201D;) for other hetero residues and blank
for standard amino and nucleic acids. This scheme is adopted for reasons described
in section <A HREF="#hetero probems">10.3.1</A>.</P><P>The second field in the Residue id is the sequence identifier, an integer describing
the position of the residue in the chain.</P><P>The third field is a string, consisting of the insertion code. The insertion
code is sometimes used to preserve a certain desirable residue numbering scheme.
A Ser 80 insertion mutant (inserted e.g. between a Thr 80 and an Asn 81 residue)
could e.g. have sequence identifiers and insertion codes as followed: Thr 80
A, Ser 80 B, Asn 81. In this way the residue numbering scheme stays in tune
with that of the wild type structure.</P><P>Let&#X2019;s give some examples. Asn 10 with a blank insertion code would have residue
id <TT>(&#X2019;&#X2019; &#X2019;&#X2019;, 10, &#X2019;&#X2019; &#X2019;&#X2019;)</TT>. Water 10 would have residue id <TT>(&#X2018;&#X2018;W&#X2018;&#X2018;, 10, &#X2018;&#X2018; &#X2018;&#X2018;)</TT>.
A glucose molecule (a hetero residue with residue name GLC) with sequence identifier
10 would have residue id <TT>(&#X2019;&#X2019;H_GLC&#X2019;&#X2019;, 10, &#X2019;&#X2019; &#X2019;&#X2019;)</TT>. In this way, the three
residues (with the same insertion code and sequence identifier) can be part
of the same chain because their residue id&#X2019;s are distinct.</P><P>In most cases, the hetflag and insertion code fields will be blank, e.g. <TT>(&#X2019;&#X2019; &#X2019;&#X2019;, 10, &#X2019;&#X2019; &#X2019;&#X2019;)</TT>.
In these cases, the sequence identifier can be used as a shortcut for the full
id:</P><PRE CLASS="verbatim"># use full id

res10=chain[("", 10, "")]

# use shortcut

res10=chain[10]
</PRE><P>Each Residue object in a Chain object should have a unique id. However, disordered
residues are dealt with in a special way, as described in section <A HREF="#point mutations">10.2.3.2</A>.</P><P>A Residue object has a number of additional methods:</P><PRE CLASS="verbatim">r.get_resname()  # return residue name, e.g. "ASN"
r.get_segid()  # return the SEGID, e.g. "CHN1"
</PRE><!--TOC subsection Atom-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc142">10.1.5</A>&#XA0;&#XA0;Atom</H3><!--SEC END --><P>The Atom object stores the data associated with an atom, and has no children.
The id of an atom is its atom name (e.g. &#X201C;OG&#X201D; for the side chain oxygen
of a Ser residue). An Atom id needs to be unique in a Residue. Again, an exception
is made for disordered atoms, as described in section <A HREF="#disordered atoms">10.2.2</A>.</P><P>In a PDB file, an atom name consists of 4 chars, typically with leading and
trailing spaces. Often these spaces can be removed for ease of use (e.g. an
amino acid C &#X3B1;  atom is labeled &#X201C;.CA.&#X201D; in a PDB file, where
the dots represent spaces). To generate an atom name (and thus an atom id) the
spaces are removed, unless this would result in a name collision in a Residue
(i.e. two Atom objects with the same atom name and id). In the latter case,
the atom name including spaces is tried. This situation can e.g. happen when
one residue contains atoms with names &#X201C;.CA.&#X201D; and &#X201C;CA..&#X201D;, although
this is not very likely.</P><P>The atomic data stored includes the atom name, the atomic coordinates (including
standard deviation if present), the B factor (including anisotropic B factors
and standard deviation if present), the altloc specifier and the full atom name
including spaces. Less used items like the atom element number or the atomic
charge sometimes specified in a PDB file are not stored.</P><P>An Atom object has the following additional methods:</P><PRE CLASS="verbatim">a.get_name()       # atom name (spaces stripped, e.g. "CA")
a.get_id()         # id (equals atom name)
a.get_coord()      # atomic coordinates
a.get_bfactor()    # B factor
a.get_occupancy()  # occupancy
a.get_altloc()     # alternative location specifie
a.get_sigatm()     # std. dev. of atomic parameters
a.get_siguij()     # std. dev. of anisotropic B factor
a.get_anisou()     # anisotropic B factor
a.get_fullname()   # atom name (with spaces, e.g. ".CA.")
</PRE><P>To represent the atom coordinates, siguij, anisotropic B factor and sigatm Numpy
arrays are used.</P><!--TOC section Disorder-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc143">10.2</A>&#XA0;&#XA0;Disorder</H2><!--SEC END --><!--TOC subsection General approach-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc144">10.2.1</A>&#XA0;&#XA0;General approach<A NAME="disorder problems"></A></H3><!--SEC END --><P>Disorder should be dealt with from two points of view: the atom and the residue
points of view. In general, we have tried to encapsulate all the complexity that
arises from disorder. If you just want to loop over all C &#X3B1;  atoms,
you do not care that some residues have a disordered side chain. On the other
hand it should also be possible to represent disorder completely in the data
structure. Therefore, disordered atoms or residues are stored in special objects
that behave as if there is no disorder. This is done by only representing a
subset of the disordered atoms or residues. Which subset is picked (e.g. which
of the two disordered OG side chain atom positions of a Ser residue is used)
can be specified by the user.</P><!--TOC subsection Disordered atoms-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc145">10.2.2</A>&#XA0;&#XA0;Disordered atoms<A NAME="disordered atoms"></A></H3><!--SEC END --><P>Disordered atoms are represented by ordinary Atom objects, but all Atom objects
that represent the same physical atom are stored in a DisorderedAtom object.
Each Atom object in a DisorderedAtom object can be uniquely indexed using its
altloc specifier. The DisorderedAtom object forwards all uncaught method calls
to the selected Atom object, by default the one that represents the atom with
with the highest occupancy. The user can of course change the selected Atom
object, making use of its altloc specifier. In this way atom disorder is represented
correctly without much additional complexity. In other words, if you are not
interested in atom disorder, you will not be bothered by it.</P><P>Each disordered atom has a characteristic altloc identifier. You can specify
that a DisorderedAtom object should behave like the Atom object associated with
a specific altloc identifier:</P><PRE CLASS="verbatim">atom.disordered_select("A")  # select altloc A atom

print atom.get_altloc()
"A"

atom.disordered_select("B")     # select altloc B atom
print atom.get_altloc()
"B"
</PRE><!--TOC subsection Disordered residues-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc146">10.2.3</A>&#XA0;&#XA0;Disordered residues</H3><!--SEC END --><!--TOC subsubsection Common case-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.2.3.1&#XA0;&#XA0;Common case</H4><!--SEC END --><P>The most common case is a residue that contains one or more disordered atoms.
This is evidently solved by using DisorderedAtom objects to represent the disordered
atoms, and storing the DisorderedAtom object in a Residue object just like ordinary
Atom objects. The DisorderedAtom will behave exactly like an ordinary atom (in
fact the atom with the highest occupancy) by forwarding all uncaught method
calls to one of the Atom objects (the selected Atom object) it contains.</P><!--TOC subsubsection Point mutations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.2.3.2&#XA0;&#XA0;Point mutations<A NAME="point mutations"></A></H4><!--SEC END --><P>A special case arises when disorder is due to a point mutation, i.e. when two
or more point mutants of a polypeptide are present in the crystal. An example
of this can be found in PDB structure 1EN2.</P><P>Since these residues belong to a different residue type (e.g. let&#X2019;s say Ser
60 and Cys 60) they should not be stored in a single Residue object as in the
common case. In this case, each residue is represented by one Residue object,
and both Residue objects are stored in a DisorderedResidue object.</P><P>The DisorderedResidue object forwards all uncaught methods to the selected Residue
object (by default the last Residue object added), and thus behaves like an
ordinary residue. Each Residue object in a DisorderedResidue object can be uniquely
identified by its residue name. In the above example, residue Ser 60 would have
id &#X201C;SER&#X201D; in the DisorderedResidue object, while residue Cys 60 would
have id &#X201C;CYS&#X201D;. The user can select the active Residue object in a DisorderedResidue
object via this id.</P><!--TOC section Hetero residues-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc147">10.3</A>&#XA0;&#XA0;Hetero residues</H2><!--SEC END --><!--TOC subsection Associated problems-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc148">10.3.1</A>&#XA0;&#XA0;Associated problems<A NAME="hetero probems"></A></H3><!--SEC END --><P>A common problem with hetero residues is that several hetero and non-hetero
residues present in the same chain share the same sequence identifier (and insertion
code). Therefore, to generate a unique id for each hetero residue, waters and
other hetero residues are treated in a different way.</P><P>Remember that Residue object have the tuple (hetfield, resseq, icode) as id.
The hetfield is blank (&#X201C; &#X201C;) for amino and nucleic acids, and a string
for waters and other hetero residues. The content of the hetfield is explained
below.</P><!--TOC subsection Water residues-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc149">10.3.2</A>&#XA0;&#XA0;Water residues</H3><!--SEC END --><P>The hetfield string of a water residue consists of the letter &#X201C;W&#X201D;. So
a typical residue id for a water is (&#X201C;W&#X201D;, 1, &#X201C; &#X201C;).</P><!--TOC subsection Other hetero residues-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc150">10.3.3</A>&#XA0;&#XA0;Other hetero residues</H3><!--SEC END --><P>The hetfield string for other hetero residues starts with &#X201C;H_&#X201D; followed
by the residue name. A glucose molecule e.g. with residue name &#X201C;GLC&#X201D;
would have hetfield &#X201C;H_GLC&#X201D;. It&#X2019;s residue id could e.g. be (&#X201C;H_GLC&#X201D;,
1, &#X201C; &#X201C;).</P><!--TOC section Some random usage examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc151">10.4</A>&#XA0;&#XA0;Some random usage examples</H2><!--SEC END --><P>Parse a PDB file, and extract some Model, Chain, Residue and Atom objects.</P><PRE CLASS="verbatim">from Bio.PDB.PDBParser import PDBParser

parser=PDBParser()

structure=parser.get_structure("test", "1fat.pdb")
model=structure[0]
chain=model["A"]
residue=chain[1]
atom=residue["CA"]
</PRE><P>Extract a hetero residue from a chain (e.g. a glucose (GLC) moiety with resseq
10).</P><PRE CLASS="verbatim">residue_id=("H_GLC", 10, " ")
residue=chain[residue_id]
</PRE><P>Print all hetero residues in chain.</P><PRE CLASS="verbatim">for residue in chain.get_list():
 residue_id=residue.get_id()
 hetfield=residue_id[0]
 if hetfield[0]=="H":
  print residue_id
</PRE><P>Print out the coordinates of all CA atoms in a structure with B factor greater
than 50.</P><PRE CLASS="verbatim">for model in structure.get_list():
  for chain in model.get_list():
    for residue in chain.get_list():
      if residue.has_id("CA"):
        ca=residue["CA"]
        if ca.get_bfactor()&gt;50.0:
          print ca.get_coord()
</PRE><P>Print out all the residues that contain disordered atoms.</P><PRE CLASS="verbatim">for model in structure.get_list():
  for chain in model.get_list():
    for residue in chain.get_list():
      if residue.is_disordered():
        resseq=residue.get_id()[1]
        resname=residue.get_resname()
        model_id=model.get_id()
        chain_id=chain.get_id()
        print model_id, chain_id, resname, resseq
</PRE><P>Loop over all disordered atoms, and select all atoms with altloc A (if present).
This will make sure that the SMCRA data structure will behave as if only the
atoms with altloc A are present.</P><PRE CLASS="verbatim">for model in structure.get_list():
  for chain in model.get_list():
    for residue in chain.get_list():
      if residue.is_disordered():
        for atom in residue.get_list():
          if atom.is_disordered():
            if atom.disordered_has_id("A"):
              atom.disordered_select("A")
</PRE><P>Suppose that a chain has a point mutation at position 10, consisting of a Ser
and a Cys residue. Make sure that residue 10 of this chain behaves as the Cys
residue.</P><PRE CLASS="verbatim">residue=chain[10]
residue.disordered_select("CYS")
</PRE><!--TOC section Common problems in PDB files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc152">10.5</A>&#XA0;&#XA0;Common problems in PDB files</H2><!--SEC END --><!--TOC subsection Examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc153">10.5.1</A>&#XA0;&#XA0;Examples<A NAME="problem structures"></A></H3><!--SEC END --><P>The PDBParser/Structure class was tested on about 800 structures (each belonging
to a unique SCOP superfamily). This takes about 20 minutes, or on average 1.5
seconds per structure. Parsing the structure of the large ribosomal subunit
(1FKK), which contains about 64000 atoms, takes 10 seconds on a 1000 MHz PC.</P><P>Three exceptions were generated in cases where an unambiguous data structure
could not be built. In all three cases, the likely cause is an error in the
PDB file that should be corrected. Generating an exception in these cases
is much better than running the chance of incorrectly describing
the structure in a data structure.</P><!--TOC subsubsection Duplicate residues-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.5.1.1&#XA0;&#XA0;Duplicate residues</H4><!--SEC END --><P>One structure contains two amino acid residues in one chain with the same sequence
identifier (resseq 3) and icode. Upon inspection it was found that this chain
contains the residues Thr A3, &#X2026;, Gly A202, Leu A3, Glu A204. Clearly,
Leu A3 should be Leu A203. A couple of similar situations exist for structure
1FFK (which e.g. contains Gly B64, Met B65, Glu B65, Thr B67, i.e. residue Glu
B65 should be Glu B66).</P><!--TOC subsubsection Duplicate atoms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.5.1.2&#XA0;&#XA0;Duplicate atoms</H4><!--SEC END --><P>Structure 1EJG contains a Ser/Pro point mutation in chain A at position 22.
In turn, Ser 22 contains some disordered atoms. As expected, all atoms belonging
to Ser 22 have a non-blank altloc specifier (B or C). All atoms of Pro 22 have
altloc A, except the N atom which has a blank altloc. This generates an exception,
because all atoms belonging to two residues at a point mutation should have
non-blank altloc. It turns out that this atom is probably shared by Ser and
Pro 22, as Ser 22 misses the N atom. Again, this points to a problem in the
file: the N atom should be present in both the Ser and the Pro residue, in both
cases associated with a suitable altloc identifier.</P><!--TOC subsection Automatic correction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc154">10.5.2</A>&#XA0;&#XA0;Automatic correction</H3><!--SEC END --><P>Some errors are quite common and can be easily corrected without much risk of
making a wrong interpretation. These cases are listed below.</P><!--TOC subsubsection A blank altloc for a disordered atom-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.5.2.1&#XA0;&#XA0;A blank altloc for a disordered atom</H4><!--SEC END --><P>Normally each disordered atom should have a non-blank altloc identifier. However,
there are many structures that do not follow this convention, and have a blank
and a non-blank identifier for two disordered positions of the same atom. This
is automatically interpreted in the right way.</P><!--TOC subsubsection Broken chains-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.5.2.2&#XA0;&#XA0;Broken chains</H4><!--SEC END --><P>Sometimes a structure contains a list of residues belonging to chain A, followed
by residues belonging to chain B, and again followed by residues belonging to
chain A, i.e. the chains are &#X201C;broken&#X201D;. This is correctly interpreted.</P><!--TOC subsection Fatal errors-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc155">10.5.3</A>&#XA0;&#XA0;Fatal errors</H3><!--SEC END --><P>Sometimes a PDB file cannot be unambiguously interpreted. Rather than guessing
and risking a mistake, an exception is generated, and the user is expected to
correct the PDB file. These cases are listed below.</P><!--TOC subsubsection Duplicate residues-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.5.3.1&#XA0;&#XA0;Duplicate residues</H4><!--SEC END --><P>All residues in a chain should have a unique id. This id is generated based
on:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The sequence identifier (resseq).
</LI><LI CLASS="li-itemize">The insertion code (icode).
</LI><LI CLASS="li-itemize">The hetfield string (&#X201C;W&#X201D; for waters and &#X201C;H_&#X201D; followed by the
residue name for other hetero residues)
</LI><LI CLASS="li-itemize">The residue names of the residues in the case of point mutations (to store the
Residue objects in a DisorderedResidue object).
</LI></UL><P>
If this does not lead to a unique id something is quite likely wrong, and an
exception is generated.</P><!--TOC subsubsection Duplicate atoms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.5.3.2&#XA0;&#XA0;Duplicate atoms</H4><!--SEC END --><P>All atoms in a residue should have a unique id. This id is generated based on:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The atom name (without spaces, or with spaces if a problem arises).
</LI><LI CLASS="li-itemize">The altloc specifier.
</LI></UL><P>
If this does not lead to a unique id something is quite likely wrong, and an
exception is generated.</P><!--TOC section Other features-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc156">10.6</A>&#XA0;&#XA0;Other features</H2><!--SEC END --><P>There are also some tools to analyze a crystal structure. Tools
exist to superimpose two coordinate sets (SVDSuperimposer), to extract
polypeptides from a structure (Polypeptide), to perform neighbor lookup
(NeighborSearch) and to write out PDB files (PDBIO). The neighbor lookup
is done using a KD tree module written in C++. It is very fast and also
includes a fast method to find all point pairs within a certain distance
of each other.</P><P>A Polypeptide object is simply a UserList of Residue objects. You can
construct a list of Polypeptide objects from a Structure object as follows:</P><PRE CLASS="verbatim">model_nr=1
polypeptide_list=build_peptides(structure, model_nr)

for polypeptide in polypeptide_list:
    print polypeptide
</PRE><P>The Polypeptide objects are always created from a single
Model (in this case model 1).</P><!--TOC chapter Bio.PopGen: Population genetics-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc157">Chapter&#XA0;11</A>&#XA0;&#XA0;Bio.PopGen: Population genetics</H1><!--SEC END --><P>Bio.PopGen is a new Biopython module supporting population genetics,
available in Biopython 1.44 onwards.</P><P>The medium term objective for the module is to support widely used data
formats, applications and databases. This module is currently under intense
development and support for new features should appear at a rather fast pace.
Unfortunately this might also entail some instability on the API, especially
if you are using a development version. APIs that are made available on
our official public releases should be much more stable.</P><!--TOC section GenePop-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc158">11.1</A>&#XA0;&#XA0;GenePop</H2><!--SEC END --><P>GenePop (<A HREF="http://genepop.curtin.edu.au/"><TT>http://genepop.curtin.edu.au/</TT></A>) is a popular population
genetics software package supporting Hardy-Weinberg tests, linkage
desiquilibrium, population diferentiation, basic statistics, <I>F</I><SUB><I>st</I></SUB> and
migration estimates, among others. GenePop does not supply sequence
based statistics as it doesn&#X2019;t handle sequence data.
The GenePop file format is supported by a wide range of other population
genetic software applications, thus making it a relevant format in the
population genetics field.</P><P>Bio.PopGen provides a parser and generator of GenePop file format.
Utilities to manipulate the content of a record are also provided.
Here is an example on how to read a GenePop file (you can find
example GenePop data files in the Test/PopGen directory of Biopython):</P><PRE CLASS="verbatim">from Bio.PopGen import GenePop

handle = open("example.gen")
rec = GenePop.read(handle)
handle.close()
</PRE><P>This will read a file called example.gen and parse it. If you
do print rec, the record will be output again, in GenePop format.</P><P>The most important information in rec will be the loci names and
population information (but there is more &#X2013; use help(GenePop.Record)
to check the API documentation). Loci names can be found on rec.loci_list.
Population information can be found on rec.populations.
Populations is a list with one element per population. Each element is itself
a list of individuals, each individual is a pair composed by individual
name and a list of alleles (2 per marker), here is an example for
rec.populations:</P><PRE CLASS="verbatim">[
    [
        ('Ind1', [(1, 2),    (3, 3), (200, 201)],
        ('Ind2', [(2, None), (3, 3), (None, None)],
    ],
    [
        ('Other1', [(1, 1),  (4, 3), (200, 200)],
    ]
]
</PRE><P>So we have two populations, the first with two individuals, the
second with only one. The first individual of the first
population is called Ind1, allelic information for each of
the 3 loci follows. Please note that for any locus, information
might be missing (see as an example, Ind2 above).</P><P>A few utility functions to manipulate GenePop records are made
available, here is an example:</P><PRE CLASS="verbatim">from Bio.PopGen import GenePop

#Imagine that you have loaded rec, as per the code snippet above...

rec.remove_population(pos)
#Removes a population from a record, pos is the population position in
#  rec.populations, remember that it starts on position 0.
#  rec is altered.

rec.remove_locus_by_position(pos)
#Removes a locus by its position, pos is the locus position in
#  rec.loci_list, remember that it starts on position 0.
#  rec is altered.

rec.remove_locus_by_name(name)
#Removes a locus by its name, name is the locus name as in
#  rec.loci_list. If the name doesn't exist the function fails
#  silently.
#  rec is altered.

rec_loci = rec.split_in_loci()
#Splits a record in loci, that is, for each loci, it creates a new
#  record, with a single loci and all populations.
#  The result is returned in a dictionary, being each key the locus name.
#  The value is the GenePop record.
#  rec is not altered.

rec_pops =  rec.split_in_pops(pop_names)
#Splits a record in populations, that is, for each population, it creates
#  a new record, with a single population and all loci.
#  The result is returned in a dictionary, being each key
#  the population name. As population names are not available in GenePop,
#  they are passed in array (pop_names).
#  The value of each dictionary entry is the GenePop record.
#  rec is not altered.
</PRE><P>GenePop does not support population names, a limitation which can be
cumbersome at times. Functionality to enable population names is currently
being planned for Biopython. These extensions won&#X2019;t break compatibility in
any way with the standard format. In the medium term, we would also like to
support the GenePop web service.</P><!--TOC section Coalescent simulation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc159">11.2</A>&#XA0;&#XA0;Coalescent simulation</H2><!--SEC END --><P>A coalescent simulation is a backward model of population genetics with relation to
time. A simulation of ancestry is done until the Most Recent Common Ancestor (MRCA) is found.
This ancestry relationship starting on the MRCA and ending on the current generation
sample is sometimes called a genealogy. Simple cases assume a population of constant
size in time, haploidy, no population structure, and simulate the alleles of a single
locus under no selection pressure.</P><P>Coalescent theory is used in many fields like selection detection, estimation of
demographic parameters of real populations or disease gene mapping.</P><P>The strategy followed in the Biopython implementation of the coalescent was not
to create a new, built-in, simulator from scratch but to use an existing one,
SIMCOAL2 (<A HREF="http://cmpg.unibe.ch/software/simcoal2/"><TT>http://cmpg.unibe.ch/software/simcoal2/</TT></A>). SIMCOAL2 allows for,
among others, population structure, multiple demographic events, simulation
of multiple types of loci (SNPs, sequences, STRs/microsatellites and RFLPs)
with recombination, diploidy multiple chromosomes or ascertainment bias. Notably
SIMCOAL2 doesn&#X2019;t support any selection model. We recommend reading SIMCOAL2&#X2019;s
documentation, available in the link above.</P><P>The input for SIMCOAL2 is a file specifying the desired demography and genome,
the output is a set of files (typically around 1000) with the simulated genomes
of a sample of individuals per subpopulation. This set of files can be used
in many ways, like to compute confidence intervals where which certain
statistics (e.g., <I>F</I><SUB><I>st</I></SUB> or Tajima D) are expected to lie. Real population
genetics datasets statistics can then be compared to those confidence intervals.</P><P>Biopython coalescent code allows to create demographic scenarios and genomes and
to run SIMCOAL2.</P><!--TOC subsection Creating scenarios-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc160">11.2.1</A>&#XA0;&#XA0;Creating scenarios</H3><!--SEC END --><P>Creating a scenario involves both creating a demography and a chromosome structure.
In many cases (e.g. when doing Approximate Bayesian Computations &#X2013; ABC) it is
important to test many parameter variations (e.g. vary the effective population size,
<I>N</I><SUB><I>e</I></SUB>, between 10, 50, 500 and 1000 individuals). The code provided allows for
the simulation of scenarios with different demographic parameters very easily.</P><P>Below we see how we can create scenarios and then how simulate them.</P><!--TOC subsubsection Demography-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->11.2.1.1&#XA0;&#XA0;Demography</H4><!--SEC END --><P>A few predefined demographies are built-in, all have two shared parameters: sample size
(called sample_size on the template, see below for its use) per deme and deme size, i.e.
subpopulation size (pop_size). All demographies are available as templates where all
parameters can be varied, each template has a system name. The prefedined
demographies/templates are:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Single population, constant size</B></DT><DD CLASS="dd-description"> The standard parameters are enough to specify
it. Template name: simple.
</DD><DT CLASS="dt-description"><B>Single population, bottleneck</B></DT><DD CLASS="dd-description"> As seen on figure <A HREF="#fig:bottle">11.2.1.1</A>. The parameters
are current population size (pop_size on template ne3 on figure), time of expansion,
given as the generation in the past when it occurred (expand_gen), 
effective population size during bottleneck (ne2), time of contraction
(contract_gen) and original size in the remote past (ne3). Template name: bottle.
</DD><DT CLASS="dt-description"><B>Island model</B></DT><DD CLASS="dd-description"> The typical island model. The total number of demes is specified
by total_demes and the migration rate by mig. Template name island.
</DD><DT CLASS="dt-description"><B>Stepping stone model - 1 dimension</B></DT><DD CLASS="dd-description"> The stepping stone model in 1 dimension,
extremes disconnected. The total number of demes is total_demes, migration rate
is mig. Template name is ssm_1d.
</DD><DT CLASS="dt-description"><B>Stepping stone model - 2 dimensions</B></DT><DD CLASS="dd-description"> The stepping stone model in 2 dimensions,
extremes disconnected. The parameters are x for the horizontal dimension and y
for the vertical (being the total number of demes x times y), migration rate is mig.
Template name is ssm_2d.
</DD></DL><P>
<A NAME="fig:bottle"></A>
<IMG SRC="images/bottle.png">
</P><P>In our first example, we will generate a template for a single population, constant size
model with a sample size of 30 and a deme size of 500. The code for this is:</P><PRE CLASS="verbatim">from Bio.PopGen.SimCoal.Template import generate_simcoal_from_template

generate_simcoal_from_template('simple',
    [(1, [('SNP', [24, 0.0005, 0.0])])],
    [('sample_size', [30]),
    ('pop_size', [100])])
</PRE><P>Executing this code snippet will generate a file on the current directory called
simple_100_300.par this file can be given as input to SIMCOAL2 to simulate the
demography (below we will see how Biopython can take care of calling SIMCOAL2).</P><P>This code consists of a single function call, let&#X2019;s discuss it parameter by parameter.</P><P>The first parameter is the template id (from the list above). We are using the id
&#X2019;simple&#X2019; which is the template for a single population of constant size along time.</P><P>The second parameter is the chromosome structure. Please ignore it for now, it will be
explained in the next section.</P><P>The third parameter is a list of all required parameters (recall that the simple model
only needs sample_size and pop_size) and possible values (in this case each
parameter only has a possible value).</P><P>Now, let&#X2019;s consider an example where we want to generate several island models, and we
are interested in varying the number of demes: 10, 50 and 100 with a migration
rate of 1%. Sample size and deme
size will be the same as before. Here is the code:</P><PRE CLASS="verbatim">from Bio.PopGen.SimCoal.Template import generate_simcoal_from_template

generate_simcoal_from_template('island',
    [(1, [('SNP', [24, 0.0005, 0.0])])],
    [('sample_size', [30]),
    ('pop_size', [100]),
    ('mig', [0.01]),
    ('total_demes', [10, 50, 100])])
</PRE><P>In this case, 3 files will be generated: island_100_0.01_100_30.par,
island_10_0.01_100_30.par and island_50_0.01_100_30.par. Notice the
rule to make file names: template name, followed by parameter values in
reverse order.</P><P>A few, arguably more esoteric template demographies exist (please check the
Bio/PopGen/SimCoal/data directory on Biopython source tree). Furthermore it is possible
for the user to create new templates. That functionality will be discussed in a future
version of this document.</P><!--TOC subsubsection Chromosome structure-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->11.2.1.2&#XA0;&#XA0;Chromosome structure</H4><!--SEC END --><P>We strongly recommend reading SIMCOAL2 documentation to understand the full potential
available in modeling chromosome structures. In this subsection we only discuss how
to implement chromosome structures using the Biopython interface, not the underlying
SIMCOAL2 capabilities.</P><P>We will start by implementing a single chromosome, with 24 SNPs with
a recombination rate immediately on the right of each locus of 0.0005 and a
minimum frequency of the minor allele of 0. This will be specified by the
following list (to be passed as second parameter to the function
generate_simcoal_from_template):</P><PRE CLASS="verbatim">[(1, [('SNP', [24, 0.0005, 0.0])])]
</PRE><P>This is actually the chromosome structure used in the above examples.</P><P>The chromosome structure is represented by a list of chromosomes,
each chromosome (i.e., each element in the list)
is composed by a tuple (a pair): the first element
is the number of times the chromosome is to be repeated (as there
might be interest in repeating the same chromosome many times).
The second element is a list of the actual components of the chromosome.
Each element is again a pair, the first member is the locus type and
the second element the parameters for that locus type. Confused?
Before showing more examples let&#X2019;s review the example above: We have
a list with one element (thus one chromosome), the chromosome is
a single instance (therefore not to be repeated), it is composed
of 24 SNPs, with a recombination rate of 0.0005 between each
consecutive SNP, the minimum frequency of the minor allele is
0.0 (i.e, it can be absent from a certain population).</P><P>Let&#X2019;s see a more complicated example:</P><PRE CLASS="verbatim">[
  (5, [
       ('SNP', [24, 0.0005, 0.0])
      ]
  ),
  (2, [
       ('DNA', [10, 0.0, 0.00005, 0.33]),
       ('RFLP', [1, 0.0, 0.0001]),
       ('MICROSAT', [1, 0.0, 0.001, 0.0, 0.0])
      ]
  )
]
</PRE><P>We start by having 5 chromosomes with the same structure as
above (i.e., 24 SNPs). We then have 2 chromosomes which
have a DNA sequence with 10 nucleotides, 0.0 recombination rate,
0.0005 mutation rate, and a transition rate of 0.33. Then we
have an RFLP with 0.0 recombination rate to the next locus and
a 0.0001 mutation rate. Finally we have a microsatellite (or STR),
with 0.0 recombination rate to the next locus (note, that as this
is a single microsatellite which has no loci following, this
recombination rate here is irrelevant), with a mutation rate
of 0.001, geometric parameter of 0.0 and a range constraint
of 0.0 (for information about this parameters please consult
the SIMCOAL2 documentation, you can use them to simulate
various mutation models, including the typical &#X2013; for microsatellites &#X2013;
stepwise mutation model among others).</P><!--TOC subsection Running SIMCOAL2-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc161">11.2.2</A>&#XA0;&#XA0;Running SIMCOAL2</H3><!--SEC END --><P>We now discuss how to run SIMCOAL2 from inside Biopython. It is required
that the binary for SIMCOAL2 is called simcoal2 (or simcoal2.exe on Windows
based platforms), please note that the typical name when downloading the
program is in the format simcoal2_x_y. As such, when installing SIMCOAL2
you will need to rename of the downloaded executable so that Biopython can
find it.</P><P>It is possible to run SIMCOAL2 on files that were not generated using the method
above (e.g., writing a parameter file by hand), but we will show an
example by creating a model using the framework presented above.</P><PRE CLASS="verbatim">from Bio.PopGen.SimCoal.Template import generate_simcoal_from_template
from Bio.PopGen.SimCoal.Controller import SimCoalController


generate_simcoal_from_template('simple',
    [
      (5, [
           ('SNP', [24, 0.0005, 0.0])
          ]
      ),
      (2, [
           ('DNA', [10, 0.0, 0.00005, 0.33]),
           ('RFLP', [1, 0.0, 0.0001]),
           ('MICROSAT', [1, 0.0, 0.001, 0.0, 0.0])
          ]
      )
    ],
    [('sample_size', [30]),
    ('pop_size', [100])])

ctrl = SimCoalController('.')
ctrl.run_simcoal('simple_100_30.par', 50)
</PRE><P>The lines of interest are the last two (plus the new import).
Firstly a controller for the
application is created. The directory where the binary is located has
to be specified.</P><P>The simulator is then run on the last line: we know, from the rules explained
above, that the input file name is simple_100_30.par for the
simulation parameter file created. We then specify
that we want to run 50 independent simulations, by default Biopython
requests a simulation of diploid data, but a third parameter can
be added to simulate haploid data (adding as a parameter the
string &#X2019;0&#X2019;). SIMCOAL2 will now run (please
note that this can take quite a lot of time) and will create a directory
with the simulation results. The results can now be analysed (typically
studying the data with Arlequin3). In the future Biopython might support
reading the Arlequin3 format and thus allowing for the analysis of SIMCOAL2
data inside Biopython.</P><!--TOC section Other applications-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc162">11.3</A>&#XA0;&#XA0;Other applications</H2><!--SEC END --><P>Here we discuss interfaces and utilities to deal with population genetics&#X2019;
applications which arguably have a smaller user base.</P><!--TOC subsection FDist: Detecting selection and molecular adaptation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc163">11.3.1</A>&#XA0;&#XA0;FDist: Detecting selection and molecular adaptation</H3><!--SEC END --><P>FDist is a selection detection application suite based on computing
(i.e. simulating) a &#X201C;neutral&#X201D; confidence interval based on <I>F</I><SUB><I>st</I></SUB> and
heterozygosity. Markers (which can be SNPs, microsatellites, AFLPs
among others) which lie outside the &#X201C;neutral&#X201D; interval are to be
considered as possible candidates for being under selection.</P><P>FDist is mainly used when the number of markers is considered enough
to estimate an average <I>F</I><SUB><I>st</I></SUB>, but not enough to either have outliers
calculated from the dataset directly or, with even more markers for
which the relative positions in the genome are known, to use
approaches based on, e.g., Extended Haplotype Heterozygosity (EHH).</P><P>The typical usage pattern for FDist is as follows:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Import a dataset from an external format into FDist format.
</LI><LI CLASS="li-enumerate">Compute average <I>F</I><SUB><I>st</I></SUB>. This is done by datacal inside FDist.
</LI><LI CLASS="li-enumerate">Simulate &#X201C;neutral&#X201D; markers based on the
average <I>F</I><SUB><I>st</I></SUB> and expected number of total populations.
This is the core operation, done by fdist inside FDist.
</LI><LI CLASS="li-enumerate">Calculate the confidence interval, based on the desired
confidence boundaries (typically 95% or 99%). This is done by
cplot and is mainly used to plot the interval.
</LI><LI CLASS="li-enumerate">Assess each marker status against the simulation &#X201C;neutral&#X201D;
confidence interval. Done
by pv. This is used to detect the outlier status of each marker
against the simulation.
</LI></OL><P>We will now discuss each step with illustrating example code
(for this example to work FDist binaries have to be on the
executable PATH).</P><P>The FDist data format is application specific and is not used at
all by other applications, as such you will probably have to convert
your data for use with FDist. Biopython can help you do this.
Here is an example converting from GenePop format to FDist format
(along with imports that will be needed on examples further below):</P><PRE CLASS="verbatim">from Bio.PopGen import GenePop
from Bio.PopGen import FDist
from Bio.PopGen.FDist import Controller
from Bio.PopGen.FDist.Utils import convert_genepop_to_fdist

gp_rec = GenePop.read(open("example.gen"))
fd_rec = convert_genepop_to_fdist(gp_rec)
in_file = open("infile", "w")
in_file.write(str(fd_rec))
in_file.close()
</PRE><P>In this code we simply parse a GenePop file and convert it to a FDist
record.</P><P>Printing an FDist record will generate
a string that can be directly saved to a file and supplied to FDist. FDist
requires the input file to be called infile, therefore we save the record on
a file with that name.</P><P>The most important fields on a FDist record are: num_pops, the number of
populations; num_loci, the number of loci and loci_data with the marker
data itself. Most probably the details of the record are of no interest
to the user, as the record only purpose is to be passed to FDist.</P><P>The next step is to calculate the average <I>F</I><SUB><I>st</I></SUB> of the dataset (along
with the sample size):</P><PRE CLASS="verbatim">ctrl = Controller.FDistController()
fst, samp_size = ctrl.run_datacal()
</PRE><P>On the first line we create an object to control the call of FDist
suite, this object will be used further on in order to call other
suite applications.</P><P>On the second line we call the datacal application which computes the
average <I>F</I><SUB><I>st</I></SUB>
and the sample size. It is worth noting that the <I>F</I><SUB><I>st</I></SUB> computed by
datacal is a <EM>variation</EM> of Weir and Cockerham&#X2019;s &#X3B8;.</P><P>We can now call the main fdist application in order to simulate neutral
markers.</P><PRE CLASS="verbatim">sim_fst = ctrl.run_fdist(npops = 15, nsamples = fd_rec.num_pops, fst = fst,
    sample_size = samp_size, mut = 0, num_sims = 40000)
</PRE><DL CLASS="description"><DT CLASS="dt-description">
<B>npops</B></DT><DD CLASS="dd-description"> Number of populations existing in nature. This is really a
&#X201C;guestimate&#X201D;. Has to be lower than 100.
</DD><DT CLASS="dt-description"><B>nsamples</B></DT><DD CLASS="dd-description"> Number of populations sampled, has to be lower than npops.
</DD><DT CLASS="dt-description"><B>fst</B></DT><DD CLASS="dd-description"> Average <I>F</I><SUB><I>st</I></SUB>.
</DD><DT CLASS="dt-description"><B>sample_size</B></DT><DD CLASS="dd-description"> Average number of individuals sampled on each population.
</DD><DT CLASS="dt-description"><B>mut</B></DT><DD CLASS="dd-description"> Mutation model: 0 - Infinite alleles; 1 - Stepwise mutations
</DD><DT CLASS="dt-description"><B>num_sims</B></DT><DD CLASS="dd-description"> Number of simulations to perform. Typically a number around
40000 will be OK, but if you get a confidence interval that looks sharp
(this can be detected when plotting the confidence interval computed
below) the value can be increased (a suggestion would be steps of 10000
simulations).
</DD></DL><P>The confusion in wording between number of samples and sample size
stems from the original application.</P><P>A file named out.dat will be created with the simulated heterozygosities
and <I>F</I><SUB><I>st</I></SUB>s, it will have as many lines as the number of simulations
requested.</P><P>Note that fdist returns the average <I>F</I><SUB><I>st</I></SUB> that it was <EM>capable</EM> of
simulating, for more details about this issue please read below the paragraph
on approximating the desired average <I>F</I><SUB><I>st</I></SUB>.</P><P>The next (optional) step is to calculate the confidence interval:</P><PRE CLASS="verbatim">cpl_interval = ctrl.run_cplot(ci=0.99)
</PRE><P>You can only call cplot after having run fdist.</P><P>This will calculate the confidence intervals (99% in this case)
for a previous fdist run. A list of quadruples is returned. The
first element represents the heterozygosity, the second the lower
bound of <I>F</I><SUB><I>st</I></SUB> confidence interval for that heterozygosity,
the third the average and the fourth the upper bound. This can
be used to trace the confidence interval contour. This list
is also written to a file, out.cpl.</P><P>The main purpose of this step is return a set of points which can
be easily used to plot a confidence interval. It can be skipped
if the objective is only to assess the status of each marker against
the simulation, which is the next step...</P><PRE CLASS="verbatim">pv_data = ctrl.run_pv()
</PRE><P>You can only call cplot after having run datacal and fdist.</P><P>This will use the simulated markers to assess the status of each
individual real marker. A list, in the same order than the loci_list
that is on the FDist record (which is in the same order that the GenePop
record) is returned. Each element in the list is a quadruple, the
fundamental member of each quadruple is the last element (regarding the
other elements, please refer to the pv documentation &#X2013; for the
sake of simplicity we will not discuss them here) which returns the
probability of the simulated <I>F</I><SUB><I>st</I></SUB> being lower than the marker <I>F</I><SUB><I>st</I></SUB>.
Higher values would indicate a stronger candidate for positive selection,
lower values a candidate for balancing selection, and intermediate values
a possible neutral marker. What is &#X201C;higher&#X201D;, &#X201C;lower&#X201D; or &#X201C;intermediate&#X201D;
is really a subjective issue, but taking a &#X201C;confidence interval&#X201D; approach
and considering a 95% confidence interval, &#X201C;higher&#X201D; would be between 0.95
and 1.0, &#X201C;lower&#X201D; between 0.0 and 0.05 and &#X201C;intermediate&#X201D; between 0.05 and
0.95.</P><!--TOC subsubsection Approximating the desired average <I>F</I><SUB><I>st</I></SUB>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->11.3.1.1&#XA0;&#XA0;Approximating the desired average <I>F</I><SUB><I>st</I></SUB></H4><!--SEC END --><P>Fdist tries to approximate the desired average <I>F</I><SUB><I>st</I></SUB> by doing a
coalescent simulation using migration rates based on the formula</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>m</I></SUB>&#XA0;=&#XA0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1&#XA0;&#X2212;&#XA0;<I>F</I><SUB><I>st</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4<I>F</I><SUB><I>st</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#XA0;</TD></TR>
</TABLE><P>This formula assumes a few premises like an infinite number of populations.</P><P>In practice, when the number of populations is low, the mutation model
is stepwise and the sample size increases, fdist will not be able to
simulate an acceptable approximate average <I>F</I><SUB><I>st</I></SUB>.</P><P>To address that, a function is provided to iteratively approach the desired
value by running several fdists in sequence. This approach is computationally
more intensive than running a single fdist run, but yields good results.
The following code runs fdist approximating the desired <I>F</I><SUB><I>st</I></SUB>:</P><PRE CLASS="verbatim">sim_fst = ctrl.run_fdist_force_fst(npops = 15, nsamples = fd_rec.num_pops,
    fst = fst, sample_size = samp_size, mut = 0, num_sims = 40000,
    limit = 0.05)
</PRE><P>The only new optional parameter, when comparing with run_fdist, is limit
which is the desired maximum error. run_fdist can (and probably should)
be safely replaced with run_fdist_force_fst.</P><!--TOC subsubsection Final notes-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->11.3.1.2&#XA0;&#XA0;Final notes</H4><!--SEC END --><P>The process to determine the average <I>F</I><SUB><I>st</I></SUB> can be more sophisticated than
the one presented here. For more information we refer you to the FDist
README file. Biopython&#X2019;s code can be used to implement more sophisticated
approaches.</P><!--TOC section Future Developments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc164">11.4</A>&#XA0;&#XA0;Future Developments</H2><!--SEC END --><P>The most desired future developments would be the ones you add yourself ;) .</P><P>That being said, already existing fully functional code is currently being
incorporated in Bio.PopGen, that code covers the applications FDist and
SimCoal2, the HapMap and UCSC Table Browser databases and some simple statistics
like <I>F</I><SUB><I>st</I></SUB>, or allele counts.</P><!--TOC chapter Phylogenetics with Bio.Phylo-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc165">Chapter&#XA0;12</A>&#XA0;&#XA0;Phylogenetics with Bio.Phylo</H1><!--SEC END --><P>
<A NAME="sec:Phylo"></A></P><P>The Bio.Phylo module was introduced in Biopython 1.54. Following the lead of SeqIO and AlignIO,
it aims to provide a common way to work with phylogenetic trees independently of the source data
format, as well as a consistent API for I/O operations.</P><!--TOC section Demo: What&#X2019;s in a Tree?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc166">12.1</A>&#XA0;&#XA0;Demo: What&#X2019;s in a Tree?</H2><!--SEC END --><P>To get acquainted with the module, let&#X2019;s start with a tree that we&#X2019;ve already constructed, and
inspect it a few different ways. Then we&#X2019;ll colorize the branches, to use a special phyloXML
feature, and finally save it.</P><P>In a terminal, create a simple Newick file using your favorite text editor:</P><PRE CLASS="verbatim">% cat &gt; simple.dnd &lt;&lt;EOF
&gt; (((A,B),(C,D)),(E,F,G));
&gt; EOF
</PRE><P>This tree has no branch lengths, only a topology and labelled terminals. (If you have a real
tree file available, you can follow this demo using that instead.)</P><P>Launch the Python interpreter of your choice:</P><PRE CLASS="verbatim">% ipython -pylab
</PRE><P>For interactive work, launching the IPython interpreter with the <CODE>-pylab</CODE> flag enables
<B>matplotlib</B> integration, so graphics will pop up automatically. We&#X2019;ll use that during
this demo.</P><P>Now, within Python, read the tree file, giving the file name and the name of the format.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Phylo
&gt;&gt;&gt; tree = Phylo.read("simple.dnd", "newick")
</PRE><P>Printing the tree object as a string gives us a look at the entire object hierarchy.</P><PRE CLASS="verbatim">&gt;&gt;&gt; print tree

Tree(weight=1.0, rooted=False, name="")
    Clade(branch_length=1.0)
        Clade(branch_length=1.0)
            Clade(branch_length=1.0)
                Clade(branch_length=1.0, name="A")
                Clade(branch_length=1.0, name="B")
            Clade(branch_length=1.0)
                Clade(branch_length=1.0, name="C")
                Clade(branch_length=1.0, name="D")
        Clade(branch_length=1.0)
            Clade(branch_length=1.0, name="E")
            Clade(branch_length=1.0, name="F")
            Clade(branch_length=1.0, name="G")
</PRE><P>The <TT>Tree</TT> object contains global information about the tree, such as whether it&#X2019;s
rooted or unrooted. It has one root clade, and under that, it&#X2019;s nested lists of clades all the
way down to the tips.</P><P>The function <CODE>draw_ascii</CODE> creates a simple ASCII-art (plain text) dendrogram. This is a
convenient visualization for interactive exploration, in case better graphical tools aren&#X2019;t
available.</P><PRE CLASS="verbatim">&gt;&gt;&gt; Phylo.draw_ascii(tree)
                                                    ________________________ A
                           ________________________|
                          |                        |________________________ B
  ________________________|
 |                        |                         ________________________ C
 |                        |________________________|
_|                                                 |________________________ D
 |
 |                         ________________________ E
 |                        |
 |________________________|________________________ F
                          |
                          |________________________ G

</PRE><P>If you have <B>matplotlib</B> or <B>pylab</B> installed, you can create a graphic
using the <CODE>draw</CODE> function (see Fig. <A HREF="#fig:phylo-simple-draw">12.1</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree.rooted = True
&gt;&gt;&gt; Phylo.draw(tree)
</PRE><P>
<IMG SRC="images/phylo-simple-draw.png" width=666, height=530>
<A NAME="fig:phylo-simple-draw"></A>
</P><!--TOC subsection Coloring branches within a tree-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc167">12.1.1</A>&#XA0;&#XA0;Coloring branches within a tree</H3><!--SEC END --><P>The functions <CODE>draw</CODE> and <CODE>draw_graphviz</CODE> support the display of different
colors and branch widths in a tree.
As of Biopython 1.59, the <CODE>color</CODE> and <CODE>width</CODE> attributes are available on the
basic Clade object and there&#X2019;s nothing extra required to use them.
Both attributes refer to the branch leading the given clade, and apply recursively, so
all descendent branches will also inherit the assigned width and color values during
display.</P><P>In earlier versions of Biopython, these were special features of PhyloXML trees, and
using the attributes required first converting the tree to a subclass of the basic tree
object called Phylogeny, from the Bio.Phylo.PhyloXML module.</P><P>In Biopython 1.55 and later, this is a convenient tree method:</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree = tree.as_phyloxml()
</PRE><P>In Biopython 1.54, you can accomplish the same thing with one extra import:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Phylo.PhyloXML import Phylogeny
&gt;&gt;&gt; tree = Phylogeny.from_tree(tree)
</PRE><P>Note that the file formats Newick and Nexus don&#X2019;t support branch colors or widths, so
if you use these attributes in Bio.Phylo, you will only be able to save the values in
PhyloXML format. (You can still save a tree as Newick or Nexus, but the color and width
values will be skipped in the output file.)</P><P>Now we can begin assigning colors.
First, we&#X2019;ll color the root clade gray. We can do that by assigning the 24-bit color
value as an RGB triple, an HTML-style hex string, or the name of one of the predefined
colors.</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree.root.color = (128, 128, 128)
</PRE><P>Or:</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree.root.color = "#808080"
</PRE><P>Or:</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree.root.color = "gray"
</PRE><P>Colors for a clade are treated as cascading down through the entire clade, so when we colorize
the root here, it turns the whole tree gray. We can override that by assigning a different
color lower down on the tree.</P><P>Let&#X2019;s target the most recent common ancestor (MRCA) of the nodes named &#X201C;E&#X201D; and &#X201C;F&#X201D;. The
<CODE>common_ancestor</CODE> method returns a reference to that clade in the original tree, so when
we color that clade &#X201C;salmon&#X201D;, the color will show up in the original tree.</P><PRE CLASS="verbatim">&gt;&gt;&gt; mrca = tree.common_ancestor({"name": "E"}, {"name": "F"})
&gt;&gt;&gt; mrca.color = "salmon"
</PRE><P>If we happened to know exactly where a certain clade is in the tree, in terms of nested list
entries, we can jump directly to that position in the tree by indexing it. Here, the index
<CODE>[0,1]</CODE> refers to the second child of the first child of the root.</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree.clade[0,1].color = "blue"
</PRE><P>Finally, show our work (see Fig. <A HREF="#fig:phylo-color-draw">12.1.1</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; Phylo.draw(tree)
</PRE><P>
<IMG SRC="images/phylo-color-draw.png" width=666, height=530>
<A NAME="fig:phylo-color-draw"></A>
</P><P>Note that a clade&#X2019;s color includes the branch leading to that clade, as well as its
descendents. The common ancestor of E and F turns out to be just under the root, and with this
coloring we can see exactly where the root of the tree is.</P><P>My, we&#X2019;ve accomplished a lot! Let&#X2019;s take a break here and save our work. Call the
<TT>write</TT> function with a file name or handle &#X2014; here we use standard output, to see what
would be written &#X2014; and the format <TT>phyloxml</TT>. PhyloXML saves the colors we assigned,
so you can open this phyloXML file in another tree viewer like Archaeopteryx, and the colors
will show up there, too.</P><PRE CLASS="verbatim">&gt;&gt;&gt; import sys
&gt;&gt;&gt; Phylo.write(tree, sys.stdout, "phyloxml")

&lt;phy:phyloxml xmlns:phy="http://www.phyloxml.org"&gt;
  &lt;phy:phylogeny rooted="true"&gt;
    &lt;phy:clade&gt;
      &lt;phy:branch_length&gt;1.0&lt;/phy:branch_length&gt;
      &lt;phy:color&gt;
        &lt;phy:red&gt;128&lt;/phy:red&gt;
        &lt;phy:green&gt;128&lt;/phy:green&gt;
        &lt;phy:blue&gt;128&lt;/phy:blue&gt;
      &lt;/phy:color&gt;
      &lt;phy:clade&gt;
        &lt;phy:branch_length&gt;1.0&lt;/phy:branch_length&gt;
        &lt;phy:clade&gt;
          &lt;phy:branch_length&gt;1.0&lt;/phy:branch_length&gt;
          &lt;phy:clade&gt;
            &lt;phy:name&gt;A&lt;/phy:name&gt;
            ...
</PRE><P>The rest of this chapter covers the core functionality of Bio.Phylo in greater detail. For more
examples of using Bio.Phylo, see the cookbook page on Biopython.org:</P><P><A HREF="http://biopython.org/wiki/Phylo_cookbook"><TT>http://biopython.org/wiki/Phylo_cookbook</TT></A></P><!--TOC section I/O functions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc168">12.2</A>&#XA0;&#XA0;I/O functions</H2><!--SEC END --><P>Like SeqIO and AlignIO, Phylo handles file input and output through four functions:
<CODE>parse</CODE>, <CODE>read</CODE>, <CODE>write</CODE> and <CODE>convert</CODE>.</P><P>The <CODE>read</CODE> function parses a single tree in the given file and returns it. Careful; it
will raise an error if the file contains more than one tree, or no trees.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Phylo
&gt;&gt;&gt; tree = Phylo.read("Tests/Nexus/int_node_labels.nwk", "newick")
&gt;&gt;&gt; print tree
</PRE><P>(Example files are available in the <TT>Tests/Nexus/</TT> and <TT>Tests/PhyloXML/</TT>
directories of the Biopython distribution.)</P><P>To handle multiple (or an unknown number of) trees, use the <CODE>parse</CODE> function iterates
through each of the trees in the given file: </P><PRE CLASS="verbatim">&gt;&gt;&gt; trees = Phylo.parse("Tests/PhyloXML/phyloxml_examples.xml", "phyloxml")
&gt;&gt;&gt; for tree in trees:
...     print tree
</PRE><P>Write a tree or iterable of trees back to file with the <CODE>write</CODE> function:</P><PRE CLASS="verbatim">&gt;&gt;&gt; trees = list(Phylo.parse("phyloxml_examples.xml", "phyloxml"))
&gt;&gt;&gt; tree1 = trees[0]
&gt;&gt;&gt; others = trees[1:]
&gt;&gt;&gt; Phylo.write(tree1, "tree1.xml", "phyloxml")
1
&gt;&gt;&gt; Phylo.write(others, "other_trees.xml", "phyloxml")
12
</PRE><P>Convert files between any of the supported formats with the <CODE>convert</CODE> function:</P><PRE CLASS="verbatim">&gt;&gt;&gt; Phylo.convert("tree1.xml", "phyloxml", "tree1.dnd", "newick")
1
&gt;&gt;&gt; Phylo.convert("other_trees.xml", "phyloxml", "other_trees.nex", 'nexus")
12
</PRE><P>To use strings as input or output instead of actual files, use <CODE>StringIO</CODE> as you would
with SeqIO and AlignIO:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Phylo
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; handle = StringIO("(((A,B),(C,D)),(E,F,G));")
&gt;&gt;&gt; tree = Phylo.read(handle, "newick")
</PRE><!--TOC section View and export trees-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc169">12.3</A>&#XA0;&#XA0;View and export trees</H2><!--SEC END --><P>The simplest way to get an overview of a <CODE>Tree</CODE> object is to <CODE>print</CODE> it:</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree = Phylo.read("Tests/PhyloXML/example.xml", "phyloxml")
&gt;&gt;&gt; print tree
Phylogeny(rooted='True', description='phyloXML allows to use either a "branch_length"
attribute...', name='example from Prof. Joe Felsenstein's book "Inferring Phyl...')
    Clade()
        Clade(branch_length='0.06')
            Clade(branch_length='0.102', name='A')
            Clade(branch_length='0.23', name='B')
        Clade(branch_length='0.4', name='C')
</PRE><P>This is essentially an outline of the object hierarchy Biopython uses to represent a tree. But
more likely, you&#X2019;d want to see a drawing of the tree. There are three functions to do this.</P><P>As we saw in the demo, <CODE>draw_ascii</CODE> prints an ascii-art drawing of the tree (a
rooted phylogram) to standard output, or an open file handle if given. Not all of the
available information about the tree is shown, but it provides a way to quickly view the
tree without relying on any external dependencies.</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree = Phylo.read("example.xml", "phyloxml")
&gt;&gt;&gt; Phylo.draw_ascii(tree)
             __________________ A
  __________|
_|          |___________________________________________ B
 |
 |___________________________________________________________________________ C

</PRE><P>The <CODE>draw</CODE> function draws a more attractive image using the matplotlib
library. See the API documentation for details on the arguments it accepts to
customize the output.</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree = Phylo.read("example.xml", "phyloxml")
&gt;&gt;&gt; Phylo.draw(tree, branch_labels=lambda c: c.branch_length)
</PRE><P>
<IMG SRC="images/phylo-draw-example.png" width=701, height=465>
<A NAME="fig:phylo-draw-example"></A>
</P><P><CODE>draw_graphviz</CODE> draws an unrooted cladogram, but requires that you have Graphviz,
PyDot or PyGraphviz, NetworkX, and matplotlib (or pylab) installed. Using the same example as
above, and the <CODE>dot</CODE> program included with Graphviz, let&#X2019;s draw a rooted tree (see
Fig.&#XA0;<A HREF="#fig:phylo-dot">12.3</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree = Phylo.read("example.xml", "phyloxml")
&gt;&gt;&gt; Phylo.draw_graphviz(tree, prog='dot')
&gt;&gt;&gt; import pylab
&gt;&gt;&gt; pylab.show()                    # Displays the tree in an interactive viewer
&gt;&gt;&gt; pylab.savefig('phylo-dot.png')  # Creates a PNG file of the same graphic
</PRE><P>
<IMG SRC="images/phylo-dot.png" width=400, height=312>
<A NAME="fig:phylo-dot"></A>
</P><P>(Tip: If you execute IPython with the <CODE>-pylab</CODE> option, calling <CODE>draw_graphviz</CODE> causes
the matplotlib viewer to launch automatically without manually calling <CODE>show()</CODE>.)</P><P>This exports the tree object to a NetworkX graph, uses Graphviz to lay out the nodes, and
displays it using matplotlib. 
There are a number of keyword arguments that can modify the resulting diagram, including
most of those accepted by the NetworkX functions <CODE>networkx.draw</CODE> and
<CODE>networkx.draw_graphviz</CODE>.</P><P>The display is also affected by the <CODE>rooted</CODE> attribute of the given tree object.
Rooted trees are shown with a &#X201C;head&#X201D; on each branch indicating direction (see
Fig.&#XA0;<A HREF="#fig:phylo-rooted">12.3</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree = Phylo.read("simple.dnd", "newick")
&gt;&gt;&gt; tree.rooted = True
&gt;&gt;&gt; Phylo.draw_graphiz(tree)
</PRE><P>
<IMG SRC="images/phylo-rooted.png" width=432, height=368>
<A NAME="fig:phylo-rooted"></A>
</P><P>The &#X201C;prog&#X201D; argument specifies the Graphviz engine used for layout. The default,
<CODE>twopi</CODE>, behaves well for any size tree, reliably avoiding crossed branches. The
<CODE>neato</CODE> program may draw more attractive moderately-sized trees, but sometimes will
cross branches (see Fig.&#XA0;<A HREF="#fig:phylo-color">12.3</A>). The <CODE>dot</CODE> program may be useful
with small trees, but tends to do surprising things with the layout of larger trees.</P><PRE CLASS="verbatim">&gt;&gt;&gt; Phylo.draw_graphviz(tree, prog="neato")
</PRE><P>
<IMG SRC="images/phylo-color.png" width=499, height=348>
<A NAME="fig:phylo-color"></A>
</P><P>This viewing mode is particularly handy for exploring larger trees, because the matplotlib
viewer can zoom in on a selected region, thinning out a cluttered graphic.
</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree = Phylo.read("apaf.xml", "phyloxml")
&gt;&gt;&gt; Phylo.draw_graphviz(tree, prog="neato", node_size=0)
</PRE><P>
<IMG SRC="images/phylo-apaf.png" width=519, height=400>
<A NAME="fig:phylo-apaf"></A>
<IMG SRC="images/phylo-apaf-zoom.png" width=506, height=400>
<A NAME="fig:phylo-apaf-zoom"></A>
</P><P>Note that branch lengths are not displayed accurately, because Graphviz ignores them when
creating the node layouts. The branch lengths are retained when exporting a tree as a NetworkX
graph object (<CODE>to_networkx</CODE>), however.</P><P>See the Phylo page on the Biopython wiki (<A HREF="http://biopython.org/wiki/Phylo"><TT>http://biopython.org/wiki/Phylo</TT></A>) for
descriptions and examples of the more advanced functionality in <CODE>draw_ascii</CODE>,
<CODE>draw_graphviz</CODE> and <CODE>to_networkx</CODE>.</P><!--TOC section Using Tree and Clade objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc170">12.4</A>&#XA0;&#XA0;Using Tree and Clade objects</H2><!--SEC END --><P>The <CODE>Tree</CODE> objects produced by <CODE>parse</CODE> and <CODE>read</CODE> are containers for recursive
sub-trees, attached to the <CODE>Tree</CODE> object at the <CODE>root</CODE> attribute (whether or not the
phylogenic tree is actually considered rooted). A <CODE>Tree</CODE> has globally applied information
for the phylogeny, such as rootedness, and a reference to a single <CODE>Clade</CODE>; a
<CODE>Clade</CODE> has node- and clade-specific information, such as branch length, and a list of
its own descendent <CODE>Clade</CODE> instances, attached at the <CODE>clades</CODE> attribute.</P><P>So there is a distinction between <CODE>tree</CODE> and <CODE>tree.root</CODE>. In practice, though, you
rarely need to worry about it. To smooth over the difference, both <CODE>Tree</CODE> and
<CODE>Clade</CODE> inherit from <CODE>TreeMixin</CODE>, which contains the implementations for methods
that would be commonly used to search, inspect or modify a tree or any of its clades. This
means that almost all of the methods supported by <CODE>tree</CODE> are also available on
<CODE>tree.root</CODE> and any clade below it. (<CODE>Clade</CODE> also has a <CODE>root</CODE> property, which
returns the clade object itself.)</P><!--TOC subsection Search and traversal methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc171">12.4.1</A>&#XA0;&#XA0;Search and traversal methods</H3><!--SEC END --><P>For convenience, we provide a couple of simplified methods that return all external or internal
nodes directly as a list:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>get_terminals</TT></B></DT><DD CLASS="dd-description"> makes a list of all of this tree&#X2019;s terminal (leaf) nodes.
</DD><DT CLASS="dt-description"><B><TT>get_nonterminals</TT></B></DT><DD CLASS="dd-description"> makes a list of all of this tree&#X2019;s nonterminal (internal)
nodes.
</DD></DL><P>These both wrap a method with full control over tree traversal, <CODE>find_clades</CODE>. Two more
traversal methods, <CODE>find_elements</CODE> and <CODE>find_any</CODE>, rely on the same core
functionality and accept the same arguments, which we&#X2019;ll call a &#X201C;target specification&#X201D; for
lack of a better description. These specify which objects in the tree will be matched and
returned during iteration. The first argument can be any of the following types:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A <B>TreeElement instance</B>, which tree elements will match by identity &#X2014; so
searching with a Clade instance as the target will find that clade in the tree;</LI><LI CLASS="li-itemize">A <B>string</B>, which matches tree elements&#X2019; string representation &#X2014; in
particular, a clade&#X2019;s <CODE>name</CODE> <I>(added in Biopython 1.56)</I>;</LI><LI CLASS="li-itemize">A <B>class</B> or <B>type</B>, where every tree element of the same type (or
sub-type) will be matched;</LI><LI CLASS="li-itemize">A <B>dictionary</B> where keys are tree element attributes and values are matched to the
corresponding attribute of each tree element. This one gets even more elaborate:<UL CLASS="itemize"><LI CLASS="li-itemize">
If an <TT>int</TT> is given, it matches numerically equal attributes, e.g. 1 will
match 1 or 1.0</LI><LI CLASS="li-itemize">If a boolean is given (True or False), the corresponding attribute value is
evaluated as a boolean and checked for the same</LI><LI CLASS="li-itemize"><TT>None</TT> matches <TT>None</TT></LI><LI CLASS="li-itemize">If a string is given, the value is treated as a regular expression (which must
match the whole string in the corresponding element attribute, not just a prefix). A
given string without special regex characters will match string attributes exactly, so
if you don&#X2019;t use regexes, don&#X2019;t worry about it. For example, in a tree with clade
names Foo1, Foo2 and Foo3, <CODE>tree.find_clades({"name": "Foo1"})</CODE> matches Foo1,
<CODE>{"name": "Foo.*"}</CODE> matches all three clades, and <CODE>{"name": "Foo"}</CODE> doesn&#X2019;t
match anything.</LI></UL><P>Since floating-point arithmetic can produce some strange behavior, we don&#X2019;t support
matching <TT>float</TT>s directly. Instead, use the boolean <TT>True</TT> to match every
element with a nonzero value in the specified attribute, then filter on that attribute
manually with an inequality (or exact number, if you like living dangerously).</P><P>If the dictionary contains multiple entries, a matching element must match each of the
given attribute values &#X2014; think &#X201C;and&#X201D;, not &#X201C;or&#X201D;.</P></LI><LI CLASS="li-itemize">A <B>function</B> taking a single argument (it will be applied to each element in the
tree), returning True or False. For convenience, LookupError, AttributeError and ValueError
are silenced, so this provides another safe way to search for floating-point values in the
tree, or some more complex characteristic.</LI></UL><P>After the target, there are two optional keyword arguments:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>terminal</B></DT><DD CLASS="dd-description"> &#X2014; A boolean value to select for or against terminal clades (a.k.a. leaf
nodes): True searches for only terminal clades, False for non-terminal (internal) clades,
and the default, None, searches both terminal and non-terminal clades, as well as any tree
elements lacking the <CODE>is_terminal</CODE> method.</DD><DT CLASS="dt-description"><B>order</B></DT><DD CLASS="dd-description"> &#X2014; Tree traversal order: <TT>"preorder"</TT> (default) is depth-first search,
<TT>"postorder"</TT> is DFS with child nodes preceding parents, and <TT>"level"</TT> is
breadth-first search.</DD></DL><P>Finally, the methods accept arbitrary keyword arguments which are treated the same way as a
dictionary target specification: keys indicate the name of the element attribute to search for,
and the argument value (string, integer, None or boolean) is compared to the value of each
attribute found. If no keyword arguments are given, then any TreeElement types are matched.
The code for this is generally shorter than passing a dictionary as the target specification:
<CODE>tree.find_clades({"name": "Foo1"})</CODE> can be shortened to
<CODE>tree.find_clades(name="Foo1")</CODE>.</P><P>(In Biopython 1.56 or later, this can be even shorter: <CODE>tree.find_clades("Foo1")</CODE>)</P><P>Now that we&#X2019;ve mastered target specifications, here are the methods used to traverse a tree:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>find_clades</TT></B></DT><DD CLASS="dd-description">
Find each clade containing a matching element. That is, find each element as with
<CODE>find_elements</CODE>, but return the corresponding clade object. (This is usually what you
want.)<P>The result is an iterable through all matching objects, searching depth-first by default.
This is not necessarily the same order as the elements appear in the Newick, Nexus or XML
source file!</P></DD><DT CLASS="dt-description"><B><TT>find_elements</TT></B></DT><DD CLASS="dd-description">
Find all tree elements matching the given attributes, and return the matching elements
themselves. Simple Newick trees don&#X2019;t have complex sub-elements, so this behaves the same
as <CODE>find_clades</CODE> on them. PhyloXML trees often do have complex objects attached to
clades, so this method is useful for extracting those.</DD><DT CLASS="dt-description"><B><TT>find_any</TT></B></DT><DD CLASS="dd-description">
Return the first element found by <CODE>find_elements()</CODE>, or None. This is also useful for
checking whether any matching element exists in the tree, and can be used in a conditional.</DD></DL><P>Two more methods help navigating between nodes in the tree:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>get_path</TT></B></DT><DD CLASS="dd-description">
List the clades directly between the tree root (or current clade) and the given target.
Returns a list of all clade objects along this path, ending with the given target, but
excluding the root clade.</DD><DT CLASS="dt-description"><B><TT>trace</TT></B></DT><DD CLASS="dd-description">
List of all clade object between two targets in this tree. Excluding start, including
finish.</DD></DL><!--TOC subsection Information methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc172">12.4.2</A>&#XA0;&#XA0;Information methods</H3><!--SEC END --><P>These methods provide information about the whole tree (or any clade).</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>common_ancestor</TT></B></DT><DD CLASS="dd-description">
Find the most recent common ancestor of all the given targets. (This will be a Clade object). 
If no target is given, returns the root of the current clade (the one this method is called
from); if 1 target is given, this returns the target itself. However, if any of the
specified targets are not found in the current tree (or clade), an exception is raised.</DD><DT CLASS="dt-description"><B><TT>count_terminals</TT></B></DT><DD CLASS="dd-description">
Counts the number of terminal (leaf) nodes within the tree.</DD><DT CLASS="dt-description"><B><TT>depths</TT></B></DT><DD CLASS="dd-description">
Create a mapping of tree clades to depths. The result is a dictionary where the keys are
all of the Clade instances in the tree, and the values are the distance from the root to
each clade (including terminals). By default the distance is the cumulative branch length
leading to the clade, but with the <CODE>unit_branch_lengths=True</CODE> option, only the number
of branches (levels in the tree) is counted.</DD><DT CLASS="dt-description"><B><TT>distance</TT></B></DT><DD CLASS="dd-description">
Calculate the sum of the branch lengths between two targets. If only one target is
specified, the other is the root of this tree.</DD><DT CLASS="dt-description"><B><TT>total_branch_length</TT></B></DT><DD CLASS="dd-description">
Calculate the sum of all the branch lengths in this tree. This is usually just called the
&#X201C;length&#X201D; of the tree in phylogenetics, but we use a more explicit name to avoid confusion
with Python terminology.</DD></DL><P>The rest of these methods are boolean checks:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>is_bifurcating</TT></B></DT><DD CLASS="dd-description">
True if the tree is strictly bifurcating; i.e. all nodes have either 2 or 0 children
(internal or external, respectively). The root may have 3 descendents and still be
considered part of a bifurcating tree.</DD><DT CLASS="dt-description"><B><TT>is_monophyletic</TT></B></DT><DD CLASS="dd-description">
Test if all of the given targets comprise a complete subclade &#X2014; i.e., there
exists a clade such that its terminals are the same set as the given targets. The targets
should be terminals of the tree. For convenience, this method returns the common ancestor
(MCRA) of the targets if they are monophyletic (instead of the value <CODE>True</CODE>), and
<CODE>False</CODE> otherwise.</DD><DT CLASS="dt-description"><B><TT>is_parent_of</TT></B></DT><DD CLASS="dd-description"> True if target is a descendent of this tree &#X2014; not required
to be a direct descendent. To check direct descendents of a clade, simply use list
membership testing: <CODE>if subclade in clade: ...</CODE></DD><DT CLASS="dt-description"><B><TT>is_preterminal</TT></B></DT><DD CLASS="dd-description"> True if all direct descendents are terminal; False if any
direct descendent is not terminal.</DD></DL><!--TOC subsection Modification methods-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc173">12.4.3</A>&#XA0;&#XA0;Modification methods</H3><!--SEC END --><P>These methods modify the tree in-place. If you want to keep the original tree intact, make a
complete copy of the tree first, using Python&#X2019;s <TT>copy</TT> module:</P><PRE CLASS="verbatim">tree = Phylo.read('example.xml', 'phyloxml')
import copy
newtree = copy.deepcopy(tree)
</PRE><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>collapse</TT></B></DT><DD CLASS="dd-description">
Deletes the target from the tree, relinking its children to its parent.</DD><DT CLASS="dt-description"><B><TT>collapse_all</TT></B></DT><DD CLASS="dd-description">
Collapse all the descendents of this tree, leaving only terminals. Branch lengths are
preserved, i.e. the distance to each terminal stays the same. With a target specification
(see above), collapses only the internal nodes matching the specification.</DD><DT CLASS="dt-description"><B><TT>ladderize</TT></B></DT><DD CLASS="dd-description">
Sort clades in-place according to the number of terminal nodes. Deepest clades are placed
last by default. Use <CODE>reverse=True</CODE> to sort clades deepest-to-shallowest.</DD><DT CLASS="dt-description"><B><TT>prune</TT></B></DT><DD CLASS="dd-description">
Prunes a terminal clade from the tree. If taxon is from a bifurcation, the connecting node
will be collapsed and its branch length added to remaining terminal node. This might no
longer be a meaningful value.</DD><DT CLASS="dt-description"><B><TT>root_with_outgroup</TT></B></DT><DD CLASS="dd-description">
Reroot this tree with the outgroup clade containing the given targets, i.e. the common
ancestor of the outgroup. This method is only available on Tree objects, not Clades.<P>If the outgroup is identical to self.root, no change occurs. If the outgroup clade is
terminal (e.g. a single terminal node is given as the outgroup), a new bifurcating root
clade is created with a 0-length branch to the given outgroup. Otherwise, the internal node
at the base of the outgroup becomes a trifurcating root for the whole tree. If the original
root was bifurcating, it is dropped from the tree.</P><P>In all cases, the total branch length of the tree stays the same.</P></DD><DT CLASS="dt-description"><B><TT>split</TT></B></DT><DD CLASS="dd-description">
Generate <I>n</I> (default 2) new descendants. In a species tree, this is a speciation
event. New clades have the given <CODE>branch_length</CODE> and the same name as this clade&#X2019;s
root plus an integer suffix (counting from 0) &#X2014; for example, splitting a clade named
&#X201C;A&#X201D; produces the sub-clades &#X201C;A0&#X201D; and &#X201C;A1&#X201D;.</DD></DL><P>See the Phylo page on the Biopython wiki (<A HREF="http://biopython.org/wiki/Phylo"><TT>http://biopython.org/wiki/Phylo</TT></A>) for
more examples of using the available methods.</P><!--TOC subsection Features of PhyloXML trees-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc174">12.4.4</A>&#XA0;&#XA0;Features of PhyloXML trees</H3><!--SEC END --><P>
<A NAME="sec:PhyloXML"></A></P><P>The phyloXML file format includes fields for annotating trees with additional data types and
visual cues.</P><P>See the PhyloXML page on the Biopython wiki (<A HREF="http://biopython.org/wiki/PhyloXML"><TT>http://biopython.org/wiki/PhyloXML</TT></A>) for
descriptions and examples of using the additional annotation features provided by PhyloXML.</P><!--TOC section Running external applications-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc175">12.5</A>&#XA0;&#XA0;Running external applications</H2><!--SEC END --><P>
<A NAME="sec:PhyloApps"></A></P><P>While Bio.Phylo doesn&#X2019;t infer trees from alignments itself, there are third-party
programs available that do. These are supported through the module
<TT>Bio.Phylo.Applications</TT>, using the same general framework as
<TT>Bio.Emboss.Applications</TT>, <TT>Bio.Align.Applications</TT> and others.</P><P>Biopython 1.58 introduced a wrapper for PhyML
(<A HREF="http://www.atgc-montpellier.fr/phyml/"><TT>http://www.atgc-montpellier.fr/phyml/</TT></A>). The program accepts an input alignment in
<TT>phylip-relaxed</TT> format (that&#X2019;s Phylip format, but without the 10-character limit
on taxon names) and a variety of options. A quick example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Phylo
&gt;&gt;&gt; from Bio.Phylo.Applications import PhymlCommandline
&gt;&gt;&gt; cmd = PhymlCommandline(input='Tests/Phylip/random.phy')
&gt;&gt;&gt; out_log, err_log = cmd()
</PRE><P>This generates a tree file and a stats file with the names
[<I>input&#XA0;filename</I>]<CODE>_phyml_tree.txt</CODE> and
[<I>input&#XA0;filename</I>]<CODE>_phyml_stats.txt</CODE>. The tree file is in Newick format:</P><PRE CLASS="verbatim">&gt;&gt;&gt; tree = Phylo.read('Tests/Phylip/random.phy_phyml_tree.txt', 'newick')
&gt;&gt;&gt; Phylo.draw_ascii(tree)
</PRE><P>A similar wrapper for RAxML (<A HREF="http://sco.h-its.org/exelixis/software.html"><TT>http://sco.h-its.org/exelixis/software.html</TT></A>)
was added in Biopython 1.60.</P><P>Note that some popular Phylip programs, including <TT>dnaml</TT> and <TT>protml</TT>,
are already available through the EMBOSS wrappers in <TT>Bio.Emboss.Applications</TT> if
you have the Phylip extensions to EMBOSS installed on your system.
See Section&#XA0;<A HREF="#sec:alignment-tools">6.4</A> for some examples and clues on how to use
programs like these.</P><!--TOC section PAML integration-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc176">12.6</A>&#XA0;&#XA0;PAML integration</H2><!--SEC END --><P>
<A NAME="sec:PhyloPAML"></A></P><P>Biopython 1.58 brings support for PAML
(<A HREF="http://abacus.gene.ucl.ac.uk/software/paml.html"><TT>http://abacus.gene.ucl.ac.uk/software/paml.html</TT></A>), a suite of programs for
phylogenetic analysis by maximum likelihood. Currently the programs codeml, baseml and 
yn00 are implemented. Due to PAML&#X2019;s usage of control files rather than command line 
arguments to control runtime options, usage of this wrapper strays from the format of 
other application wrappers in Biopython. </P><P>A typical workflow would be to initialize a PAML object, specifying an alignment file, a
tree file, an output file and a working directory. Next, runtime options are set via the
<TT>set_options()</TT> method or by reading an existing control file. Finally, the
program is run via the <TT>run()</TT> method and the output file is automatically parsed
to a results dictionary.</P><P>Here is an example of typical usage of codeml:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Phylo.PAML import codeml
&gt;&gt;&gt; cml = codeml.Codeml()
&gt;&gt;&gt; cml.alignment = "Tests/PAML/alignment.phylip"
&gt;&gt;&gt; cml.tree = "Tests/PAML/species.tree"
&gt;&gt;&gt; cml.out_file = "results.out"
&gt;&gt;&gt; cml.working_dir = "./scratch"
&gt;&gt;&gt; cml.set_options(seqtype=1,
...         verbose=0,
...         noisy=0,
...         RateAncestor=0,
...         model=0,
...         NSsites=[0, 1, 2],
...         CodonFreq=2,
...         cleandata=1,
...         fix_alpha=1,
...         kappa=4.54006)
&gt;&gt;&gt; results = cml.run()
&gt;&gt;&gt; ns_sites = results.get("NSsites")
&gt;&gt;&gt; m0 = ns_sites.get(0)
&gt;&gt;&gt; m0_params = m0.get("parameters")
&gt;&gt;&gt; print m0_params.get("omega")
</PRE><P>Existing output files may be parsed as well using a module&#X2019;s <TT>read()</TT> function:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; results = codeml.read("Tests/PAML/Results/codeml/codeml_NSsites_all.out")
&gt;&gt;&gt; print results.get("lnL max")
</PRE><P>Detailed documentation for this new module currently lives on the Biopython wiki:
<A HREF="http://biopython.org/wiki/PAML"><TT>http://biopython.org/wiki/PAML</TT></A></P><!--TOC section Future plans-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc177">12.7</A>&#XA0;&#XA0;Future plans</H2><!--SEC END --><P>
<A NAME="sec:PhyloFuture"></A></P><P>Bio.Phylo is under active development. Here are some features we might add in future
releases:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>New methods</B></DT><DD CLASS="dd-description"> 
Generally useful functions for operating on Tree or Clade objects appear on the Biopython
wiki first, so that casual users can test them and decide if they&#X2019;re useful before we add
them to Bio.Phylo:<P><A HREF="http://biopython.org/wiki/Phylo_cookbook"><TT>http://biopython.org/wiki/Phylo_cookbook</TT></A></P></DD><DT CLASS="dt-description"><B>Bio.Nexus port</B></DT><DD CLASS="dd-description">
Much of this module was written during Google Summer of Code 2009, under the auspices of
NESCent, as a project to implement Python support for the phyloXML data format (see
<A HREF="#sec:PhyloXML">12.4.4</A>). Support for Newick and Nexus formats was added by porting part of the
existing Bio.Nexus module to the new classes used by Bio.Phylo.<P>Currently, Bio.Nexus contains some useful features that have not yet been ported to
Bio.Phylo classes &#X2014; notably, calculating a consensus tree. If you find some functionality
lacking in Bio.Phylo, try poking throught Bio.Nexus to see if it&#X2019;s there instead.</P></DD><DT CLASS="dt-description"><B>NeXML support</B></DT><DD CLASS="dd-description"> 
Within the next few releases, we intend to add support for another file format, NeXML. This
is unlikely to change the basic object hierarchy substantially, but could inspire some
additions to the attributes of existing classes.</DD><DT CLASS="dt-description"><B>String representations</B></DT><DD CLASS="dd-description"> 
The string representations of some objects could change in future releases; we&#X2019;re
still determining which &#X201C;informal&#X201D; representations are most useful most often. To
future-proof your code against this, we recommend using the attributes of objects
directly (e.g. <CODE>my_clade.name</CODE>) rather than automatic string conversion
(<CODE>str(my_clade)</CODE>) in scripts that require a consistent result.</DD></DL><P>We&#X2019;re open to any suggestions for improving the functionality and usability of this module;
just let us know on the mailing list or our bug database.</P><!--TOC chapter Sequence motif analysis using Bio.Motif-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc178">Chapter&#XA0;13</A>&#XA0;&#XA0;Sequence motif analysis using Bio.Motif</H1><!--SEC END --><P>
<A NAME="chap:bio_motif"></A></P><P>This chapter gives an overview of the functionality of the
<CODE>Bio.Motif</CODE> package included in Biopython distribution. It is intended
for people who are involved in analysis of sequence motif, so I&#X2019;ll
assume that you are familiar with basic notions of motif analysis. In
case something is unclear, please look into Section&#XA0;<A HREF="#sec:links">13.3</A>
for some relevant links.</P><P>It should be also noted, that <CODE>Bio.Motif</CODE> was based on two
former Biopython modules, <CODE>Bio.AlignAce</CODE> and <CODE>Bio.MEME</CODE>. It provides
most of their functionality with a unified motif object implementation.</P><P>Speaking of other libraries, if you are reading this you might be
interested in the <A HREF="http://fraenkel.mit.edu/TAMO/">TAMO</A>, another python library
designed to deal with sequence motifs. It supports more <EM>de-novo</EM>
motif finders, but it is not a part of Biopython and has some restrictions
on commercial use.</P><!--TOC section Motif objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc179">13.1</A>&#XA0;&#XA0;Motif objects</H2><!--SEC END --><P>
<A NAME="sec:object"></A></P><P>Since we are interested in motif analysis, we need to take a look at
<CODE>Motif</CODE> objects in the first place. For that we need to import 
the Motif library:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Motif
</PRE><P>and we can start creating our first motif objects. Let&#X2019;s create a DNA motif:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; m = Motif.Motif(alphabet=IUPAC.unambiguous_dna)
</PRE><P>This is for now just an empty container, so let&#X2019;s add some sequences to our newly created motif:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; m.add_instance(Seq("TATAA",m.alphabet))
&gt;&gt;&gt; m.add_instance(Seq("TATTA",m.alphabet))
&gt;&gt;&gt; m.add_instance(Seq("TATAA",m.alphabet))
&gt;&gt;&gt; m.add_instance(Seq("TATAA",m.alphabet))
</PRE><P>Now we have a full <CODE>Motif</CODE> instance, so we can try to get some
basic information about it. Let&#X2019;s start with length and consensus
sequence:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; len(m)
5
&gt;&gt;&gt; m.consensus()
Seq('TATAA', IUPACUnambiguousDNA())
</PRE><P>In case of DNA motifs, we can also get a reverse complement of a motif:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; m.reverse_complement().consensus()
Seq('TTATA', IUPACUnambiguousDNA())
&gt;&gt;&gt; for i in m.reverse_complement().instances:
...     print i
TTATA
TAATA
TTATA
TTATA
</PRE><P>We can also calculate the information content of a motif with a simple call:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print "%0.2f" % m.ic()
5.27
</PRE><P>This gives us a number of bits of information provided by the motif,
which tells us how much differs from background.</P><P>The most common representation of a motif is a PWM (Position Weight
Matrix). It summarizes the probabilities of finding any symbol (in
this case nucleotide) in any position of a motif. It can be computed by calling the <CODE>.pwm()</CODE> method:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; m.pwm()
[{'A': 0.05, 'C': 0.05, 'T': 0.85, 'G': 0.05}, 
 {'A': 0.85, 'C': 0.05, 'T': 0.05, 'G': 0.05}, 
 {'A': 0.05, 'C': 0.05, 'T': 0.85, 'G': 0.05}, 
 {'A': 0.65, 'C': 0.05, 'T': 0.25, 'G': 0.05}, 
 {'A': 0.85, 'C': 0.05, 'T': 0.05, 'G': 0.05}]
</PRE><P>The probabilities in the motif&#X2019;s PWM are based on the counts in the
instances, but we can see, that even though there were no Gs and no Cs
in the instances, we still have non-zero probabilities assigned to
them. These come from pseudo-counts which are, roughly speaking, a
commonly used way to acknowledge the incompleteness of our knowledge
and avoid technical problems with calculating logarithms of 0.</P><P>We can control the way that pseudo-counts are added with two
properties of Motif objects <CODE>.background</CODE> is the probability
distribution over all symbols in the alphabet that we assume represents background, non-motif sequences (usually based on the GC content of the respective
genome). It is by default set to a uniform distribution upon creation of a motif:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; m.background  
{'A': 0.25, 'C': 0.25, 'T': 0.25, 'G': 0.25}
</PRE><P>The other parameter is <CODE>.beta</CODE>, which states the amount of
pseudo-counts we should add to the PWM. By default it is set to 1.0,
</P><PRE CLASS="verbatim">&gt;&gt;&gt; m.beta
1.0
</PRE><P>so that the total input of pseudo-counts is equal to that of one instance. </P><P>Using the background distribution and pwm with pseudo-counts added,
it&#X2019;s easy to compute the log-odds ratios, telling us what are the log
odds of a particular symbol to be coming from a motif against the
background. We can use the <CODE>.log_odds()</CODE> method:</P><PRE CLASS="verbatim"> &gt;&gt;&gt; m.log_odds() 
[{'A': -2.3219280948873622, 
  'C': -2.3219280948873622, 
  'T': 1.7655347463629771, 
  'G': -2.3219280948873622}, 
 {'A': 1.7655347463629771, 
  'C': -2.3219280948873622, 
  'T': -2.3219280948873622, 
  'G': -2.3219280948873622}, 
 {'A': -2.3219280948873622, 
  'C': -2.3219280948873622, 
  'T': 1.7655347463629771, 
  'G': -2.3219280948873622}, 
 {'A': 1.3785116232537298, 
  'C': -2.3219280948873622, 
  'T': 0.0, 
  'G': -2.3219280948873622}, 
 {'A': 1.7655347463629771, 
  'C': -2.3219280948873622, 
  'T': -2.3219280948873622, 
  'G': -2.3219280948873622}
]
</PRE><P>Here we can see positive values for symbols more frequent in the motif
than in the background and negative for symbols more frequent in the
background. 0.0 means that it&#X2019;s equally likely to see a symbol in
background and in the motif (e.g. &#X2018;T&#X2019; in the second-last position).</P><!--TOC subsection Reading and writing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc180">13.1.1</A>&#XA0;&#XA0;Reading and writing</H3><!--SEC END --><P>
<A NAME="sec:io"></A></P><P>Creating motifs from instances by hand is a bit boring, so it&#X2019;s
useful to have some I/O functions for reading and writing
motifs. There are no really well established standards for storing
motifs, but there&#X2019;s a couple of formats which are more used than
others. The most important distinction is whether the motif
representation is based on instances or on some version of PWM matrix.
On of the most popular motif databases <A HREF="http://jaspar.genereg.net">JASPAR</A>
stores motifs in both formats, so
let&#X2019;s look at how we can import JASPAR motifs from instances:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Motif
&gt;&gt;&gt; arnt = Motif.read(open("Arnt.sites"),"jaspar-sites")
</PRE><P>and from a count matrix:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; srf = Motif.read(open("SRF.pfm"),"jaspar-pfm")
</PRE><P>The <CODE>arnt</CODE> and <CODE>srf</CODE> motifs can both do the same things for
us, but they use different internal representations of the motif. We
can tell that by inspecting the <CODE>has_counts</CODE> and
<CODE>has_instances</CODE> properties:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; arnt.has_instances
True
&gt;&gt;&gt; srf.has_instances
False
&gt;&gt;&gt; srf.has_counts
True
</PRE><PRE CLASS="verbatim">&gt;&gt;&gt; srf.counts
{'A': [2, 9, 0, 1, 32, 3, 46, 1, 43, 15, 2, 2],
 'C': [1, 33, 45, 45, 1, 1, 0, 0, 0, 1, 0, 1],
 'G': [39, 2, 1, 0, 0, 0, 0, 0, 0, 0, 44, 43],
 'T': [4, 2, 0, 0, 13, 42, 0, 45, 3, 30, 0, 0]}
</PRE><P>There are conversion functions, which can help us convert between
different representations:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; arnt.make_counts_from_instances()
{'A': [8, 38, 0, 0, 0, 0],
 'C': [32, 0, 40, 0, 0, 0],
 'G': [0, 2, 0, 40, 0, 40],
 'T': [0, 0, 0, 0, 40, 0]}

&gt;&gt;&gt; srf.make_instances_from_counts()
[Seq('GGGAAAAAAAGG', IUPACUnambiguousDNA()),
 Seq('GGCCAAATAAGG', IUPACUnambiguousDNA()),
 Seq('GACCAAATAAGG', IUPACUnambiguousDNA()),
....
</PRE><P>The important thing to remember here is that the method
<CODE>make_instances_from_counts()</CODE> creates fake instances, because
usually there are very many possible sets of instances which give rise
to the same pwm, and if we have only the count matrix, we cannot
reconstruct the original one. This does not make any difference if we
are using the PWM as the representation of the motif, but one should
be careful with exporting instances from count-based motifs.</P><P>Speaking of exporting, let&#X2019;s look at export functions. We can export to fasta:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print m.format("fasta")
&gt;instance0
TATAA
&gt;instance1
TATTA
&gt;instance2
TATAA
&gt;instance3
TATAA
</PRE><P>or to TRANSFAC-like matrix format (used by some motif processing software)
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print m.format("transfac")
XX
TY Motif
ID 
BF undef
P0 G A T C
01 0 0 4 0
02 0 4 0 0
03 0 0 4 0
04 0 3 1 0
05 0 4 0 0
XX
</PRE><P>Finally, if we have internet access, we can create a <A HREF="http://weblogo.berkeley.edu">weblogo</A>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; arnt.weblogo("Arnt.png")
</PRE><P>We should get our logo saved as a png in the specified file.</P><!--TOC subsection Searching for instances-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc181">13.1.2</A>&#XA0;&#XA0;Searching for instances</H3><!--SEC END --><P>
<A NAME="sec:search"></A></P><P>The most frequent use for a motif is to find its instances in some
sequence. For the sake of this section, we will use an artificial sequence like this:</P><PRE CLASS="verbatim">test_seq=Seq("TATGATGTAGTATAATATAATTATAA",m.alphabet)
</PRE><P>The simplest way to find instances, is to look for exact matches of
the true instances of the motif:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for pos,seq in m.search_instances(test_seq):
...     print pos,seq.tostring()
... 
10 TATAA
15 TATAA
21 TATAA
</PRE><P>We can do the same with the reverse complement (to find instances on the complementary strand):
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for pos,seq in m.reverse_complement().search_instances(test_seq):
...     print pos,seq.tostring()
... 
12 TAATA
20 TTATA
</PRE><P>It&#X2019;s just as easy to look for positions, giving rise to high log-odds scores against our motif:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for pos,score in m.search_pwm(test_seq,threshold=5.0):
...     print pos,score
... 
10 8.44065060871
-12 7.06213898545
15 8.44065060871
-20 8.44065060871
21 8.44065060871
</PRE><P>You may notice the threshold parameter, here set arbitrarily to
5.0. This is in <I>log</I><SUB>2</SUB>, so we are now looking only for words, which
are 32 times more likely to occur under the motif model than in the
background. The default threshold is 0.0, which selects everything
that looks more like the motif than the background.</P><P>If you want to use a less arbitrary way of selecting thresholds, you
can explore the <CODE>Motif.score_distribution</CODE> class implementing an
distribution of scores for a given motif. Since the space for a score
distribution grows exponentially with motif length, we are using an
approximation with a given precision to keep computation cost manageable:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; sd = Motif.score_distribution(m,precision=10**4)
</PRE><P>The sd object can be used to determine a number of different thresholds.</P><P>We can specify the requested false-positive rate (probability of &#X201C;finding&#X201D; a motif instance in background generated sequence):
</P><PRE CLASS="verbatim">&gt;&gt;&gt; sd.threshold_fpr(0.01)
4.3535838726139886
</PRE><P>or the false-negative rate (probability of &#X201C;not finding&#X201D; an instance generated from the motif):
</P><PRE CLASS="verbatim">&gt;&gt;&gt; sd.threshold_fnr(0.1)
0.26651713652234044
</PRE><P>or a threshold (approximately) satisfying some relation between fpr
and fnr <I>fnr</I>/<I>fpr</I>&#X2243; <I>t</I>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; sd.threshold_balanced(1000)
8.4406506087056368
</PRE><P>or a threshold satisfying (roughly) the equality between the
false-positive rate and the &#X2212;<I>log</I> of the information content (as used
in patser software by Hertz and Stormo).</P><P>For example, in case of our motif, you can get the threshold giving
you exactly the same results (for this sequence) as searching for
instances with balanced threshold with rate of 1000.
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for pos,score in m.search_pwm(test_seq,threshold=sd.threshold_balanced(1000)):
...     print pos,score
... 
10 8.44065060871
15 8.44065060871
-20 8.44065060871
21 8.44065060871
</PRE><!--TOC subsection Comparing motifs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc182">13.1.3</A>&#XA0;&#XA0;Comparing motifs</H3><!--SEC END --><P>
<A NAME="sec:comp"></A>
Once we have more than one motif, we might want to compare them. For
that, we have currently three different methods of <CODE>Bio.Motif</CODE>
objects.</P><P>Before we start comparing motifs, I should point out that motif
boundaries are usually quite arbitrary. This means, that we often need
to compare motifs of different lengths, so comparison needs to involve
some kind of alignment. This means, that we have to take into account two things:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
alignment of motifs
</LI><LI CLASS="li-itemize">some function to compare aligned motifs
</LI></UL><P>
In <CODE>Bio.Motif</CODE> we have 3 different functions for motif
comparison, which are based on the same idea behind motif alignment,
but use different functions to compare aligned motifs. Briefly
speaking, we are using ungapped alignment of PWMs and substitute the
missing columns at the beginning and end of the matrices with
background distribution. All three comparison functions are written in
such a way, that they can be interpreted as distance measures, however
only one (<CODE>dist_dpq</CODE>) satisfies the triangle inequality. All of
them return the minimal distance and the corresponding offset between
motifs.</P><P>To show how these functions work, let us first load another motif,
which is similar to our test motif <CODE>m</CODE>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; ubx=Motif.read(open("Ubx.pfm"),"jaspar-pfm")
&lt;Bio.Motif.Motif.Motif object at 0xc29b90&gt;
&gt;&gt;&gt; ubx.consensus()
Seq('TAAT', IUPACUnambiguousDNA())
</PRE><P>The first function we&#X2019;ll use to compare these motifs is based on
Pearson correlation. Since we want it to resemble a distance
measure, we actually take 1&#X2212;<I>r</I>, where <I>r</I> is the Pearson correlation
coefficient (PCC):
</P><PRE CLASS="verbatim">&gt;&gt;&gt; m.dist_pearson(ubx)
(0.41740393308237722, 2)
</PRE><P>This means, that the best PCC between motif <CODE>m</CODE> and <CODE>Ubx</CODE> is obtained with the following alignment:
</P><PRE CLASS="verbatim">bbTAAT
TATAAb
</PRE><P>where <CODE>b</CODE> stands for background distribution. The PCC itself is
roughly 1&#X2212;0.42=0.58. If we try the reverse complement of the Ubx motif:</P><PRE CLASS="verbatim">&gt;&gt;&gt; m.dist_pearson(ubx.reverse_complement())
(0.25784180151584823, 1)
</PRE><P>We can see that the PCC is better (almost 0.75), and the alignment is also different:
</P><PRE CLASS="verbatim">bATTA
TATAA
</PRE><P>There are two other functions: <CODE>dist_dpq</CODE>, which is a true metric (satisfying traingle inequality) based on the Kullback-Leibler divergence 
</P><PRE CLASS="verbatim">&gt;&gt;&gt; m.dist_dpq(ubx.reverse_complement())
(0.49292358382899853, 1)
</PRE><P>and the <CODE>dist_product</CODE> method, which is based on the product of
probabilities which can be interpreted as the probability of
independently generating the same instance by both motifs.</P><PRE CLASS="verbatim">&gt;&gt;&gt; m.dist_product(ubx.reverse_complement())
(0.16224587301064275, 1)
</PRE><!--TOC section <EM>De novo</EM> motif finding-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc183">13.2</A>&#XA0;&#XA0;<EM>De novo</EM> motif finding</H2><!--SEC END --><P>
<A NAME="sec:find"></A></P><P>Currently, biopython has only limited support for <EM>de novo</EM> motif
finding. Namely, we support running and parsing of AlignAce and
MEME. Since the number of motif finding tools is growing rapidly, 
contributions of new parsers are welcome. </P><!--TOC subsection MEME-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc184">13.2.1</A>&#XA0;&#XA0;MEME</H3><!--SEC END --><P>
<A NAME="sec:meme"></A></P><P>Let&#X2019;s assume, you have run MEME on sequences of your choice with your
favorite parameters and saved the output in the file
<CODE>meme.out</CODE>. You can retrieve the motifs reported by MEME by
running the following piece of code:</P><PRE CLASS="verbatim">&gt;&gt;&gt; motifsM = list(Motif.parse(open("meme.out"),"MEME"))
&gt;&gt;&gt; motifsM
[&lt;Bio.Motif.MEMEMotif.MEMEMotif object at 0xc356b0&gt;]
</PRE><P>Besides the most wanted list of motifs, the result object contains more useful information, accessible through properties with self-explanatory names:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>.alphabet</CODE>
</LI><LI CLASS="li-itemize"><CODE>.datafile</CODE>
</LI><LI CLASS="li-itemize"><CODE>.sequence_names</CODE>
</LI><LI CLASS="li-itemize"><CODE>.version</CODE>
</LI><LI CLASS="li-itemize"><CODE>.command</CODE>
</LI></UL><P>The motifs returned by MEMEParser can be treated exactly like regular
Motif objects (with instances), they also provide some extra
functionality, by adding additional information about the instances. </P><PRE CLASS="verbatim">&gt;&gt;&gt; motifsM[0].consensus()
Seq('CTCAATCGTA', IUPACUnambiguousDNA())

&gt;&gt;&gt; motifsM[0].instances[0].pvalue
8.71e-07
&gt;&gt;&gt; motifsM[0].instances[0].sequence_name
'SEQ10;'
&gt;&gt;&gt; motifsM[0].instances[0].start
3
&gt;&gt;&gt; motifsM[0].instances[0].strand
'+'
</PRE><!--TOC subsection AlignAce-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc185">13.2.2</A>&#XA0;&#XA0;AlignAce</H3><!--SEC END --><P>
<A NAME="sec:alignace"></A></P><P>We can do very similar things with AlignACE program. Assume, you have
your output in the file <CODE>alignace.out</CODE>. You can parse your output
with the following code:</P><PRE CLASS="verbatim">&gt;&gt;&gt; motifsA=list(Motif.parse(open("alignace.out"),"AlignAce"))
</PRE><P>Again, your motifs behave as they should:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; motifsA[0].consensus()
Seq('TCTACGATTGAG', IUPACUnambiguousDNA())
</PRE><P>In fact you can even see, that AlignAce found a very similar motif as
MEME, it is just a longer version of a reverse complement of MEME
motif:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; motifsM[0].reverse_complement().consensus()
Seq('TACGATTGAG', IUPACUnambiguousDNA())
</PRE><P>If you have AlignAce installed on the same machine, you can also run
it directly from Biopython. Short example of how this can be done is
shown below (other parameters can be specified as keyword parameters):</P><PRE CLASS="verbatim">&gt;&gt;&gt; command="/opt/bin/AlignACE"
&gt;&gt;&gt; input_file="test.fa"
&gt;&gt;&gt; from Bio.Motif.Applications import AlignAceCommandline
&gt;&gt;&gt; cmd = AlignAceCommandline(cmd=command,input=input_file,gcback=0.6,numcols=10)
&gt;&gt;&gt; stdout,stderr= cmd()
</PRE><P>Since AlignAce prints all its output to standard output, you can get
to your motifs by parsing the first part of the result:
</P><PRE CLASS="verbatim">motifs=list(Motif.parse(stdout,"AlignAce"))
</PRE><!--TOC section Useful links -->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc186">13.3</A>&#XA0;&#XA0;Useful links </H2><!--SEC END --><P>
<A NAME="sec:links"></A></P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="http://en.wikipedia.org/wiki/Sequence_motif">Sequence motif</A> in wikipedia
</LI><LI CLASS="li-itemize"><A HREF="http://en.wikipedia.org/wiki/Position_weight_matrix">PWM</A> in wikipedia
</LI><LI CLASS="li-itemize"><A HREF="http://en.wikipedia.org/wiki/Consensus_sequence">Consensus sequence</A> in wikipedia
</LI><LI CLASS="li-itemize"><A HREF="http://bio.cs.washington.edu/assessment/">Comparison of different motif finding programs</A> 
</LI></UL><!--TOC chapter Supervised learning methods-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc187">Chapter&#XA0;14</A>&#XA0;&#XA0;Supervised learning methods</H1><!--SEC END --><P>Note the supervised learning methods described in this chapter all require Numerical Python (numpy) to be installed.</P><!--TOC section The Logistic Regression Model-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc188">14.1</A>&#XA0;&#XA0;The Logistic Regression Model</H2><!--SEC END --><P>
<A NAME="sec:LogisticRegression"></A></P><!--TOC subsection Background and Purpose-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc189">14.1.1</A>&#XA0;&#XA0;Background and Purpose</H3><!--SEC END --><P>Logistic regression is a supervised learning approach that attempts to distinguish <I>K</I> classes from each other using a weighted sum of some predictor variables <I>x</I><SUB><I>i</I></SUB>. The logistic regression model is used to calculate the weights &#X3B2;<SUB><I>i</I></SUB> of the predictor variables. In Biopython, the logistic regression model is currently implemented for two classes only (<I>K</I> = 2); the number of predictor variables has no predefined limit.</P><P>As an example, let&#X2019;s try to predict the operon structure in bacteria. An operon is a set of adjacent genes on the same strand of DNA that are transcribed into a single mRNA molecule. Translation of the single mRNA molecule then yields the individual proteins. For <I>Bacillus subtilis</I>, whose data we will be using, the average number of genes in an operon is about 2.4.</P><P>As a first step in understanding gene regulation in bacteria, we need to know the operon structure. For about 10% of the genes in <I>Bacillus subtilis</I>, the operon structure is known from experiments. A supervised learning method can be used to predict the operon structure for the remaining 90% of the genes.</P><P>For such a supervised learning approach, we need to choose some predictor variables <I>x</I><SUB><I>i</I></SUB> that can be measured easily and are somehow related to the operon structure. One predictor variable might be the distance in base pairs between genes. Adjacent genes belonging to the same operon tend to be separated by a relatively short distance, whereas adjacent genes in different operons tend to have a larger space between them to allow for promoter and terminator sequences. Another predictor variable is based on gene expression measurements. By definition, genes belonging to the same operon have equal gene expression profiles, while genes in different operons are expected to have different expression profiles. In practice, the measured expression profiles of genes in the same operon are not quite identical due to the presence of measurement errors. To assess the similarity in the gene expression profiles, we assume that the measurement errors follow a normal distribution and calculate the corresponding log-likelihood score.</P><P>We now have two predictor variables that we can use to predict if two adjacent genes on the same strand of DNA belong to the same operon:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>x</I><SUB>1</SUB>: the number of base pairs between them;
</LI><LI CLASS="li-itemize"><I>x</I><SUB>2</SUB>: their similarity in expression profile.
</LI></UL><P>In a logistic regression model, we use a weighted sum of these two predictors to calculate a joint score <I>S</I>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<I>S</I>&#XA0;=&#XA0;&#X3B2;<SUB>0</SUB>&#XA0;+&#XA0;&#X3B2;<SUB>1</SUB>&#XA0;<I>x</I><SUB>1</SUB>&#XA0;+&#XA0;&#X3B2;<SUB>2</SUB>&#XA0;<I>x</I><SUB>2</SUB>.
&#XA0;&#XA0;&#XA0;&#XA0;(14.1)</TD></TR>
</TABLE><P>
The logistic regression model gives us appropriate values for the parameters &#X3B2;<SUB>0</SUB>, &#X3B2;<SUB>1</SUB>, &#X3B2;<SUB>2</SUB> using two sets of example genes:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
OP: Adjacent genes, on the same strand of DNA, known to belong to the same operon;
</LI><LI CLASS="li-itemize">NOP: Adjacent genes, on the same strand of DNA, known to belong to different operons.
</LI></UL><P>In the logistic regression model, the probability of belonging to a class depends on the score via the logistic function. For the two classes OP and NOP, we can write this as
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">


&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>Pr(<I>OP</I>|<I>x</I><SUB>1</SUB>,&#XA0;<I>x</I><SUB>2</SUB>)</TD><TD ALIGN=center NOWRAP>&#XA0;=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#XA0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">exp(&#X3B2;<SUB>0</SUB>&#XA0;+&#XA0;&#X3B2;<SUB>1</SUB>&#XA0;<I>x</I><SUB>1</SUB>&#XA0;+&#XA0;&#X3B2;<SUB>2</SUB>&#XA0;<I>x</I><SUB>2</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+exp(&#X3B2;<SUB>0</SUB>&#XA0;+&#XA0;&#X3B2;<SUB>1</SUB>&#XA0;<I>x</I><SUB>1</SUB>&#XA0;+&#XA0;&#X3B2;<SUB>2</SUB>&#XA0;<I>x</I><SUB>2</SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#XA0;<A NAME="eq:OP">&#XA0;</A>&#XA0;</TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>&#XA0;&#XA0;&#XA0;&#XA0;(14.2)</TD></TR>
<TR><TD ALIGN=right NOWRAP>Pr(<I>NOP</I>|<I>x</I><SUB>1</SUB>,&#XA0;<I>x</I><SUB>2</SUB>)</TD><TD ALIGN=center NOWRAP>&#XA0;=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#XA0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+exp(&#X3B2;<SUB>0</SUB>&#XA0;+&#XA0;&#X3B2;<SUB>1</SUB>&#XA0;<I>x</I><SUB>1</SUB>&#XA0;+&#XA0;&#X3B2;<SUB>2</SUB>&#XA0;<I>x</I><SUB>2</SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#XA0;<A NAME="eq:NOP">&#XA0;</A>&#XA0;
</TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>&#XA0;&#XA0;&#XA0;&#XA0;(14.3)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Using a set of gene pairs for which it is known whether they belong to the same operon (class OP) or to different operons (class NOP), we can calculate the weights &#X3B2;<SUB>0</SUB>, &#X3B2;<SUB>1</SUB>, &#X3B2;<SUB>2</SUB> by maximizing the log-likelihood corresponding to the probability functions (<A HREF="#eq:OP">14.2</A>) and (<A HREF="#eq:NOP">14.3</A>).</P><!--TOC subsection Training the logistic regression model-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc190">14.1.2</A>&#XA0;&#XA0;Training the logistic regression model</H3><!--SEC END --><P>
<A NAME="subsec:LogisticRegressionTraining"></A></P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 14.1: Adjacent gene pairs known to belong to the same operon (class OP) or to different operons (class NOP). Intergene distances are negative if the two genes overlap.</TD></TR>
</TABLE></DIV>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>Gene pair</TD><TD ALIGN=center NOWRAP>Intergene distance (<I>x</I><SUB>1</SUB>)</TD><TD ALIGN=center NOWRAP>Gene expression score (<I>x</I><SUB>2</SUB>)</TD><TD ALIGN=center NOWRAP>Class</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>cotJA</I> &#X2014; <I>cotJB</I></TD><TD ALIGN=center NOWRAP>-53</TD><TD ALIGN=center NOWRAP>-200.78</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yesK</I> &#X2014; <I>yesL</I></TD><TD ALIGN=center NOWRAP>117</TD><TD ALIGN=center NOWRAP>-267.14</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>lplA</I> &#X2014; <I>lplB</I></TD><TD ALIGN=center NOWRAP>57</TD><TD ALIGN=center NOWRAP>-163.47</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>lplB</I> &#X2014; <I>lplC</I></TD><TD ALIGN=center NOWRAP>16</TD><TD ALIGN=center NOWRAP>-190.30</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>lplC</I> &#X2014; <I>lplD</I></TD><TD ALIGN=center NOWRAP>11</TD><TD ALIGN=center NOWRAP>-220.94</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>lplD</I> &#X2014; <I>yetF</I></TD><TD ALIGN=center NOWRAP>85</TD><TD ALIGN=center NOWRAP>-193.94</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yfmT</I> &#X2014; <I>yfmS</I></TD><TD ALIGN=center NOWRAP>16</TD><TD ALIGN=center NOWRAP>-182.71</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yfmF</I> &#X2014; <I>yfmE</I></TD><TD ALIGN=center NOWRAP>15</TD><TD ALIGN=center NOWRAP>-180.41</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>citS</I> &#X2014; <I>citT</I></TD><TD ALIGN=center NOWRAP>-26</TD><TD ALIGN=center NOWRAP>-181.73</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>citM</I> &#X2014; <I>yflN</I></TD><TD ALIGN=center NOWRAP>58</TD><TD ALIGN=center NOWRAP>-259.87</TD><TD ALIGN=center NOWRAP>OP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yfiI</I> &#X2014; <I>yfiJ</I></TD><TD ALIGN=center NOWRAP>126</TD><TD ALIGN=center NOWRAP>-414.53</TD><TD ALIGN=center NOWRAP>NOP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>lipB</I> &#X2014; <I>yfiQ</I></TD><TD ALIGN=center NOWRAP>191</TD><TD ALIGN=center NOWRAP>-249.57</TD><TD ALIGN=center NOWRAP>NOP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yfiU</I> &#X2014; <I>yfiV</I></TD><TD ALIGN=center NOWRAP>113</TD><TD ALIGN=center NOWRAP>-265.28</TD><TD ALIGN=center NOWRAP>NOP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yfhH</I> &#X2014; <I>yfhI</I></TD><TD ALIGN=center NOWRAP>145</TD><TD ALIGN=center NOWRAP>-312.99</TD><TD ALIGN=center NOWRAP>NOP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>cotY</I> &#X2014; <I>cotX</I></TD><TD ALIGN=center NOWRAP>154</TD><TD ALIGN=center NOWRAP>-213.83</TD><TD ALIGN=center NOWRAP>NOP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yjoB</I> &#X2014; <I>rapA</I></TD><TD ALIGN=center NOWRAP>147</TD><TD ALIGN=center NOWRAP>-380.85</TD><TD ALIGN=center NOWRAP>NOP</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>ptsI</I> &#X2014; <I>splA</I></TD><TD ALIGN=center NOWRAP>93</TD><TD ALIGN=center NOWRAP>-291.13</TD><TD ALIGN=center NOWRAP>NOP</TD></TR>
</TABLE>
<A NAME="table:training"></A>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Table <A HREF="#table:training">14.1</A> lists some of the <I>Bacillus subtilis</I> gene pairs for which the operon structure is known.
Let&#X2019;s calculate the logistic regression model from these data:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import LogisticRegression
&gt;&gt;&gt; xs = [[-53, -200.78],
          [117, -267.14],
          [57, -163.47],
          [16, -190.30],
          [11, -220.94],
          [85, -193.94],
          [16, -182.71],
          [15, -180.41],
          [-26, -181.73],
          [58, -259.87],
          [126, -414.53],
          [191, -249.57],
          [113, -265.28],
          [145, -312.99],
          [154, -213.83],
          [147, -380.85],
          [93, -291.13]]
&gt;&gt;&gt; ys = [1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0]
&gt;&gt;&gt; model = LogisticRegression.train(xs, ys)
</PRE><P>Here, <CODE>xs</CODE> and <CODE>ys</CODE> are the training data: <CODE>xs</CODE> contains the predictor variables for each gene pair, and <CODE>ys</CODE> specifies if the gene pair belongs to the same operon (<CODE>1</CODE>, class OP) or different operons (<CODE>0</CODE>, class NOP). The resulting logistic regression model is stored in <CODE>model</CODE>, which contains the weights &#X3B2;<SUB>0</SUB>, &#X3B2;<SUB>1</SUB>, and &#X3B2;<SUB>2</SUB>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; model.beta
[8.9830290157144681, -0.035968960444850887, 0.02181395662983519]
</PRE><P>Note that &#X3B2;<SUB>1</SUB> is negative, as gene pairs with a shorter intergene distance have a higher probability of belonging to the same operon (class OP). On the other hand, &#X3B2;<SUB>2</SUB> is positive, as gene pairs belonging to the same operon typically have a higher similarity score of their gene expression profiles.
The parameter &#X3B2;<SUB>0</SUB> is positive due to the higher prevalence of operon gene pairs than non-operon gene pairs in the training data.</P><P>The function <CODE>train</CODE> has two optional arguments: <CODE>update_fn</CODE> and <CODE>typecode</CODE>. The <CODE>update_fn</CODE> can be used to specify a callback function, taking as arguments the iteration number and the log-likelihood. With the callback function, we can for example track the progress of the model calculation (which uses a Newton-Raphson iteration to maximize the log-likelihood function of the logistic regression model):</P><PRE CLASS="verbatim">&gt;&gt;&gt; def show_progress(iteration, loglikelihood):
        print "Iteration:", iteration, "Log-likelihood function:", loglikelihood
&gt;&gt;&gt;
&gt;&gt;&gt; model = LogisticRegression.train(xs, ys, update_fn=show_progress)
Iteration: 0 Log-likelihood function: -11.7835020695
Iteration: 1 Log-likelihood function: -7.15886767672
Iteration: 2 Log-likelihood function: -5.76877209868
Iteration: 3 Log-likelihood function: -5.11362294338
Iteration: 4 Log-likelihood function: -4.74870642433
Iteration: 5 Log-likelihood function: -4.50026077146
Iteration: 6 Log-likelihood function: -4.31127773737
Iteration: 7 Log-likelihood function: -4.16015043396
Iteration: 8 Log-likelihood function: -4.03561719785
Iteration: 9 Log-likelihood function: -3.93073282192
Iteration: 10 Log-likelihood function: -3.84087660929
Iteration: 11 Log-likelihood function: -3.76282560605
Iteration: 12 Log-likelihood function: -3.69425027154
Iteration: 13 Log-likelihood function: -3.6334178602
Iteration: 14 Log-likelihood function: -3.57900855837
Iteration: 15 Log-likelihood function: -3.52999671386
Iteration: 16 Log-likelihood function: -3.48557145163
Iteration: 17 Log-likelihood function: -3.44508206139
Iteration: 18 Log-likelihood function: -3.40799948447
Iteration: 19 Log-likelihood function: -3.3738885624
Iteration: 20 Log-likelihood function: -3.3423876581
Iteration: 21 Log-likelihood function: -3.31319343769
Iteration: 22 Log-likelihood function: -3.2860493346
Iteration: 23 Log-likelihood function: -3.2607366863
Iteration: 24 Log-likelihood function: -3.23706784091
Iteration: 25 Log-likelihood function: -3.21488073614
Iteration: 26 Log-likelihood function: -3.19403459259
Iteration: 27 Log-likelihood function: -3.17440646052
Iteration: 28 Log-likelihood function: -3.15588842703
Iteration: 29 Log-likelihood function: -3.13838533947
Iteration: 30 Log-likelihood function: -3.12181293595
Iteration: 31 Log-likelihood function: -3.10609629966
Iteration: 32 Log-likelihood function: -3.09116857282
Iteration: 33 Log-likelihood function: -3.07696988017
Iteration: 34 Log-likelihood function: -3.06344642288
Iteration: 35 Log-likelihood function: -3.05054971191
Iteration: 36 Log-likelihood function: -3.03823591619
Iteration: 37 Log-likelihood function: -3.02646530573
Iteration: 38 Log-likelihood function: -3.01520177394
Iteration: 39 Log-likelihood function: -3.00441242601
Iteration: 40 Log-likelihood function: -2.99406722296
Iteration: 41 Log-likelihood function: -2.98413867259
</PRE><P>The iteration stops once the increase in the log-likelihood function is less than 0.01. If no convergence is reached after 500 iterations, the <CODE>train</CODE> function returns with an <CODE>AssertionError</CODE>.</P><P>The optional keyword <CODE>typecode</CODE> can almost always be ignored. This keyword allows the user to choose the type of Numeric matrix to use. In particular, to avoid memory problems for very large problems, it may be necessary to use single-precision floats (Float8, Float16, etc.) rather than double, which is used by default.</P><!--TOC subsection Using the logistic regression model for classification-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc191">14.1.3</A>&#XA0;&#XA0;Using the logistic regression model for classification</H3><!--SEC END --><P>Classification is performed by calling the <CODE>classify</CODE> function. Given a logistic regression model and the values for <I>x</I><SUB>1</SUB> and <I>x</I><SUB>2</SUB> (e.g. for a gene pair of unknown operon structure), the <CODE>classify</CODE> function returns <CODE>1</CODE> or <CODE>0</CODE>, corresponding to class OP and class NOP, respectively. For example, let&#X2019;s consider the gene pairs <I>yxcE</I>, <I>yxcD</I> and <I>yxiB</I>, <I>yxiA</I>:</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Table 14.2: Adjacent gene pairs of unknown operon status.</TD></TR>
</TABLE></DIV>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>Gene pair</TD><TD ALIGN=center NOWRAP>Intergene distance <I>x</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>Gene expression score <I>x</I><SUB>2</SUB></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yxcE</I> &#X2014; <I>yxcD</I></TD><TD ALIGN=center NOWRAP>6</TD><TD ALIGN=center NOWRAP>-173.143442352</TD></TR>
<TR><TD ALIGN=center NOWRAP><I>yxiB</I> &#X2014; <I>yxiA</I></TD><TD ALIGN=center NOWRAP>309</TD><TD ALIGN=center NOWRAP>-271.005880394</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The logistic regression model classifies <I>yxcE</I>, <I>yxcD</I> as belonging to the same operon (class OP), while <I>yxiB</I>, <I>yxiA</I> are predicted to belong to different operons:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print "yxcE, yxcD:", LogisticRegression.classify(model, [6,-173.143442352])
yxcE, yxcD: 1
&gt;&gt;&gt; print "yxiB, yxiA:", LogisticRegression.classify(model, [309, -271.005880394])
yxiB, yxiA: 0
</PRE><P>(which, by the way, agrees with the biological literature).</P><P>To find out how confident we can be in these predictions, we can call the <CODE>calculate</CODE> function to obtain the probabilities (equations (<A HREF="#eq:OP">14.2</A>) and <A HREF="#eq:NOP">14.3</A>) for class OP and NOP. For <I>yxcE</I>, <I>yxcD</I> we find
</P><PRE CLASS="verbatim">&gt;&gt;&gt; q, p = LogisticRegression.calculate(model, [6,-173.143442352])
&gt;&gt;&gt; print "class OP: probability =", p, "class NOP: probability =", q
class OP: probability = 0.993242163503 class NOP: probability = 0.00675783649744
</PRE><P>and for <I>yxiB</I>, <I>yxiA</I>
</P><PRE CLASS="verbatim">&gt;&gt;&gt; q, p = LogisticRegression.calculate(model, [309, -271.005880394])
&gt;&gt;&gt; print "class OP: probability =", p, "class NOP: probability =", q
class OP: probability = 0.000321211251817 class NOP: probability = 0.999678788748
</PRE><P>To get some idea of the prediction accuracy of the logistic regression model, we can apply it to the training data:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for i in range(len(ys)):
        print "True:", ys[i], "Predicted:", LogisticRegression.classify(model, xs[i])
True: 1 Predicted: 1
True: 1 Predicted: 0
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
</PRE><P>showing that the prediction is correct for all but one of the gene pairs. A more reliable estimate of the prediction accuracy can be found from a leave-one-out analysis, in which the model is recalculated from the training data after removing the gene to be predicted:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for i in range(len(ys)):
        model = LogisticRegression.train(xs[:i]+xs[i+1:], ys[:i]+ys[i+1:])
        print "True:", ys[i], "Predicted:", LogisticRegression.classify(model, xs[i])
True: 1 Predicted: 1
True: 1 Predicted: 0
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 1
True: 0 Predicted: 0
True: 0 Predicted: 0
</PRE><P>The leave-one-out analysis shows that the prediction of the logistic regression model is incorrect for only two of the gene pairs, which corresponds to a prediction accuracy of 88%.</P><!--TOC subsection Logistic Regression, Linear Discriminant Analysis, and Support Vector Machines-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc192">14.1.4</A>&#XA0;&#XA0;Logistic Regression, Linear Discriminant Analysis, and Support Vector Machines</H3><!--SEC END --><P>The logistic regression model is similar to linear discriminant analysis. In linear discriminant analysis, the class probabilities also follow equations (<A HREF="#eq:OP">14.2</A>) and (<A HREF="#eq:NOP">14.3</A>). However, instead of estimating the coefficients &#X3B2; directly, we first fit a normal distribution to the predictor variables <I>x</I>. The coefficients &#X3B2; are then calculated from the means and covariances of the normal distribution. If the distribution of <I>x</I> is indeed normal, then we expect linear discriminant analysis to perform better than the logistic regression model. The logistic regression model, on the other hand, is more robust to deviations from normality.</P><P>Another similar approach is a support vector machine with a linear kernel. Such an SVM also uses a linear combination of the predictors, but estimates the coefficients &#X3B2; from the predictor variables <I>x</I> near the boundary region between the classes. If the logistic regression model (equations (<A HREF="#eq:OP">14.2</A>) and (<A HREF="#eq:NOP">14.3</A>)) is a good description for <I>x</I> away from the boundary region, we expect the logistic regression model to perform better than an SVM with a linear kernel, as it relies on more data. If not, an SVM with a linear kernel may perform better.</P><P>Trevor Hastie, Robert Tibshirani, and Jerome Friedman: <I>The Elements of Statistical Learning. Data Mining, Inference, and Prediction</I>. Springer Series in Statistics, 2001. Chapter 4.4.</P><!--TOC section <I>k</I>-Nearest Neighbors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc193">14.2</A>&#XA0;&#XA0;<I>k</I>-Nearest Neighbors</H2><!--SEC END --><!--TOC subsection Background and purpose-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc194">14.2.1</A>&#XA0;&#XA0;Background and purpose</H3><!--SEC END --><P>The <I>k</I>-nearest neighbors method is a supervised learning approach that does not need to fit a model to the data. Instead, data points are classified based on the categories of the <I>k</I> nearest neighbors in the training data set.</P><P>In Biopython, the <I>k</I>-nearest neighbors method is available in <CODE>Bio.kNN</CODE>. To illustrate the use of the <I>k</I>-nearest neighbor method in Biopython, we will use the same operon data set as in section <A HREF="#sec:LogisticRegression">14.1</A>.</P><!--TOC subsection Initializing a <I>k</I>-nearest neighbors model-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc195">14.2.2</A>&#XA0;&#XA0;Initializing a <I>k</I>-nearest neighbors model</H3><!--SEC END --><P>Using the data in Table <A HREF="#table:training">14.1</A>, we create and initialize a <I>k</I>-nearest neighbors model as follows:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import kNN
&gt;&gt;&gt; k = 3
&gt;&gt;&gt; model = kNN.train(xs, ys, k)
</PRE><P>where <CODE>xs</CODE> and <CODE>ys</CODE> are the same as in Section <A HREF="#subsec:LogisticRegressionTraining">14.1.2</A>. Here, <CODE>k</CODE> is the number of neighbors <I>k</I> that will be considered for the classification. For classification into two classes, choosing an odd number for <I>k</I> lets you avoid tied votes. The function name <CODE>train</CODE> is a bit of a misnomer, since no model training is done: this function simply stores <CODE>xs</CODE>, <CODE>ys</CODE>, and <CODE>k</CODE> in <CODE>model</CODE>.</P><!--TOC subsection Using a <I>k</I>-nearest neighbors model for classification-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc196">14.2.3</A>&#XA0;&#XA0;Using a <I>k</I>-nearest neighbors model for classification</H3><!--SEC END --><P>To classify new data using the <I>k</I>-nearest neighbors model, we use the <CODE>classify</CODE> function. This function takes a data point (<I>x</I><SUB>1</SUB>,<I>x</I><SUB>2</SUB>) and finds the <I>k</I>-nearest neighbors in the training data set <CODE>xs</CODE>. The data point (<I>x</I><SUB>1</SUB>, <I>x</I><SUB>2</SUB>) is then classified based on which category (<CODE>ys</CODE>) occurs most among the <I>k</I> neighbors.</P><P>For the example of the gene pairs <I>yxcE</I>, <I>yxcD</I> and <I>yxiB</I>, <I>yxiA</I>, we find:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; x = [6, -173.143442352]
&gt;&gt;&gt; print "yxcE, yxcD:", kNN.classify(model, x)
yxcE, yxcD: 1
&gt;&gt;&gt; x = [309, -271.005880394]
&gt;&gt;&gt; print "yxiB, yxiA:", kNN.classify(model, x)
yxiB, yxiA: 0
</PRE><P>In agreement with the logistic regression model, <I>yxcE</I>, <I>yxcD</I> are classified as belonging to the same operon (class OP), while <I>yxiB</I>, <I>yxiA</I> are predicted to belong to different operons.</P><P>The <CODE>classify</CODE> function lets us specify both a distance function and a weight function as optional arguments. The distance function affects which <I>k</I> neighbors are chosen as the nearest neighbors, as these are defined as the neighbors with the smallest distance to the query point (<I>x</I>, <I>y</I>). By default, the Euclidean distance is used. Instead, we could for example use the city-block (Manhattan) distance:</P><PRE CLASS="verbatim">&gt;&gt;&gt; def cityblock(x1, x2):
...    assert len(x1)==2
...    assert len(x2)==2
...    distance = abs(x1[0]-x2[0]) + abs(x1[1]-x2[1])
...    return distance
...
&gt;&gt;&gt; x = [6, -173.143442352]
&gt;&gt;&gt; print "yxcE, yxcD:", kNN.classify(model, x, distance_fn = cityblock)
yxcE, yxcD: 1
</PRE><P>The weight function can be used for weighted voting. For example, we may want to give closer neighbors a higher weight than neighbors that are further away:</P><PRE CLASS="verbatim">&gt;&gt;&gt; def weight(x1, x2):
...    assert len(x1)==2
...    assert len(x2)==2
...    return exp(-abs(x1[0]-x2[0]) - abs(x1[1]-x2[1]))
...
&gt;&gt;&gt; x = [6, -173.143442352]
&gt;&gt;&gt; print "yxcE, yxcD:", kNN.classify(model, x, weight_fn = weight)
yxcE, yxcD: 1
</PRE><P>By default, all neighbors are given an equal weight.</P><P>To find out how confident we can be in these predictions, we can call the <CODE>calculate</CODE> function, which will calculate the total weight assigned to the classes OP and NOP. For the default weighting scheme, this reduces to the number of neighbors in each category. For <I>yxcE</I>, <I>yxcD</I>, we find
</P><PRE CLASS="verbatim">&gt;&gt;&gt; x = [6, -173.143442352]
&gt;&gt;&gt; weight = kNN.calculate(model, x)
&gt;&gt;&gt; print "class OP: weight =", weight[0], "class NOP: weight =", weight[1]
class OP: weight = 0.0 class NOP: weight = 3.0
</PRE><P>which means that all three neighbors of <CODE>x1</CODE>, <CODE>x2</CODE> are in the NOP class. As another example, for <I>yesK</I>, <I>yesL</I> we find</P><PRE CLASS="verbatim">&gt;&gt;&gt; x = [117, -267.14]
&gt;&gt;&gt; weight = kNN.calculate(model, x)
&gt;&gt;&gt; print "class OP: weight =", weight[0], "class NOP: weight =", weight[1]
class OP: weight = 2.0 class NOP: weight = 1.0
</PRE><P>which means that two neighbors are operon pairs and one neighbor is a non-operon pair.</P><P>To get some idea of the prediction accuracy of the <I>k</I>-nearest neighbors approach, we can apply it to the training data:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for i in range(len(ys)):
        print "True:", ys[i], "Predicted:", kNN.classify(model, xs[i])
True: 1 Predicted: 1
True: 1 Predicted: 0
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
</PRE><P>showing that the prediction is correct for all but two of the gene pairs. A more reliable estimate of the prediction accuracy can be found from a leave-one-out analysis, in which the model is recalculated from the training data after removing the gene to be predicted:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for i in range(len(ys)):
        model = kNN.train(xs[:i]+xs[i+1:], ys[:i]+ys[i+1:])
        print "True:", ys[i], "Predicted:", kNN.classify(model, xs[i])
True: 1 Predicted: 1
True: 1 Predicted: 0
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 1
True: 1 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 1
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 0
True: 0 Predicted: 1
</PRE><P>The leave-one-out analysis shows that <I>k</I>-nearest neighbors model is correct for 13 out of 17 gene pairs, which corresponds to a prediction accuracy of 76%.</P><!--TOC section Na&#XEF;ve Bayes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc197">14.3</A>&#XA0;&#XA0;Na&#XEF;ve Bayes</H2><!--SEC END --><P>This section will describe the <CODE>Bio.NaiveBayes</CODE> module.</P><!--TOC section Maximum Entropy-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc198">14.4</A>&#XA0;&#XA0;Maximum Entropy</H2><!--SEC END --><P>This section will describe the <CODE>Bio.MaximumEntropy</CODE> module.</P><!--TOC section Markov Models-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc199">14.5</A>&#XA0;&#XA0;Markov Models</H2><!--SEC END --><P>This section will describe the <CODE>Bio.MarkovModel</CODE> and/or <CODE>Bio.HMM.MarkovModel</CODE> modules.</P><!--TOC chapter Graphics including GenomeDiagram-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc200">Chapter&#XA0;15</A>&#XA0;&#XA0;Graphics including GenomeDiagram</H1><!--SEC END --><P>
<A NAME="chapter:graphics"></A></P><P>The <CODE>Bio.Graphics</CODE> module depends on the third party Python library
<A HREF="http://www.reportlab.org">ReportLab</A>. Although focused on producing PDF files,
ReportLab can also create encapsulated postscript (EPS) and (SVG) files. In addition
to these vector based images, provided certain further dependencies such as the
<A HREF="http://www.pythonware.com/products/pil/">Python Imaging Library (PIL)</A> are
installed, ReportLab can also output bitmap images (including JPEG, PNG, GIF, BMP
and PICT formats).</P><!--TOC section GenomeDiagram-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc201">15.1</A>&#XA0;&#XA0;GenomeDiagram</H2><!--SEC END --><P>
<A NAME="sec:genomediagram"></A>
</P><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc202">15.1.1</A>&#XA0;&#XA0;Introduction</H3><!--SEC END --><P>The <CODE>Bio.Graphics.GenomeDiagram</CODE> module was added to Biopython 1.50,
having previously been available as a separate Python module dependent on Biopython.
GenomeDiagram is described in the Bioinformatics journal publication Pritchard et al. (2006),
<A HREF="http://dx.doi.org/10.1093/bioinformatics/btk021">doi:10.1093/bioinformatics/btk021</A>,
which includes some examples images. There is a PDF copy of the old manual here,
<A HREF="http://biopython.org/DIST/docs/GenomeDiagram/userguide.pdf"><TT>http://biopython.org/DIST/docs/GenomeDiagram/userguide.pdf</TT></A> which has some
more examples.
</P><P>As the name might suggest, GenomeDiagram was designed for drawing whole genomes, in
particular prokaryotic genomes, either as linear diagrams (optionally broken up into
fragments to fit better) or as circular wheel diagrams. Have a look at Figure 2 in
Toth <I>et al.</I> (2006),
<A HREF="http://dx.doi.org/10.1146/annurev.phyto.44.070505.143444">doi:10.1146/annurev.phyto.44.070505.143444</A>,
for a good example. It proved also well suited to drawing quite detailed figures for
smaller genomes such as phage, plasmids or mitochrondia, for example see Figures 1
and 2 in van Leeuwenhoek <I>et al.</I> (2009),
<A HREF="http://dx.doi.org/10.1007/s10482-009-9316-9">doi:10.1007/s10482-009-9316-9</A>
(shown with additional manual editing).</P><P>This module is easiest to use if you have your genome loaded as a <CODE>SeqRecord</CODE>
object containing lots of <CODE>SeqFeature</CODE> objects - for example as loaded from a
GenBank file (see Chapters&#XA0;<A HREF="#chapter:SeqRecord">4</A> and&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>).</P><!--TOC subsection Diagrams, tracks, feature-sets and features-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc203">15.1.2</A>&#XA0;&#XA0;Diagrams, tracks, feature-sets and features</H3><!--SEC END --><P>GenomeDiagram uses a nested set of objects. At the top level, you have a diagram
object representing a sequence (or sequence region) along the horizontal axis (or
circle). A diagram can contain one or more tracks, shown stacked vertically (or
radially on circular diagrams). These will typically all have the same length
and represent the same sequence region. You might use one track to show the gene
locations, another to show regulatory regions, and a third track to show the GC
percentage. </P><P>The most commonly used type of track will contain features, bundled together in
feature-sets. You might choose to use one feature-set for all your CDS features,
and another for tRNA features. This isn&#X2019;t required - they can all go in the same
feature-set, but it makes it easier to update the properties of just selected
features (e.g. make all the tRNA features red).</P><P>There are two main ways to build up a complete diagram. Firstly, the top down
approach where you create a diagram object, and then using its methods add
track(s), and use the track methods to add feature-set(s), and use their
methods to add the features. Secondly, you can create the individual objects
separately (in whatever order suits your code), and then combine them.</P><!--TOC subsection A top down example-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc204">15.1.3</A>&#XA0;&#XA0;A top down example</H3><!--SEC END --><P>
<A NAME="sec:gd_top_down"></A></P><P>We&#X2019;re going to draw a whole genome from a <CODE>SeqRecord</CODE> object read in from
a GenBank file (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>). This example uses the
pPCP1 plasmid from <I>Yersinia pestis biovar Microtus</I>, the file is
included with the Biopython unit tests under the GenBank folder, or online
<A HREF="http://biopython.org/SRC/biopython/Tests/GenBank/NC_005816.gb"><TT>NC_005816.gb</TT></A> from our website.</P><PRE CLASS="verbatim">from reportlab.lib import colors
from reportlab.lib.units import cm
from Bio.Graphics import GenomeDiagram
from Bio import SeqIO
record = SeqIO.read("NC_005816.gb", "genbank")
</PRE><P>We&#X2019;re using a top down approach, so after loading in our sequence we next
create an empty diagram, then add an (empty) track, and to that add an
(empty) feature set:</P><PRE CLASS="verbatim">gd_diagram = GenomeDiagram.Diagram("Yersinia pestis biovar Microtus plasmid pPCP1")
gd_track_for_features = gd_diagram.new_track(1, name="Annotated Features")
gd_feature_set = gd_track_for_features.new_set()
</PRE><P>Now the fun part - we take each gene <CODE>SeqFeature</CODE> object in our
<CODE>SeqRecord</CODE>, and use it to generate a feature on the diagram. We&#X2019;re
going to color them blue, alternating between a dark blue and a light blue.
</P><PRE CLASS="verbatim">for feature in record.features:
    if feature.type != "gene":
        #Exclude this feature
        continue
    if len(gd_feature_set) % 2 == 0:
        color = colors.blue
    else:
        color = colors.lightblue
    gd_feature_set.add_feature(feature, color=color, label=True)
</PRE><P>Now we come to actually making the output file. This happens in two steps,
first we call the <CODE>draw</CODE> method, which creates all the shapes using
ReportLab objects. Then we call the <CODE>write</CODE> method which renders these
to the requested file format. Note you can output in multiple file formats:</P><PRE CLASS="verbatim">gd_diagram.draw(format="linear", orientation="landscape", pagesize='A4',
                fragments=4, start=0, end=len(record))
gd_diagram.write("plasmid_linear.pdf", "PDF")
gd_diagram.write("plasmid_linear.eps", "EPS")
gd_diagram.write("plasmid_linear.svg", "SVG")
</PRE><P>Also, provided you have the dependencies installed, you can also do bitmaps,
for example:</P><PRE CLASS="verbatim">gd_diagram.write("plasmid_linear.png", "PNG")
</PRE><P>
<IMG SRC="images/plasmid_linear.png" width=550, height=400></P><P>

Notice that the <CODE>fragments</CODE> argument which we set to four controls how
many pieces the genome gets broken up into.</P><P>If you want to do a circular figure, then try this:</P><PRE CLASS="verbatim">gd_diagram.draw(format="circular", circular=True, pagesize=(20*cm,20*cm),
                start=0, end=len(record), circle_core=0.7)
gd_diagram.write("plasmid_circular.pdf", "PDF")
</PRE><P>
<IMG SRC="images/plasmid_circular.png" width=400, height=400></P><P>

These figures are not very exciting, but we&#X2019;ve only just got started.</P><!--TOC subsection A bottom up example-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc205">15.1.4</A>&#XA0;&#XA0;A bottom up example</H3><!--SEC END --><P>
Now let&#X2019;s produce exactly the same figures, but using the bottom up approach.
This means we create the different objects directly (and this can be done in
almost any order) and then combine them.</P><PRE CLASS="verbatim">from reportlab.lib import colors
from reportlab.lib.units import cm
from Bio.Graphics import GenomeDiagram
from Bio import SeqIO
record = SeqIO.read("NC_005816.gb", "genbank")

#Create the feature set and its feature objects,
gd_feature_set = GenomeDiagram.FeatureSet()
for feature in record.features:
    if feature.type != "gene":
        #Exclude this feature
        continue
    if len(gd_feature_set) % 2 == 0:
        color = colors.blue
    else:
        color = colors.lightblue
    gd_feature_set.add_feature(feature, color=color, label=True)
#(this for loop is the same as in the previous example)

#Create a track, and a diagram
gd_track_for_features = GenomeDiagram.Track(name="Annotated Features")
gd_diagram = GenomeDiagram.Diagram("Yersinia pestis biovar Microtus plasmid pPCP1")

#Now have to glue the bits together...
gd_track_for_features.add_set(gd_feature_set)
gd_diagram.add_track(gd_track_for_features, 1)
</PRE><P>You can now call the <CODE>draw</CODE> and <CODE>write</CODE> methods as before to produce
a linear or circular diagram, using the code at the end of the top-down example
above. The figures should be identical.</P><!--TOC subsection Features without a SeqFeature-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc206">15.1.5</A>&#XA0;&#XA0;Features without a SeqFeature</H3><!--SEC END --><P>
<A NAME="sec:gd_features_without_seqfeatures"></A></P><P>In the above example we used a <CODE>SeqRecord</CODE>&#X2019;s <CODE>SeqFeature</CODE> objects
to build our diagram (see also Section&#XA0;<A HREF="#sec:seq_features">4.3</A>).
Sometimes you won&#X2019;t have <CODE>SeqFeature</CODE> objects,
but just the coordinates for a feature you want to draw. You have to create
minimal <CODE>SeqFeature</CODE> object, but this is easy:</P><PRE CLASS="verbatim">from Bio.SeqFeature import SeqFeature, FeatureLocation
my_seq_feature = SeqFeature(FeatureLocation(50,100),strand=+1)
</PRE><P>For strand, use <TT>+1</TT> for the forward strand, <TT>-1</TT> for the
reverse strand, and <TT>None</TT> for both. Here is a short self contained
example:</P><PRE CLASS="verbatim">from Bio.SeqFeature import SeqFeature, FeatureLocation
from Bio.Graphics import GenomeDiagram
from reportlab.lib.units import cm

gdd = GenomeDiagram.Diagram('Test Diagram')
gdt_features = gdd.new_track(1, greytrack=False)
gds_features = gdt_features.new_set()

#Add three features to show the strand options,
feature = SeqFeature(FeatureLocation(25, 125), strand=+1)
gds_features.add_feature(feature, name="Forward", label=True)
feature = SeqFeature(FeatureLocation(150, 250), strand=None)
gds_features.add_feature(feature, name="Standless", label=True)
feature = SeqFeature(FeatureLocation(275, 375), strand=-1)
gds_features.add_feature(feature, name="Reverse", label=True)

gdd.draw(format='linear', pagesize=(15*cm,4*cm), fragments=1,
         start=0, end=400)
gdd.write("GD_labels_default.pdf", "pdf")
</PRE><P>
The top part of the image in the next subsection shows the output


(in the default feature color, pale green).</P><P>Notice that we have used the <TT>name</TT> argument here to specify the
caption text for these features. This is discussed in more detail next.</P><!--TOC subsection Feature captions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc207">15.1.6</A>&#XA0;&#XA0;Feature captions</H3><!--SEC END --><P>
<A NAME="sec:gd_feature_captions"></A></P><P>Recall we used the following (where <TT>feature</TT> was a
<CODE>SeqFeature</CODE> object) to add a feature to the diagram:</P><PRE CLASS="verbatim">gd_feature_set.add_feature(feature, color=color, label=True)
</PRE><P>In the example above the <CODE>SeqFeature</CODE> annotation was used to pick a
sensible caption for the features. By default the following possible entries
under the <CODE>SeqFeature</CODE> object&#X2019;s qualifiers dictionary are used:
<TT>gene</TT>, <TT>label</TT>, <TT>name</TT>, <TT>locus_tag</TT>, and
<TT>product</TT>. More simply, you can specify a name directly:</P><PRE CLASS="verbatim">gd_feature_set.add_feature(feature, color=color, label=True, name="My Gene")
</PRE><P>In addition to the caption text for each feature&#X2019;s label, you can also choose
the font, position (this defaults to the start of the sigil, you can also
choose the middle or at the end) and orientation (for linear diagrams only,
where this defaults to rotated by 45 degrees):</P><PRE CLASS="verbatim">#Large font, parallel with the track
gd_feature_set.add_feature(feature, label=True, color="green",
                           label_size=25, label_angle=0)

#Very small font, perpendicular to the track (towards it)
gd_feature_set.add_feature(feature, label=True, color="purple",
                           label_position="end",
                           label_size=4, label_angle=90)

#Small font, perpendicular to the track (away from it)
gd_feature_set.add_feature(feature, label=True, color="blue",
                           label_position="middle",
                           label_size=6, label_angle=-90)
</PRE><P>Combining each of these three fragments with the complete example
in the previous section should give something like

this:</P><P><IMG SRC="images/GD_sigil_labels.png" width=600, height=700>
<A NAME="fig:gd_sigil_labels"></A></P><P>We&#X2019;ve not shown it here, but you can also set <TT>label_color</TT> to
control the label&#X2019;s color (used in Section&#XA0;<A HREF="#sec:gd_nice_example">15.1.8</A>).</P><P>You&#X2019;ll notice the default font is quite small - this makes sense because
you will usually be drawing many (small) features on a page, not just a
few large ones as shown here.</P><!--TOC subsection Feature sigils-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc208">15.1.7</A>&#XA0;&#XA0;Feature sigils</H3><!--SEC END --><P>
<A NAME="sec:gd_arrow_sigils"></A></P><P>The examples above have all just used the default sigil for the feature, a
plain box, but you can also use <EM>arrows</EM> instead. Note this wasn&#X2019;t
available in the last publically released standalone version of
GenomeDiagram.</P><PRE CLASS="verbatim">#Default uses a BOX sigil
gd_feature_set.add_feature(feature)

#You can make this explicit:
gd_feature_set.add_feature(feature, sigil="BOX")

#Or opt for an arrow:
gd_feature_set.add_feature(feature, sigil="ARROW")
</PRE><P>The default arrows are shown at the top of

the next two images.


The arrows fit into a bounding box (as given by the default BOX sigil).</P><P>There are two additional options to adjust the shapes of the arrows, firstly
the thickness of the arrow shaft, given as a proportion of the height of the
bounding box:</P><PRE CLASS="verbatim">#Full height shafts, giving pointed boxes:
gd_feature_set.add_feature(feature, sigil="ARROW", color="brown",
                           arrowshaft_height=1.0)
#Or, thin shafts:                      
gd_feature_set.add_feature(feature, sigil="ARROW", color="teal",
                           arrowshaft_height=0.2)
#Or, very thin shafts:
gd_feature_set.add_feature(feature, sigil="ARROW", color="darkgreen",
                           arrowshaft_height=0.1)
</PRE><P>
The results are shown below:</P><P><IMG SRC="images/GD_sigil_arrow_shafts.png" width=600, height=700></P><P>Secondly, the length of the arrow head - given as a proportion of the height
of the bounding box (defaulting to 0.5, or 50%):</P><PRE CLASS="verbatim">#Short arrow heads:
gd_feature_set.add_feature(feature, sigil="ARROW", color="blue",
                           arrowhead_length=0.25)
#Or, longer arrow heads:
gd_feature_set.add_feature(feature, sigil="ARROW", color="orange",
                           arrowhead_length=1)
#Or, very very long arrow heads (i.e. all head, no shaft, so triangles):
gd_feature_set.add_feature(feature, sigil="ARROW", color="red",
                           arrowhead_length=10000)
</PRE><P>
The results are shown below:</P><P><IMG SRC="images/GD_sigil_arrow_heads.png" width=600, height=700></P><!--TOC subsection A nice example-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc209">15.1.8</A>&#XA0;&#XA0;A nice example</H3><!--SEC END --><P>
<A NAME="sec:gd_nice_example"></A></P><P>Now let&#X2019;s return to the pPCP1 plasmid from <I>Yersinia pestis biovar
Microtus</I>, and the top down approach used in Section&#XA0;<A HREF="#sec:gd_top_down">15.1.3</A>,
but take advantage of the sigil options we&#X2019;ve now discussed. This time
we&#X2019;ll use arrows for the genes, and overlay them with strand-less features
(as plain boxes) showing the position of some restriction digest sites.</P><PRE CLASS="verbatim">from reportlab.lib import colors
from reportlab.lib.units import cm
from Bio.Graphics import GenomeDiagram
from Bio import SeqIO
from Bio.SeqFeature import SeqFeature, FeatureLocation

record = SeqIO.read("NC_005816.gb", "genbank")

gd_diagram = GenomeDiagram.Diagram(record.id)
gd_track_for_features = gd_diagram.new_track(1, name="Annotated Features")
gd_feature_set = gd_track_for_features.new_set()

for feature in record.features:
    if feature.type != "gene":
        #Exclude this feature
        continue
    if len(gd_feature_set) % 2 == 0:
        color = colors.blue
    else:
        color = colors.lightblue
    gd_feature_set.add_feature(feature, sigil="ARROW",
                               color=color, label=True,
                               label_size = 14, label_angle=0)

#I want to include some strandless features, so for an example
#will use EcoRI recognition sites etc.
for site, name, color in [("GAATTC","EcoRI",colors.green),
                          ("CCCGGG","SmaI",colors.orange),
                          ("AAGCTT","HindIII",colors.red),
                          ("GGATCC","BamHI",colors.purple)]:
    index = 0
    while True:
        index  = record.seq.find(site, start=index)
        if index == -1 : break
        feature = SeqFeature(FeatureLocation(index, index+len(site)))
        gd_feature_set.add_feature(feature, color=color, name=name,
                                   label=True, label_size = 10,
                                   label_color=color)
        index += len(site)

gd_diagram.draw(format="linear", pagesize='A4', fragments=4,
                start=0, end=len(record))
gd_diagram.write("plasmid_linear_nice.pdf", "PDF")
gd_diagram.write("plasmid_linear_nice.eps", "EPS")
gd_diagram.write("plasmid_linear_nice.svg", "SVG")

gd_diagram.draw(format="circular", circular=True, pagesize=(20*cm,20*cm),
                start=0, end=len(record), circle_core = 0.5)
gd_diagram.write("plasmid_circular_nice.pdf", "PDF")
gd_diagram.write("plasmid_circular_nice.eps", "EPS")
gd_diagram.write("plasmid_circular_nice.svg", "SVG")
</PRE><P>
And the output:</P><P><IMG SRC="images/plasmid_linear_nice.png" width=550, height=400></P><P><IMG SRC="images/plasmid_circular_nice.png" width=591, height=591></P><!--TOC subsection Multiple tracks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc210">15.1.9</A>&#XA0;&#XA0;Multiple tracks</H3><!--SEC END --><P>
<A NAME="sec:gd_multiple_tracks"></A></P><P>All the examples so far have used a single track, but you can have more than
one track &#X2013; for example show the genes on one, and repeat regions on another.
In this example we&#X2019;re going to show three phage genomes side by side to scale,
inspired by Figure 6 in <A HREF="http://dx.doi.org/10.1128/?JB.184.21.6026-6036.2002">Proux <I>et al.</I> 2002</A>.
We&#X2019;ll need the GenBank files for the following three phage:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>NC_002703</CODE> &#X2013; Lactococcus phage Tuc2009, complete genome (38347 bp)
</LI><LI CLASS="li-itemize"><CODE>AF323668</CODE> &#X2013; Bacteriophage bIL285, complete genome (35538 bp)
</LI><LI CLASS="li-itemize"><CODE>NC_003212</CODE> &#X2013; <I>Listeria innocua</I> Clip11262, complete genome,
of which we are focussing only on integrated prophage 5 (similar length).
</LI></UL><P>You can download these using Entrez if you like, see Section&#XA0;<A HREF="#sec:efetch">8.6</A>
for more details. For the third record we&#X2019;ve worked out where the phage is
integrated into the genome, and slice the record to extract it (with the
features preserved, see Section&#XA0;<A HREF="#sec:SeqRecord-slicing">4.7</A>), and must also
reverse complement to match the orientation of the first two phage (again
preserving the features, see Section&#XA0;<A HREF="#sec:SeqRecord-reverse-complement">4.9</A>):</P><PRE CLASS="verbatim">from Bio import SeqIO

A_rec = SeqIO.read("NC_002703.gbk", "gb")
B_rec = SeqIO.read("AF323668.gbk", "gb")
C_rec = SeqIO.read("NC_003212.gbk", "gb")[2587879:2625807].reverse_complement(name=True)
</PRE><P>The figure we are imitating used different colors for different gene functions.
One way to do this is to edit the GenBank file to record color preferences for
each feature - something <A HREF="http://www.sanger.ac.uk/resources/software/artemis/">Sanger&#X2019;s Artemis editor</A> does, and which GenomeDiagram should understand. Here
however, we&#X2019;ll just hard code three lists of colors.</P><P>Note that the annotation in the GenBank files doesn&#X2019;t exactly match that shown
in Proux <I>et al.</I>, they have drawn some unannotated genes.</P><PRE CLASS="verbatim">from reportlab.lib.colors import red, grey, orange, green, brown, blue, lightblue, purple

A_colors = [red]*5 + [grey]*7 + [orange]*2 + [grey]*2 + [orange] + [grey]*11 + [green]*4 \
         + [grey] + [green]*2 + [grey, green] + [brown]*5 + [blue]*4 + [lightblue]*5 \
         + [grey, lightblue] + [purple]*2 + [grey]
B_colors = [red]*6 + [grey]*8 + [orange]*2 + [grey] + [orange] + [grey]*21 + [green]*5 \
         + [grey] + [brown]*4 + [blue]*3 + [lightblue]*3 + [grey]*5 + [purple]*2
C_colors = [grey]*30 + [green]*5 + [brown]*4 + [blue]*2 + [grey, blue] + [lightblue]*2 \
         + [grey]*5
</PRE><P>Now to draw them &#X2013; this time we add three tracks to the diagram, and also notice they
are given different start/end values to reflect their different lengths (this requires
Biopython 1.59 or later).</P><PRE CLASS="verbatim">from Bio.Graphics import GenomeDiagram

name = "Proux Fig 6"
gd_diagram = GenomeDiagram.Diagram(name)
max_len = 0
for record, gene_colors in zip([A_rec, B_rec, C_rec], [A_colors, B_colors, C_colors]):
    max_len = max(max_len, len(record))
    gd_track_for_features = gd_diagram.new_track(1,
                            name=record.name,
                            greytrack=True,
                            start=0, end=len(record))
    gd_feature_set = gd_track_for_features.new_set()

    i = 0
    for feature in record.features:
        if feature.type != "gene":
            #Exclude this feature                                                                                                   
            continue
        gd_feature_set.add_feature(feature, sigil="ARROW",
                                   color=gene_colors[i], label=True,
                                   name = str(i+1),
                                   label_position="start",
                                   label_size = 6, label_angle=0)
        i+=1

gd_diagram.draw(format="linear", pagesize='A4', fragments=1,
                start=0, end=max_len)
gd_diagram.write(name + ".pdf", "PDF")
gd_diagram.write(name + ".eps", "EPS")
gd_diagram.write(name + ".svg", "SVG")
</PRE><P>
The result:</P><P><IMG SRC="images/three_track_simple.png" width=565, height=400></P><P>

I did wonder why in the original manuscript there were no red or orange genes
marked in the bottom phage. Another important point is here the phage are
shown with different lengths - this is because they are all drawn to the same
scale (they <EM>are</EM> different lengths).</P><P>The key difference from the published figure is they have color-coded links
between similar proteins &#X2013; which is what we will do in the next section.</P><!--TOC subsection Cross-Links between tracks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc211">15.1.10</A>&#XA0;&#XA0;Cross-Links between tracks</H3><!--SEC END --><P>
<A NAME="sec:gd_cross_links"></A></P><P>Biopython 1.59 added the ability to draw cross links between tracks - both
simple linear diagrams as we will show here, but also linear diagrams split
into fragments and circular diagrams.</P><P>Continuing the example from the previous section inspired by Figure 6 from
<A HREF="http://dx.doi.org/10.1128/JB.184.21.6026-6036.2002">Proux <I>et al.</I> 2002</A>,
we would need a list of cross links between pairs of genes, along with a score
or color to use. Realistically you might extract this from a BLAST file
computationally, but here I have manually typed them in.</P><P>My naming convention continues to refer to the three phage as A, B and C.
Here are the links we want to show between A and B, given as a list of
tuples (percentage similarity score, gene in A, gene in B).</P><PRE CLASS="verbatim">#Tuc2009 (NC_002703) vs bIL285 (AF323668)
A_vs_B = [
    (99, "Tuc2009_01", "int"),
    (33, "Tuc2009_03", "orf4"),
    (94, "Tuc2009_05", "orf6"),
    (100,"Tuc2009_06", "orf7"),
    (97, "Tuc2009_07", "orf8"),
    (98, "Tuc2009_08", "orf9"),
    (98, "Tuc2009_09", "orf10"),
    (100,"Tuc2009_10", "orf12"),
    (100,"Tuc2009_11", "orf13"),
    (94, "Tuc2009_12", "orf14"),
    (87, "Tuc2009_13", "orf15"),
    (94, "Tuc2009_14", "orf16"),
    (94, "Tuc2009_15", "orf17"),
    (88, "Tuc2009_17", "rusA"),
    (91, "Tuc2009_18", "orf20"),
    (93, "Tuc2009_19", "orf22"),
    (71, "Tuc2009_20", "orf23"),
    (51, "Tuc2009_22", "orf27"),
    (97, "Tuc2009_23", "orf28"),
    (88, "Tuc2009_24", "orf29"),
    (26, "Tuc2009_26", "orf38"),
    (19, "Tuc2009_46", "orf52"),
    (77, "Tuc2009_48", "orf54"),
    (91, "Tuc2009_49", "orf55"),
    (95, "Tuc2009_52", "orf60"), 
]
</PRE><P>Likewise for B and C:</P><PRE CLASS="verbatim">#bIL285 (AF323668) vs Listeria innocua prophage 5 (in NC_003212)
B_vs_C = [
    (42, "orf39", "lin2581"),
    (31, "orf40", "lin2580"),
    (49, "orf41", "lin2579"), #terL
    (54, "orf42", "lin2578"), #portal
    (55, "orf43", "lin2577"), #protease
    (33, "orf44", "lin2576"), #mhp
    (51, "orf46", "lin2575"),
    (33, "orf47", "lin2574"),
    (40, "orf48", "lin2573"),
    (25, "orf49", "lin2572"),
    (50, "orf50", "lin2571"),
    (48, "orf51", "lin2570"),
    (24, "orf52", "lin2568"),
    (30, "orf53", "lin2567"),
    (28, "orf54", "lin2566"),
]
</PRE><P>For the first and last phage these identifiers are locus tags, for the middle
phage there are no locus tags so I&#X2019;ve used gene names instead. The following
little helper function lets us lookup a feature using either a locus tag or
gene name:</P><PRE CLASS="verbatim">def get_feature(features, id, tags=["locus_tag", "gene"]):
    """Search list of SeqFeature objects for an identifier under the given tags."""
    for f in features:
        for key in tags:
            #tag may not be present in this feature 
            for x in f.qualifiers.get(key, []):
                if x == id:
                     return f
    raise KeyError(id)
</PRE><P>We can now turn those list of identifier pairs into SeqFeature pairs, and thus
find their location co-ordinates. We can now add all that code and the following
snippet to the previous example (just before the <CODE>gd_diagram.draw(...)</CODE>
line) to add cross links to the figure:</P><PRE CLASS="verbatim">from Bio.Graphics.GenomeDiagram import CrossLink
from reportlab.lib import colors
#Note it might have been clearer to assign the track numbers explicitly...                                                          
for rec_X, tn_X, rec_Y, tn_Y, X_vs_Y in [(A_rec, 3, B_rec, 2, A_vs_B),
                                         (B_rec, 2, C_rec, 1, B_vs_C)]:
    track_X = gd_diagram.tracks[tn_X]
    track_Y = gd_diagram.tracks[tn_Y]
    for score, id_X, id_Y in X_vs_Y:
        feature_X = get_feature(rec_X.features, id_X)
        feature_Y = get_feature(rec_Y.features, id_Y)
        color = colors.linearlyInterpolatedColor(colors.white, colors.firebrick, 0, 100, score)
        link_xy = CrossLink((track_X, feature_X.location.start, feature_X.location.end),
                            (track_Y, feature_Y.location.start, feature_Y.location.end),
                            color, colors.lightgrey)
        gd_diagram.cross_track_links.append(link_xy)
</PRE><P>There are several important pieces to this code. First the <CODE>GenomeDiagram</CODE> object
has a <CODE>cross_track_links</CODE> attribute which is just a list of <CODE>CrossLink</CODE> objects.
Each <CODE>CrossLink</CODE> object takes two sets of track-specific co-ordinates (here given
as tuples, you can alternatively use a <CODE>GenomeDiagram.Feature</CODE> object instead).
You can optionally supply a colour, border color, and say if this link should be drawn
flipped (useful for showing inversions).</P><P>You can also see how we turn the BLAST percentage identity score into a colour,
interpolating between white (0%) and a dark red (100%). In this example
we don&#X2019;t have any problems with overlapping cross-links. One way to tackle that
is to use transparency in ReportLab, by using colors with their alpha channel set.
However, this kind of shaded color scheme combined with overlap transparency
would be difficult to interpret.</P><P>
The result:</P><P><IMG SRC="images/three_track_cl.png" width=565, height=400></P><P>There is still a lot more that can be done within Biopython to help
improve this figure. First of all, the cross links in this case are
between proteins which are drawn in a strand specific manor. It can
help to add a background region (a feature using the &#X2019;BOX&#X2019; sigil) on the
feature track to extend the cross link. Also, we could reduce the vertical
height of the feature tracks to allocate more to the links instead &#X2013; one
way to do that is to allocate space for empty tracks. These improvements
are demonstrated in the example script <TT>Proux_et_al_2002_Figure_6.py</TT>
included in the <TT>Doc/examples</TT> folder of the Biopython source code.

The result:</P><P><IMG SRC="images/three_track_cl2.png" width=565, height=400></P><P>Beyond that, finishing touches you might want to do manually in a vector
image editor include fine tuning the placement of gene labels, and adding
other custom annotation such as highlighting particular regions.</P><P>Although not really necessary in this example since none of the cross-links
overlap, using a transparent color in ReportLab is a very useful technique
for superimposing multiple links. However, in this case a shaded color
scheme should be avoided.</P><!--TOC subsection Further options-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc212">15.1.11</A>&#XA0;&#XA0;Further options</H3><!--SEC END --><P>You can control the tick marks to show the scale &#X2013; after all every graph
should show its units, and the number of the grey-track labels.</P><P>Also, we have only used the <CODE>FeatureSet</CODE> so far. GenomeDiagram also has
a <CODE>GraphSet</CODE> which can be used for show line graphs, bar charts and heat
plots (e.g. to show plots of GC% on a track parallel to the features).</P><P>These options are not covered here yet, so for now we refer you to the
<A HREF="http://biopython.org/DIST/docs/GenomeDiagram/userguide.pdf">User Guide (PDF)</A> included with the standalone version of GenomeDiagram (but
please read the next section first), and the docstrings.</P><!--TOC subsection Converting old code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc213">15.1.12</A>&#XA0;&#XA0;Converting old code</H3><!--SEC END --><P>If you have old code written using the standalone version of GenomeDiagram, and
you want to switch it over to using the new version included with Biopython then
you will have to make a few changes - most importantly to your import statements.</P><P>Also, the older version of GenomeDiagram used only the UK spellings of color and
center (colour and centre). As part of the integration into Biopython, both
forms can now be used for argument names. However, at some point in the future the
UK spellings may be deprecated.</P><P>For example, if you used to have:
</P><PRE CLASS="verbatim">from GenomeDiagram import GDFeatureSet, GDDiagram
gdd = GDDiagram("An example")
...
</PRE><P>you could just switch the import statements like this:
</P><PRE CLASS="verbatim">from Bio.Graphics.GenomeDiagram import FeatureSet as GDFeatureSet, Diagram as GDDiagram
gdd = GDDiagram("An example")
...
</PRE><P>and hopefully that should be enough. In the long term you might want to
switch to the new names, but you would have to change more of your code:
</P><PRE CLASS="verbatim">from Bio.Graphics.GenomeDiagram import FeatureSet, Diagram
gdd = Diagram("An example")
...
</PRE><P>or:
</P><PRE CLASS="verbatim">from Bio.Graphics import GenomeDiagram
gdd = GenomeDiagram.Diagram("An example")
...
</PRE><P>If you run into difficulties, please ask on the Biopython mailing list for
advice. One catch is that for Biopython 1.50, we have not yet included the
old module <CODE>GenomeDiagram.GDUtilities</CODE> yet. This included a number of
GC% related functions, which will probably be merged under
<CODE>Bio.SeqUtils</CODE> later on.</P><!--TOC section Chromosomes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc214">15.2</A>&#XA0;&#XA0;Chromosomes</H2><!--SEC END --><P>The <CODE>Bio.Graphics.BasicChromosome</CODE> module allows drawing of chromosomes.
There is an example in
<A HREF="http://dx.doi.org/10.1186/1471-2164-13-75">Jupe <I>et al.</I> 2012</A>
(open access) using colors to highlight different gene families.</P><!--TOC subsection Simple Chromosomes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc215">15.2.1</A>&#XA0;&#XA0;Simple Chromosomes</H3><!--SEC END --><P>
Here is a very simple example - for which we&#X2019;ll use <I>Arabidopsis thaliana</I>.</P><P>You can skip this bit, but first I downloaded the five sequenced chromosomes
from the NCBI&#X2019;s FTP site
<A HREF="ftp://ftp.ncbi.nlm.nih.gov/genomes/Arabidopsis_thaliana"><TT>ftp://ftp.ncbi.nlm.nih.gov/genomes/Arabidopsis_thaliana</TT></A> and then parsed
them with <CODE>Bio.SeqIO</CODE> to find out their lengths. You could use the
GenBank files for this, but it is faster to use the FASTA files for the
whole chromosomes:</P><PRE CLASS="verbatim">from Bio import SeqIO
entries = [("Chr I", "CHR_I/NC_003070.fna"),
           ("Chr II", "CHR_II/NC_003071.fna"),
           ("Chr III", "CHR_III/NC_003074.fna"),
           ("Chr IV", "CHR_IV/NC_003075.fna"),
           ("Chr V", "CHR_V/NC_003076.fna")]
for (name, filename) in entries:
   record = SeqIO.read(filename,"fasta")
   print name, len(record)
</PRE><P>This gave the lengths of the five chromosomes, which we&#X2019;ll now use in
the following short demonstration of the <CODE>BasicChromosome</CODE> module:</P><PRE CLASS="verbatim">from reportlab.lib.units import cm
from Bio.Graphics import BasicChromosome

entries = [("Chr I", 30432563),
           ("Chr II", 19705359),
           ("Chr III", 23470805),
           ("Chr IV", 18585042),
           ("Chr V", 26992728)]

max_len = 30432563 #Could compute this
telomere_length = 1000000 #For illustration
         
chr_diagram = BasicChromosome.Organism()
chr_diagram.page_size = (29.7*cm, 21*cm) #A4 landscape

for name, length in entries:
    cur_chromosome = BasicChromosome.Chromosome(name)
    #Set the scale to the MAXIMUM length plus the two telomeres in bp,
    #want the same scale used on all five chromosomes so they can be
    #compared to each other
    cur_chromosome.scale_num = max_len + 2 * telomere_length

    #Add an opening telomere
    start = BasicChromosome.TelomereSegment()
    start.scale = telomere_length
    cur_chromosome.add(start)

    #Add a body - using bp as the scale length here.
    body = BasicChromosome.ChromosomeSegment()
    body.scale = length
    cur_chromosome.add(body)

    #Add a closing telomere
    end = BasicChromosome.TelomereSegment(inverted=True)
    end.scale = telomere_length
    cur_chromosome.add(end)

    #This chromosome is done
    chr_diagram.add(cur_chromosome)

chr_diagram.draw("simple_chrom.pdf", "Arabidopsis thaliana")
</PRE><P>This should create a very simple PDF file, shown

here:</P><P><IMG SRC="images/simple_chrom.png" width=650, height=460></P><P>

This example is deliberately short and sweet. The next example shows the
location of features of interest.</P><!--TOC subsection Annotated Chromosomes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc216">15.2.2</A>&#XA0;&#XA0;Annotated Chromosomes</H3><!--SEC END --><P>Continuing from the previous example, let&#X2019;s also show the tRNA genes.
We&#X2019;ll get their locations by parsing the GenBank files for the five
<I>Arabidopsis thaliana</I> chromosomes. You&#X2019;ll need to download these
files from the NCBI FTP site
<A HREF="ftp://ftp.ncbi.nlm.nih.gov/genomes/Arabidopsis_thaliana"><TT>ftp://ftp.ncbi.nlm.nih.gov/genomes/Arabidopsis_thaliana</TT></A>,
and preserve the subdirectory names or edit the paths below:</P><PRE CLASS="verbatim">from reportlab.lib.units import cm
from Bio import SeqIO
from Bio.Graphics import BasicChromosome

entries = [("Chr I", "CHR_I/NC_003070.gbk"),
           ("Chr II", "CHR_II/NC_003071.gbk"),
           ("Chr III", "CHR_III/NC_003074.gbk"),
           ("Chr IV", "CHR_IV/NC_003075.gbk"),
           ("Chr V", "CHR_V/NC_003076.gbk")]

max_len = 30432563 #Could compute this
telomere_length = 1000000 #For illustration

chr_diagram = BasicChromosome.Organism()
chr_diagram.page_size = (29.7*cm, 21*cm) #A4 landscape

for index, (name, filename) in enumerate(entries):
    record = SeqIO.read(filename,"genbank")
    length = len(record)
    features = [f for f in record.features if f.type=="tRNA"]
    #Record an Artemis style integer color in the feature's qualifiers,
    #1 = Black, 2 = Red, 3 = Green, 4 = blue, 5 =cyan, 6 = purple 
    for f in features: f.qualifiers["color"] = [index+2]

    cur_chromosome = BasicChromosome.Chromosome(name)
    #Set the scale to the MAXIMUM length plus the two telomeres in bp,
    #want the same scale used on all five chromosomes so they can be
    #compared to each other
    cur_chromosome.scale_num = max_len + 2 * telomere_length

    #Add an opening telomere
    start = BasicChromosome.TelomereSegment()
    start.scale = telomere_length
    cur_chromosome.add(start)

    #Add a body - again using bp as the scale length here.
    body = BasicChromosome.AnnotatedChromosomeSegment(length, features)
    body.scale = length
    cur_chromosome.add(body)

    #Add a closing telomere
    end = BasicChromosome.TelomereSegment(inverted=True)
    end.scale = telomere_length
    cur_chromosome.add(end)

    #This chromosome is done
    chr_diagram.add(cur_chromosome)

chr_diagram.draw("tRNA_chrom.pdf", "Arabidopsis thaliana")
</PRE><P>It might warn you about the labels being too close together - have a look
at the forward strand (right hand side) of Chr I, but it should create a
colorful PDF file, shown

here:</P><P><IMG SRC="images/tRNA_chrom.png" width=650, height=460></P><!--TOC chapter Cookbook &#X2013; Cool things to do with it-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc217">Chapter&#XA0;16</A>&#XA0;&#XA0;Cookbook &#X2013; Cool things to do with it</H1><!--SEC END --><P>
<A NAME="chapter:cookbook"></A></P><P>Biopython now has two collections of &#X201C;cookbook&#X201D; examples &#X2013; this chapter
(which has been included in this tutorial for many years and has gradually
grown), and <A HREF="http://biopython.org/wiki/Category:Cookbook"><TT>http://biopython.org/wiki/Category:Cookbook</TT></A> which is a
user contributed collection on our wiki.</P><P>We&#X2019;re trying to encourage Biopython users to contribute their own examples
to the wiki. In addition to helping the community, one direct benefit of
sharing an example like this is that you could also get some feedback on
the code from other Biopython users and developers - which could help you
improve all your Python code.</P><P>In the long term, we may end up moving all of the examples in this chapter
to the wiki, or elsewhere within the tutorial.</P><!--TOC section Working with sequence files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc218">16.1</A>&#XA0;&#XA0;Working with sequence files</H2><!--SEC END --><P>
<A NAME="seq:cookbook-sequences"></A></P><P>This section shows some more examples of sequence input/output, using the
<CODE>Bio.SeqIO</CODE> module described in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>.</P><!--TOC subsection Filtering a sequence file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc219">16.1.1</A>&#XA0;&#XA0;Filtering a sequence file</H3><!--SEC END --><P>Often you&#X2019;ll have a large file with many sequences in it (e.g. FASTA file
or genes, or a FASTQ or SFF file of reads), a separate shorter list of
the IDs for a subset of sequences of interest, and want to make a new
sequence file for this subset.</P><P>Let&#X2019;s say the list of IDs is in a simple text file, as the first word on
each line. This could be a tabular file where the first column is the ID.
Try something like this:</P><PRE CLASS="verbatim">from Bio import SeqIO
input_file = "big_file.sff"
id_file = "short_list.txt"
output_file = "short_list.sff"
wanted = set(line.rstrip("\n").split(None,1)[0] for line in open(id_file))
print "Found %i unique identifiers in %s" % (len(wanted), id_file)
records = (r for r in SeqIO.parse(input_file, "sff") if r.id in wanted)
count = SeqIO.write(records, output_file, "sff")
print "Saved %i records from %s to %s" % (count, input_file, output_file)
if count &lt; len(wanted):
    print "Warning %i IDs not found in %s" % (len(wanted)-count, input_file)
</PRE><P>Note that we use a Python <CODE>set</CODE> rather than a <CODE>list</CODE>, this makes
testing membership faster.</P><!--TOC subsection Producing randomised genomes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc220">16.1.2</A>&#XA0;&#XA0;Producing randomised genomes</H3><!--SEC END --><P>Let&#X2019;s suppose you are looking at genome sequence, hunting for some sequence
feature &#X2013; maybe extreme local GC% bias, or possible restriction digest sites.
Once you&#X2019;ve got your Python code working on the real genome it may be sensible
to try running the same search on randomised versions of the same genome for
statistical analysis (after all, any &#X201C;features&#X201D; you&#X2019;ve found could just be
there just by chance).</P><P>For this discussion, we&#X2019;ll use the GenBank file for the pPCP1 plasmid from
<I>Yersinia pestis biovar Microtus</I>. The file is included with the
Biopython unit tests under the GenBank folder, or you can get it from our
website, <A HREF="http://biopython.org/SRC/biopython/Tests/GenBank/NC_005816.gb"><TT>NC_005816.gb</TT></A>. 
This file contains one and only one record, so we can read it in as a
<CODE>SeqRecord</CODE> using the <CODE>Bio.SeqIO.read()</CODE> function:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; original_rec = SeqIO.read("NC_005816.gb","genbank")
</PRE><P>So, how can we generate a shuffled versions of the original sequence? I would
use the built in Python <CODE>random</CODE> module for this, in particular the function
<CODE>random.shuffle</CODE> &#X2013; but this works on a Python list. Our sequence is a
<CODE>Seq</CODE> object, so in order to shuffle it we need to turn it into a list:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import random
&gt;&gt;&gt; nuc_list = list(original_rec.seq)
&gt;&gt;&gt; random.shuffle(nuc_list) #acts in situ!
</PRE><P>Now, in order to use <CODE>Bio.SeqIO</CODE> to output the shuffled sequence, we need
to construct a new <CODE>SeqRecord</CODE> with a new <CODE>Seq</CODE> object using this
shuffled list. In order to do this, we need to turn the list of nucleotides
(single letter strings) into a long string &#X2013; the standard Python way to do
this is with the string object&#X2019;s join method.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.SeqRecord import SeqRecord
&gt;&gt;&gt; shuffled_rec = SeqRecord(Seq("".join(nuc_list), original_rec.seq.alphabet),
...                          id="Shuffled", description="Based on %s" % original_rec.id)
</PRE><P>Let&#X2019;s put all these pieces together to make a complete Python script which
generates a single FASTA file containing 30 randomly shuffled versions of
the original sequence.</P><P>This first version just uses a big for loop and writes out the records one by one
(using the <CODE>SeqRecord</CODE>&#X2019;s format method described in
Section&#XA0;<A HREF="#sec:Bio.SeqIO-and-StringIO">5.5.4</A>):</P><PRE CLASS="verbatim">import random
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO

original_rec = SeqIO.read("NC_005816.gb","genbank")

handle = open("shuffled.fasta", "w")
for i in range(30):
    nuc_list = list(original_rec.seq)
    random.shuffle(nuc_list)
    shuffled_rec = SeqRecord(Seq("".join(nuc_list), original_rec.seq.alphabet), \
                             id="Shuffled%i" % (i+1), \
                             description="Based on %s" % original_rec.id)
    handle.write(shuffled_rec.format("fasta"))
handle.close()
</PRE><P>Personally I prefer the following version using a function to shuffle the record
and a generator expression instead of the for loop:</P><PRE CLASS="verbatim">import random
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO

def make_shuffle_record(record, new_id):
    nuc_list = list(record.seq)
    random.shuffle(nuc_list)
    return SeqRecord(Seq("".join(nuc_list), record.seq.alphabet), \
           id=new_id, description="Based on %s" % original_rec.id)
   
original_rec = SeqIO.read("NC_005816.gb","genbank")
shuffled_recs = (make_shuffle_record(original_rec, "Shuffled%i" % (i+1)) \
                 for i in range(30))
handle = open("shuffled.fasta", "w")
SeqIO.write(shuffled_recs, handle, "fasta")
handle.close()
</PRE><!--TOC subsection Translating a FASTA file of CDS entries-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc221">16.1.3</A>&#XA0;&#XA0;Translating a FASTA file of CDS entries</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-translate"></A>
Suppose you&#X2019;ve got an input file of CDS entries for some organism, and you
want to generate a new FASTA file containing their protein sequences. i.e.
Take each nucleotide sequence from the original file, and translate it.
Back in Section&#XA0;<A HREF="#sec:translation">3.9</A> we saw how to use the <CODE>Seq</CODE>
object&#X2019;s <CODE>translate method</CODE>, and the optional <CODE>cds</CODE> argument
which enables correct translation of alternative start codons.</P><P>We can combine this with <CODE>Bio.SeqIO</CODE> as
shown in the reverse complement example in Section&#XA0;<A HREF="#sec:SeqIO-reverse-complement">5.5.3</A>.
The key point is that for each nucleotide <CODE>SeqRecord</CODE>, we need to create
a protein <CODE>SeqRecord</CODE> - and take care of naming it.</P><P>You can write you own function to do this, choosing suitable protein identifiers
for your sequences, and the appropriate genetic code. In this example we just
use the default table and add a prefix to the identifier:</P><PRE CLASS="verbatim">from Bio.SeqRecord import SeqRecord
def make_protein_record(nuc_record):
    """Returns a new SeqRecord with the translated sequence (default table)."""
    return SeqRecord(seq = nuc_record.seq.translate(cds=True), \
                     id = "trans_" + nuc_record.id, \
                     description = "translation of CDS, using default table")
</PRE><P>We can then use this function to turn the input nucleotide records into protein
records ready for output. An elegant way and memory efficient way to do this
is with a generator expression:</P><PRE CLASS="verbatim">from Bio import SeqIO
proteins = (make_protein_record(nuc_rec) for nuc_rec in \
            SeqIO.parse("coding_sequences.fasta", "fasta"))
SeqIO.write(proteins, "translations.fasta", "fasta")
</PRE><P>This should work on any FASTA file of complete coding sequences.
If you are working on partial coding sequences, you may prefer to use
<CODE>nuc_record.seq.translate(to_stop=True)</CODE> in the example above, as
this wouldn&#X2019;t check for a valid start codon etc.</P><!--TOC subsection Making the sequences in a FASTA file upper case-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc222">16.1.4</A>&#XA0;&#XA0;Making the sequences in a FASTA file upper case</H3><!--SEC END --><P>Often you&#X2019;ll get data from collaborators as FASTA files, and sometimes the
sequences can be in a mixture of upper and lower case. In some cases this is
deliberate (e.g. lower case for poor quality regions), but usually it is not
important. You may want to edit the file to make everything consistent (e.g.
all upper case), and you can do this easily using the <CODE>upper()</CODE> method
of the <CODE>SeqRecord</CODE> object (added in Biopython 1.55):</P><PRE CLASS="verbatim">from Bio import SeqIO
records = (rec.upper() for rec in SeqIO.parse("mixed.fas", "fasta"))
count = SeqIO.write(records, "upper.fas", "fasta")
print "Converted %i records to upper case" % count
</PRE><P>How does this work? The first line is just importing the <CODE>Bio.SeqIO</CODE>
module. The second line is the interesting bit &#X2013; this is a Python
generator expression which gives an upper case version of each record
parsed from the input file (<TT>mixed.fas</TT>). In the third line we give
this generator expression to the <CODE>Bio.SeqIO.write()</CODE> function and it
saves the new upper cases records to our output file (<TT>upper.fas</TT>).</P><P>The reason we use a generator expression (rather than a list or list
comprehension) is this means only one record is kept in memory at a time.
This can be really important if you are dealing with large files with
millions of entries.</P><!--TOC subsection Sorting a sequence file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc223">16.1.5</A>&#XA0;&#XA0;Sorting a sequence file</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-sort"></A></P><P>Suppose you wanted to sort a sequence file by length (e.g. a set of
contigs from an assembly), and you are working with a file format like
FASTA or FASTQ which <CODE>Bio.SeqIO</CODE> can read, write (and index).</P><P>If the file is small enough, you can load it all into memory at once
as a list of <CODE>SeqRecord</CODE> objects, sort the list, and save it:</P><PRE CLASS="verbatim">from Bio import SeqIO
records = list(SeqIO.parse("ls_orchid.fasta","fasta"))
records.sort(cmp=lambda x,y: cmp(len(x),len(y)))
SeqIO.write(records, "sorted_orchids.fasta", "fasta")
</PRE><P>The only clever bit is specifying a comparison function for how to
sort the records (here we sort them by length). If you wanted the
longest records first, you could flip the comparison or use the
reverse argument:</P><PRE CLASS="verbatim">from Bio import SeqIO
records = list(SeqIO.parse("ls_orchid.fasta","fasta"))
records.sort(cmp=lambda x,y: cmp(len(y),len(x)))
SeqIO.write(records, "sorted_orchids.fasta", "fasta")
</PRE><P>Now that&#X2019;s pretty straight forward - but what happens if you have a
very large file and you can&#X2019;t load it all into memory like this?
For example, you might have some next-generation sequencing reads
to sort by length. This can be solved using the
<CODE>Bio.SeqIO.index()</CODE> function.</P><PRE CLASS="verbatim">from Bio import SeqIO
#Get the lengths and ids, and sort on length         
len_and_ids = sorted((len(rec), rec.id) for rec in \
                     SeqIO.parse("ls_orchid.fasta","fasta"))
ids = reversed([id for (length, id) in len_and_ids])
del len_and_ids #free this memory
record_index = SeqIO.index("ls_orchid.fasta", "fasta")
records = (record_index[id] for id in ids)
SeqIO.write(records, "sorted.fasta", "fasta")
</PRE><P>First we scan through the file once using <CODE>Bio.SeqIO.parse()</CODE>,
recording the record identifiers and their lengths in a list of tuples.
We then sort this list to get them in length order, and discard the lengths.
Using this sorted list of identifiers <CODE>Bio.SeqIO.index()</CODE> allows us to
retrieve the records one by one, and we pass them to <CODE>Bio.SeqIO.write()</CODE>
for output.</P><P>These examples all use <CODE>Bio.SeqIO</CODE> to parse the records into
<CODE>SeqRecord</CODE> objects which are output using <CODE>Bio.SeqIO.write()</CODE>.
What if you want to sort a file format which <CODE>Bio.SeqIO.write()</CODE> doesn&#X2019;t
support, like the plain text SwissProt format? Here is an alternative
solution using the <CODE>get_raw()</CODE> method added to <CODE>Bio.SeqIO.index()</CODE>
in Biopython 1.54 (see Section&#XA0;<A HREF="#sec:seqio-index-getraw">5.4.2.2</A>).</P><PRE CLASS="verbatim">from Bio import SeqIO
#Get the lengths and ids, and sort on length         
len_and_ids = sorted((len(rec), rec.id) for rec in \
                     SeqIO.parse("ls_orchid.fasta","fasta"))
ids = reversed([id for (length, id) in len_and_ids])
del len_and_ids #free this memory
record_index = SeqIO.index("ls_orchid.fasta", "fasta")
handle = open("sorted.fasta", "w")
for id in ids:
    handle.write(record_index.get_raw(id))
handle.close()
</PRE><P>As a bonus, because doesn&#X2019;t parse the data into <CODE>SeqRecord</CODE> objects
a second time it should be faster.</P><!--TOC subsection Simple quality filtering for FASTQ files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc224">16.1.6</A>&#XA0;&#XA0;Simple quality filtering for FASTQ files</H3><!--SEC END --><P>
<A NAME="sec:FASTQ-filtering-example"></A></P><P>The FASTQ file format was introduced at Sanger and is now widely used for
holding nucleotide sequencing reads together with their quality scores.
FASTQ files (and the related QUAL files) are an excellent example of
per-letter-annotation, because for each nucleotide in the sequence there is
an associated quality score. Any per-letter-annotation is held in a
<CODE>SeqRecord</CODE> in the <CODE>letter_annotations</CODE> dictionary as a list,
tuple or string (with the same number of elements as the sequence length).</P><P>One common task is taking a large set of sequencing reads and filtering them
(or cropping them) based on their quality scores.
The following example is very simplistic, but should illustrate the basics of
working with quality data in a <CODE>SeqRecord</CODE> object. All we are going to
do here is read in a file of FASTQ data, and filter it to pick out only those
records whose PHRED quality scores are all above some threshold (here 20).</P><P>For this example we&#X2019;ll use some real data downloaded from the ENA sequence
read archive,
<A HREF="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz"><TT>ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz</TT></A>
(2MB) which unzips to a 19MB file <TT>SRR020192.fastq</TT>. This is some
Roche 454 GS FLX single end data from virus infected California sea lions
(see <A HREF="http://www.ebi.ac.uk/ena/data/view/SRS004476"><TT>http://www.ebi.ac.uk/ena/data/view/SRS004476</TT></A> for details).</P><P>First, let&#X2019;s count the reads:</P><PRE CLASS="verbatim">from Bio import SeqIO
count = 0
for rec in SeqIO.parse("SRR020192.fastq", "fastq"):
    count += 1
print "%i reads" % count
</PRE><P>Now let&#X2019;s do a simple filtering for a minimum PHRED quality of 20:</P><PRE CLASS="verbatim">from Bio import SeqIO
good_reads = (rec for rec in \
              SeqIO.parse("SRR020192.fastq", "fastq") \
              if min(rec.letter_annotations["phred_quality"]) &gt;= 20)
count = SeqIO.write(good_reads, "good_quality.fastq", "fastq")
print "Saved %i reads" % count
</PRE><P>This pulled out only 14580 reads out of the 41892 present.
A more sensible thing to do would be to quality trim the reads, but this
is intended as an example only.</P><P>FASTQ files can contain millions of entries, so it is best to avoid loading
them all into memory at once. This example uses a generator expression, which
means only one <CODE>SeqRecord</CODE> is created at a time - avoiding any memory
limitations.</P><!--TOC subsection Trimming off primer sequences-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc225">16.1.7</A>&#XA0;&#XA0;Trimming off primer sequences</H3><!--SEC END --><P>
<A NAME="sec:FASTQ-slicing-off-primer"></A></P><P>For this example we&#X2019;re going to pretend that <TT>GATGACGGTGT</TT> is a 5&#X2019; primer
sequence we want to look for in some FASTQ formatted read data. As in the example
above, we&#X2019;ll use the <TT>SRR020192.fastq</TT> file downloaded from the ENA
(<A HREF="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz"><TT>ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz</TT></A>).
The same approach would work with any other supported file format (e.g. FASTA files).</P><P>This code uses <CODE>Bio.SeqIO</CODE> with a generator expression (to avoid loading
all the sequences into memory at once), and the <CODE>Seq</CODE> object&#X2019;s
<CODE>startswith</CODE> method to see if the read starts with the primer sequence:</P><PRE CLASS="verbatim">from Bio import SeqIO
primer_reads = (rec for rec in \
                SeqIO.parse("SRR020192.fastq", "fastq") \
                if rec.seq.startswith("GATGACGGTGT"))
count = SeqIO.write(primer_reads, "with_primer.fastq", "fastq")
print "Saved %i reads" % count
</PRE><P>That should find 13819 reads from <TT>SRR014849.fastq</TT> and save them to
a new FASTQ file, <TT>with_primer.fastq</TT>.</P><P>Now suppose that instead you wanted to make a FASTQ file containing these reads
but with the primer sequence removed? That&#X2019;s just a small change as we can slice the
<CODE>SeqRecord</CODE> (see Section&#XA0;<A HREF="#sec:SeqRecord-slicing">4.7</A>) to remove the first eleven
letters (the length of our primer):</P><PRE CLASS="verbatim">from Bio import SeqIO
trimmed_primer_reads = (rec[11:] for rec in \
                        SeqIO.parse("SRR020192.fastq", "fastq") \
                        if rec.seq.startswith("GATGACGGTGT"))
count = SeqIO.write(trimmed_primer_reads, "with_primer_trimmed.fastq", "fastq")
print "Saved %i reads" % count
</PRE><P>Again, that should pull out the 13819 reads from <TT>SRR020192.fastq</TT>,
but this time strip off the first ten characters, and save them to another new
FASTQ file, <TT>with_primer_trimmed.fastq</TT>.</P><P>Finally, suppose you want to create a new FASTQ file where these reads have
their primer removed, but all the other reads are kept as they were?
If we want to still use a generator expression, it is probably clearest to
define our own trim function:</P><PRE CLASS="verbatim">from Bio import SeqIO
def trim_primer(record, primer):
    if record.seq.startswith(primer):
        return record[len(primer):]
    else:
        return record

trimmed_reads = (trim_primer(record, "GATGACGGTGT") for record in \
                 SeqIO.parse("SRR020192.fastq", "fastq"))
count = SeqIO.write(trimmed_reads, "trimmed.fastq", "fastq")
print "Saved %i reads" % count
</PRE><P>This takes longer, as this time the output file contains all 41892 reads.
Again, we&#X2019;re used a generator expression to avoid any memory problems.
You could alternatively use a generator function rather than a generator
expression.</P><PRE CLASS="verbatim">from Bio import SeqIO
def trim_primers(records, primer):
    """Removes perfect primer sequences at start of reads.
    
    This is a generator function, the records argument should
    be a list or iterator returning SeqRecord objects.
    """
    len_primer = len(primer) #cache this for later
    for record in records:
        if record.seq.startswith(primer):
            yield record[len_primer:]
        else:
            yield record

original_reads = SeqIO.parse("SRR020192.fastq", "fastq")
trimmed_reads = trim_primers(original_reads, "GATGACGGTGT")
count = SeqIO.write(trimmed_reads, "trimmed.fastq", "fastq") 
print "Saved %i reads" % count
</PRE><P>This form is more flexible if you want to do something more complicated
where only some of the records are retained &#X2013; as shown in the next example.</P><!--TOC subsection Trimming off adaptor sequences-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc226">16.1.8</A>&#XA0;&#XA0;Trimming off adaptor sequences</H3><!--SEC END --><P>
<A NAME="sec:FASTQ-slicing-off-adaptor"></A></P><P>This is essentially a simple extension to the previous example. We are going
to going to pretend <TT>GATGACGGTGT</TT> is an adaptor sequence in some FASTQ
formatted read data, again the <TT>SRR020192.fastq</TT> file from the NCBI
(<A HREF="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz"><TT>ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz</TT></A>).</P><P>This time however, we will look for the sequence <EM>anywhere</EM> in the reads,
not just at the very beginning:</P><PRE CLASS="verbatim">from Bio import SeqIO

def trim_adaptors(records, adaptor):
    """Trims perfect adaptor sequences.
    
    This is a generator function, the records argument should
    be a list or iterator returning SeqRecord objects.
    """
    len_adaptor = len(adaptor) #cache this for later
    for record in records:
        index = record.seq.find(adaptor)
        if index == -1:
            #adaptor not found, so won't trim
            yield record
        else:
            #trim off the adaptor
            yield record[index+len_adaptor:]

original_reads = SeqIO.parse("SRR020192.fastq", "fastq")
trimmed_reads = trim_adaptors(original_reads, "GATGACGGTGT")
count = SeqIO.write(trimmed_reads, "trimmed.fastq", "fastq") 
print "Saved %i reads" % count
</PRE><P>Because we are using a FASTQ input file in this example, the <CODE>SeqRecord</CODE>
objects have per-letter-annotation for the quality scores. By slicing the
<CODE>SeqRecord</CODE> object the appropriate scores are used on the trimmed
records, so we can output them as a FASTQ file too.</P><P>Compared to the output of the previous example where we only looked for
a primer/adaptor at the start of each read, you may find some of the
trimmed reads are quite short after trimming (e.g. if the adaptor was
found in the middle rather than near the start). So, let&#X2019;s add a minimum
length requirement as well:</P><PRE CLASS="verbatim">from Bio import SeqIO

def trim_adaptors(records, adaptor, min_len):
    """Trims perfect adaptor sequences, checks read length.
    
    This is a generator function, the records argument should
    be a list or iterator returning SeqRecord objects.
    """
    len_adaptor = len(adaptor) #cache this for later
    for record in records:
        len_record = len(record) #cache this for later
        if len(record) &lt; min_len:
           #Too short to keep
           continue
        index = record.seq.find(adaptor)
        if index == -1:
            #adaptor not found, so won't trim
            yield record
        elif len_record - index - len_adaptor &gt;= min_len:
            #after trimming this will still be long enough
            yield record[index+len_adaptor:]

original_reads = SeqIO.parse("SRR020192.fastq", "fastq")
trimmed_reads = trim_adaptors(original_reads, "GATGACGGTGT", 100)
count = SeqIO.write(trimmed_reads, "trimmed.fastq", "fastq") 
print "Saved %i reads" % count
</PRE><P>By changing the format names, you could apply this to FASTA files instead.
This code also could be extended to do a fuzzy match instead of an exact
match (maybe using a pairwise alignment, or taking into account the read
quality scores), but that will be much slower.</P><!--TOC subsection Converting FASTQ files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc227">16.1.9</A>&#XA0;&#XA0;Converting FASTQ files</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-fastq-conversion"></A></P><P>Back in Section&#XA0;<A HREF="#sec:SeqIO-conversion">5.5.2</A> we showed how to use
<CODE>Bio.SeqIO</CODE> to convert between two file formats. Here we&#X2019;ll go into a
little more detail regarding FASTQ files which are used in second generation
DNA sequencing. Please refer to Cock <I>et al.</I> (2009)
<A HREF="http://dx.doi.org/10.1093/nar/gkp1137">doi:10.1093/nar/gkp1137</A> for
a longer description. FASTQ files store both the DNA sequence (as a string)
and the associated read qualities. </P><P>PHRED scores (used in most FASTQ files, and also in QUAL files, ACE files
and SFF files) have become a <I>de facto</I> standard for representing
the probability of a sequencing error (here denoted by <I>P</I><SUB><I>e</I></SUB>) at a given
base using a simple base ten log transformation:</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<I>Q</I><SUB>PHRED</SUB>&#XA0;=&#XA0;&#X2212;&#XA0;10&#XA0;&#XD7;&#XA0;log<SUB>10</SUB>&#XA0;(&#XA0;<I>P</I><SUB><I>e</I></SUB>&#XA0;)
&#XA0;&#XA0;&#XA0;&#XA0;(16.1)</TD></TR>
</TABLE><P>This means a wrong read (<I>P</I><SUB><I>e</I></SUB> = 1) gets a PHRED quality of 0, while a very
good read like <I>P</I><SUB><I>e</I></SUB> = 0.00001 gets a PHRED quality of 50. While for raw
sequencing data qualities higher than this are rare, with post processing
such as read mapping or assembly, qualities of up to about 90 are possible
(indeed, the MAQ tool allows for PHRED scores in the range 0 to 93 inclusive).</P><P>The FASTQ format has the potential to become a <I>de facto</I> standard for
storing the letters and quality scores for a sequencing read in a single plain
text file. The only fly in the ointment is that there are at least three
versions of the FASTQ format which are incompatible and difficult to
distinguish...</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The original Sanger FASTQ format uses PHRED qualities encoded with an
ASCII offset of 33. The NCBI are using this format in their Short Read
Archive. We call this the <TT>fastq</TT> (or <TT>fastq-sanger</TT>) format
in <CODE>Bio.SeqIO</CODE>.
</LI><LI CLASS="li-enumerate">Solexa (later bought by Illumina) introduced their own version using
Solexa qualities encoded with an ASCII offset of 64. We call this the
<TT>fastq-solexa</TT> format.
</LI><LI CLASS="li-enumerate">Illumina pipeline 1.3 onwards produces FASTQ files with PHRED qualities
(which is more consistent), but encoded with an ASCII offset of 64. We call
this the <TT>fastq-illumina</TT> format.
</LI></OL><P>The Solexa quality scores are defined using a different log transformation:</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<I>Q</I><SUB>Solexa</SUB>&#XA0;=&#XA0;&#X2212;&#XA0;10&#XA0;&#XD7;&#XA0;log<SUB>10</SUB>&#XA0;</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>e</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1&#X2212;<I>P</I><SUB><I>e</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#XA0;</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">
&#XA0;&#XA0;&#XA0;&#XA0;(16.2)</TD></TR>
</TABLE><P>Given Solexa/Illumina have now moved to using PHRED scores in version 1.3 of
their pipeline, the Solexa quality scores will gradually fall out of use.
If you equate the error estimates (<I>P</I><SUB><I>e</I></SUB>) these two equations allow conversion
between the two scoring systems - and Biopython includes functions to do this
in the <CODE>Bio.SeqIO.QualityIO</CODE> module, which are called if you use
<CODE>Bio.SeqIO</CODE> to convert an old Solexa/Illumina file into a standard Sanger
FASTQ file:</P><PRE CLASS="verbatim">from Bio import SeqIO
SeqIO.convert("solexa.fastq", "fastq-solexa", "standard.fastq", "fastq")
</PRE><P>If you want to convert a new Illumina 1.3+ FASTQ file, all that gets changed
is the ASCII offset because although encoded differently the scores are all
PHRED qualities:</P><PRE CLASS="verbatim">from Bio import SeqIO
SeqIO.convert("illumina.fastq", "fastq-illumina", "standard.fastq", "fastq")
</PRE><P>Note that using <CODE>Bio.SeqIO.convert()</CODE> like this is <EM>much</EM> faster
than combining <CODE>Bio.SeqIO.parse()</CODE> and <CODE>Bio.SeqIO.write()</CODE>
because optimised code is used for converting between FASTQ variants
(and also for FASTQ to FASTA conversion).</P><P>For good quality reads, PHRED and Solexa scores are approximately equal,
which means since both the <TT>fasta-solexa</TT> and <TT>fastq-illumina</TT>
formats use an ASCII offset of 64 the files are almost the same. This was a
deliberate design choice by Illumina, meaning applications expecting the old
<TT>fasta-solexa</TT> style files will probably be OK using the newer
<TT>fastq-illumina</TT> files (on good data). Of course, both variants are
very different from the original FASTQ standard as used by Sanger,
the NCBI, and elsewhere (format name <TT>fastq</TT> or <TT>fastq-sanger</TT>).</P><P>For more details, see the built in help (also <A HREF="http://www.biopython.org/DIST/docs/api/Bio.SeqIO.QualityIO-module.html">online</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.SeqIO import QualityIO
&gt;&gt;&gt; help(QualityIO)
...
</PRE><!--TOC subsection Converting FASTA and QUAL files into FASTQ files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc228">16.1.10</A>&#XA0;&#XA0;Converting FASTA and QUAL files into FASTQ files</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-fasta-qual-conversion"></A></P><P>FASTQ files hold <EM>both</EM> sequences and their quality strings.
FASTA files hold <EM>just</EM> sequences, while QUAL files hold <EM>just</EM>
the qualities. Therefore a single FASTQ file can be converted to or from
<EM>paired</EM> FASTA and QUAL files.</P><P>Going from FASTQ to FASTA is easy:</P><PRE CLASS="verbatim">from Bio import SeqIO
SeqIO.convert("example.fastq", "fastq", "example.fasta", "fasta")
</PRE><P>Going from FASTQ to QUAL is also easy:</P><PRE CLASS="verbatim">from Bio import SeqIO
SeqIO.convert("example.fastq", "fastq", "example.qual", "qual")
</PRE><P>However, the reverse is a little more tricky. You can use <CODE>Bio.SeqIO.parse()</CODE>
to iterate over the records in a <EM>single</EM> file, but in this case we have
two input files. There are several strategies possible, but assuming that the
two files are really paired the most memory efficient way is to loop over both
together. The code is a little fiddly, so we provide a function called
<CODE>PairedFastaQualIterator</CODE> in the <CODE>Bio.SeqIO.QualityIO</CODE> module to do
this. This takes two handles (the FASTA file and the QUAL file) and returns
a <CODE>SeqRecord</CODE> iterator:</P><PRE CLASS="verbatim">from Bio.SeqIO.QualityIO import PairedFastaQualIterator
for record in PairedFastaQualIterator(open("example.fasta"), open("example.qual")):
   print record
</PRE><P>This function will check that the FASTA and QUAL files are consistent (e.g.
the records are in the same order, and have the same sequence length).
You can combine this with the <CODE>Bio.SeqIO.write()</CODE> function to convert a
pair of FASTA and QUAL files into a single FASTQ files:</P><PRE CLASS="verbatim">from Bio import SeqIO
from Bio.SeqIO.QualityIO import PairedFastaQualIterator
handle = open("temp.fastq", "w") #w=write
records = PairedFastaQualIterator(open("example.fasta"), open("example.qual"))
count = SeqIO.write(records, handle, "fastq")
handle.close()
print "Converted %i records" % count
</PRE><!--TOC subsection Indexing a FASTQ file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc229">16.1.11</A>&#XA0;&#XA0;Indexing a FASTQ file</H3><!--SEC END --><P>
<A NAME="sec:fastq-indexing"></A></P><P>FASTQ files are often very large, with millions of reads in them. Due to the
sheer amount of data, you can&#X2019;t load all the records into memory at once.
This is why the examples above (filtering and trimming) iterate over the file
looking at just one <CODE>SeqRecord</CODE> at a time.</P><P>However, sometimes you can&#X2019;t use a big loop or an iterator - you may need
random access to the reads. Here the <CODE>Bio.SeqIO.index()</CODE> function
may prove very helpful, as it allows you to access any read in the FASTQ file
by its name (see Section&#XA0;<A HREF="#sec:SeqIO-index">5.4.2</A>).</P><P>Again we&#X2019;ll use the <TT>SRR020192.fastq</TT> file from the ENA
(<A HREF="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz"><TT>ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz</TT></A>),
although this is actually quite a small FASTQ file with less than 50,000 reads:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; fq_dict = SeqIO.index("SRR020192.fastq", "fastq")
&gt;&gt;&gt; len(fq_dict)
41892
&gt;&gt;&gt; fq_dict.keys()[:4]
['SRR020192.38240', 'SRR020192.23181', 'SRR020192.40568', 'SRR020192.23186']
&gt;&gt;&gt; fq_dict["SRR020192.23186"].seq
Seq('GTCCCAGTATTCGGATTTGTCTGCCAAAACAATGAAATTGACACAGTTTACAAC...CCG', SingleLetterAlphabet())
</PRE><P>When testing this on a FASTQ file with seven million reads,
indexing took about a minute, but record access was almost instant.</P><P>The example in Section&#XA0;<A HREF="#sec:SeqIO-sort">16.1.5</A> show how you can use the
<CODE>Bio.SeqIO.index()</CODE> function to sort a large FASTA file &#X2013; this
could also be used on FASTQ files.</P><!--TOC subsection Converting SFF files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc230">16.1.12</A>&#XA0;&#XA0;Converting SFF files</H3><!--SEC END --><P>
<A NAME="sec:SeqIO-sff-conversion"></A></P><P>If you work with 454 (Roche) sequence data, you will probably have access
to the raw data as an Standard Flowgram Format (SFF) file. This contains
the sequence reads (called bases) with quality scores and the original
flow information.</P><P>A common task is to convert from SFF to a pair of FASTA and QUAL files,
or to a single FASTQ file. These operations are trivial using the
<CODE>Bio.SeqIO.convert()</CODE> function (see Section&#XA0;<A HREF="#sec:SeqIO-conversion">5.5.2</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff", "reads.fasta", "fasta")
10
&gt;&gt;&gt; SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff", "reads.qual", "qual")
10
&gt;&gt;&gt; SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff", "reads.fastq", "fastq")
10
</PRE><P>Remember the convert function returns the number of records, in
this example just ten. This will give you the <EM>untrimmed</EM> reads, where
the leading and trailing poor quality sequence or adaptor will be in lower
case. If you want the <EM>trimmed</EM> reads (using the clipping information
recorded within the SFF file) use this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff-trim", "trimmed.fasta", "fasta")
10
&gt;&gt;&gt; SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff-trim", "trimmed.qual", "qual")
10
&gt;&gt;&gt; SeqIO.convert("E3MFGYR02_random_10_reads.sff", "sff-trim", "trimmed.fastq", "fastq")
10
</PRE><P>If you run Linux, you could ask Roche for a copy of their &#X201C;off instrument&#X201D;
tools (often referred to as the Newbler tools). This offers an alternative way to
do SFF to FASTA or QUAL conversion at the command line (but currently FASTQ output
is not supported), e.g.</P><PRE CLASS="verbatim">$ sffinfo -seq -notrim E3MFGYR02_random_10_reads.sff &gt; reads.fasta
$ sffinfo -qual -notrim E3MFGYR02_random_10_reads.sff &gt; reads.qual
$ sffinfo -seq -trim E3MFGYR02_random_10_reads.sff &gt; trimmed.fasta
$ sffinfo -qual -trim E3MFGYR02_random_10_reads.sff &gt; trimmed.qual
</PRE><P>The way Biopython uses mixed case sequence strings to represent
the trimming points deliberately mimics what the Roche tools do.</P><P>For more information on the Biopython SFF support, consult the built in help:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.SeqIO import SffIO
&gt;&gt;&gt; help(SffIO)
...
</PRE><!--TOC subsection Identifying open reading frames-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc231">16.1.13</A>&#XA0;&#XA0;Identifying open reading frames</H3><!--SEC END --><P>A very simplistic first step at identifying possible genes is to look for
open reading frames (ORFs). By this we mean look in all six frames for long
regions without stop codons &#X2013; an ORF is just a region of nucleotides with
no in frame stop codons.</P><P>Of course, to find a gene you would also need to worry about locating a start
codon, possible promoters &#X2013; and in Eukaryotes there are introns to worry about
too. However, this approach is still useful in viruses and Prokaryotes.</P><P>To show how you might approach this with Biopython, we&#X2019;ll need a sequence to
search, and as an example we&#X2019;ll again use the bacterial plasmid &#X2013; although
this time we&#X2019;ll start with a plain FASTA file with no pre-marked genes:
<A HREF="http://biopython.org/SRC/biopython/Tests/GenBank/NC_005816.fna"><TT>NC_005816.fna</TT></A>. This is a bacterial sequence, so we&#X2019;ll want to use
NCBI codon table 11 (see Section&#XA0;<A HREF="#sec:translation">3.9</A> about translation).</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO 
&gt;&gt;&gt; record = SeqIO.read("NC_005816.fna","fasta")
&gt;&gt;&gt; table = 11
&gt;&gt;&gt; min_pro_len = 100
</PRE><P>Here is a neat trick using the <CODE>Seq</CODE> object&#X2019;s <CODE>split</CODE> method to
get a list of all the possible ORF translations in the six reading frames:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for strand, nuc in [(+1, record.seq), (-1, record.seq.reverse_complement())]:
...     for frame in range(3):
...         for pro in nuc[frame:].translate(table).split("*"):
...             if len(pro) &gt;= min_pro_len:
...                 print "%s...%s - length %i, strand %i, frame %i" \
...                       % (pro[:30], pro[-3:], len(pro), strand, frame)
GCLMKKSSIVATIITILSGSANAASSQLIP...YRF - length 315, strand 1, frame 0
KSGELRQTPPASSTLHLRLILQRSGVMMEL...NPE - length 285, strand 1, frame 1
GLNCSFFSICNWKFIDYINRLFQIIYLCKN...YYH - length 176, strand 1, frame 1
VKKILYIKALFLCTVIKLRRFIFSVNNMKF...DLP - length 165, strand 1, frame 1
NQIQGVICSPDSGEFMVTFETVMEIKILHK...GVA - length 355, strand 1, frame 2
RRKEHVSKKRRPQKRPRRRRFFHRLRPPDE...PTR - length 128, strand 1, frame 2
TGKQNSCQMSAIWQLRQNTATKTRQNRARI...AIK - length 100, strand 1, frame 2
QGSGYAFPHASILSGIAMSHFYFLVLHAVK...CSD - length 114, strand -1, frame 0
IYSTSEHTGEQVMRTLDEVIASRSPESQTR...FHV - length 111, strand -1, frame 0
WGKLQVIGLSMWMVLFSQRFDDWLNEQEDA...ESK - length 125, strand -1, frame 1
RGIFMSDTMVVNGSGGVPAFLFSGSTLSSY...LLK - length 361, strand -1, frame 1
WDVKTVTGVLHHPFHLTFSLCPEGATQSGR...VKR - length 111, strand -1, frame 1
LSHTVTDFTDQMAQVGLCQCVNVFLDEVTG...KAA - length 107, strand -1, frame 2
RALTGLSAPGIRSQTSCDRLRELRYVPVSL...PLQ - length 119, strand -1, frame 2
</PRE><P>Note that here we are counting the frames from the 5&#X2019; end (start) of
<EM>each</EM> strand. It is sometimes easier to always count from the 5&#X2019; end
(start) of the <EM>forward</EM> strand.</P><P>You could easily edit the above loop based code to build up a list of the
candidate proteins, or convert this to a list comprehension. Now, one thing
this code doesn&#X2019;t do is keep track of where the proteins are.</P><P>You could tackle this in several ways. For example, the following code tracks
the locations in terms of the protein counting, and converts back to the
parent sequence by multiplying by three, then adjusting for the frame and
strand:</P><PRE CLASS="verbatim">from Bio import SeqIO 
record = SeqIO.read("NC_005816.gb","genbank")
table = 11
min_pro_len = 100

def find_orfs_with_trans(seq, trans_table, min_protein_length):
    answer = []
    seq_len = len(seq)
    for strand, nuc in [(+1, seq), (-1, seq.reverse_complement())]:
        for frame in range(3):
            trans = str(nuc[frame:].translate(trans_table))
            trans_len = len(trans)
            aa_start = 0
            aa_end = 0
            while aa_start &lt; trans_len:
                aa_end = trans.find("*", aa_start)
                if aa_end == -1:
                    aa_end = trans_len
                if aa_end-aa_start &gt;= min_protein_length:
                    if strand == 1:
                        start = frame+aa_start*3
                        end = min(seq_len,frame+aa_end*3+3)
                    else:
                        start = seq_len-frame-aa_end*3-3
                        end = seq_len-frame-aa_start*3                        
                    answer.append((start, end, strand,
                                   trans[aa_start:aa_end]))
                aa_start = aa_end+1
    answer.sort()
    return answer

orf_list = find_orfs_with_trans(record.seq, table, min_pro_len)
for start, end, strand, pro in orf_list:
    print "%s...%s - length %i, strand %i, %i:%i" \
          % (pro[:30], pro[-3:], len(pro), strand, start, end)
</PRE><P>And the output:</P><PRE CLASS="verbatim">NQIQGVICSPDSGEFMVTFETVMEIKILHK...GVA - length 355, strand 1, 41:1109
WDVKTVTGVLHHPFHLTFSLCPEGATQSGR...VKR - length 111, strand -1, 491:827
KSGELRQTPPASSTLHLRLILQRSGVMMEL...NPE - length 285, strand 1, 1030:1888
RALTGLSAPGIRSQTSCDRLRELRYVPVSL...PLQ - length 119, strand -1, 2830:3190
RRKEHVSKKRRPQKRPRRRRFFHRLRPPDE...PTR - length 128, strand 1, 3470:3857
GLNCSFFSICNWKFIDYINRLFQIIYLCKN...YYH - length 176, strand 1, 4249:4780
RGIFMSDTMVVNGSGGVPAFLFSGSTLSSY...LLK - length 361, strand -1, 4814:5900
VKKILYIKALFLCTVIKLRRFIFSVNNMKF...DLP - length 165, strand 1, 5923:6421
LSHTVTDFTDQMAQVGLCQCVNVFLDEVTG...KAA - length 107, strand -1, 5974:6298
GCLMKKSSIVATIITILSGSANAASSQLIP...YRF - length 315, strand 1, 6654:7602
IYSTSEHTGEQVMRTLDEVIASRSPESQTR...FHV - length 111, strand -1, 7788:8124
WGKLQVIGLSMWMVLFSQRFDDWLNEQEDA...ESK - length 125, strand -1, 8087:8465
TGKQNSCQMSAIWQLRQNTATKTRQNRARI...AIK - length 100, strand 1, 8741:9044
QGSGYAFPHASILSGIAMSHFYFLVLHAVK...CSD - length 114, strand -1, 9264:9609
</PRE><P>If you comment out the sort statement, then the protein sequences will be
shown in the same order as before, so you can check this is doing the same
thing. Here we have sorted them by location to make it easier to compare
to the actual annotation in the GenBank file (as visualised in
Section&#XA0;<A HREF="#sec:gd_nice_example">15.1.8</A>).</P><P>If however all you want to find are the locations of the open reading frames,
then it is a waste of time to translate every possible codon, including doing
the reverse complement to search the reverse strand too. All you need to do
is search for the possible stop codons (and their reverse complements). Using
regular expressions is an obvious approach here (see the Python module
<CODE>re</CODE>). These are an extremely powerful (but rather complex) way of
describing search strings, which are supported in lots of programming
languages and also command line tools like <TT>grep</TT> as well). You can
find whole books about this topic!</P><!--TOC section Sequence parsing plus simple plots-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc232">16.2</A>&#XA0;&#XA0;Sequence parsing plus simple plots</H2><!--SEC END --><P>
<A NAME="seq:sequence-parsing-plus-pylab"></A></P><P>This section shows some more examples of sequence parsing, using the <CODE>Bio.SeqIO</CODE>
module described in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>, plus the Python library matplotlib&#X2019;s <CODE>pylab</CODE> plotting interface (see <A HREF="http://matplotlib.sourceforge.net/">the matplotlib website for a tutorial</A>). Note that to follow these examples you will need matplotlib installed - but without it you can still try the data parsing bits.</P><!--TOC subsection Histogram of sequence lengths-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc233">16.2.1</A>&#XA0;&#XA0;Histogram of sequence lengths</H3><!--SEC END --><P>There are lots of times when you might want to visualise the distribution of sequence
lengths in a dataset &#X2013; for example the range of contig sizes in a genome assembly
project. In this example we&#X2019;ll reuse our orchid FASTA file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta"><TT>ls_orchid.fasta</TT></A> which has only 94 sequences.</P><P>First of all, we will use <CODE>Bio.SeqIO</CODE> to parse the FASTA file and compile a list
of all the sequence lengths. You could do this with a for loop, but I find a list
comprehension more pleasing:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; sizes = [len(rec) for rec in SeqIO.parse("ls_orchid.fasta", "fasta")]
&gt;&gt;&gt; len(sizes), min(sizes), max(sizes)
(94, 572, 789)
&gt;&gt;&gt; sizes
[740, 753, 748, 744, 733, 718, 730, 704, 740, 709, 700, 726, ..., 592]
</PRE><P>Now that we have the lengths of all the genes (as a list of integers), we can use the
matplotlib histogram function to display it.</P><PRE CLASS="verbatim">from Bio import SeqIO
sizes = [len(rec) for rec in SeqIO.parse("ls_orchid.fasta", "fasta")]

import pylab
pylab.hist(sizes, bins=20)
pylab.title("%i orchid sequences\nLengths %i to %i" \
            % (len(sizes),min(sizes),max(sizes)))
pylab.xlabel("Sequence length (bp)")
pylab.ylabel("Count")
pylab.show()
</PRE><P>
That should pop up a new window containing the following graph:</P><P><IMG SRC="images/hist_plot.png" width=600, height=450></P><P>

Notice that most of these orchid sequences are about 740 bp long, and there could be
two distinct classes of sequence here with a subset of shorter sequences.</P><P><EM>Tip:</EM> Rather than using <CODE>pylab.show()</CODE> to show the plot in a window, you can also use <CODE>pylab.savefig(...)</CODE> to save the figure to a file (e.g. as a PNG or PDF).</P><!--TOC subsection Plot of sequence GC%-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc234">16.2.2</A>&#XA0;&#XA0;Plot of sequence GC%</H3><!--SEC END --><P>Another easily calculated quantity of a nucleotide sequence is the GC%. You might
want to look at the GC% of all the genes in a bacterial genome for example, and
investigate any outliers which could have been recently acquired by horizontal gene
transfer. Again, for this example we&#X2019;ll reuse our orchid FASTA file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta"><TT>ls_orchid.fasta</TT></A>.</P><P>First of all, we will use <CODE>Bio.SeqIO</CODE> to parse the FASTA file and compile a list
of all the GC percentages. Again, you could do this with a for loop, but I prefer this:</P><PRE CLASS="verbatim">from Bio import SeqIO
from Bio.SeqUtils import GC

gc_values = sorted(GC(rec.seq) for rec in SeqIO.parse("ls_orchid.fasta", "fasta"))
</PRE><P>Having read in each sequence and calculated the GC%, we then sorted them into ascending
order. Now we&#X2019;ll take this list of floating point values and plot them with matplotlib:</P><PRE CLASS="verbatim">import pylab
pylab.plot(gc_values)
pylab.title("%i orchid sequences\nGC%% %0.1f to %0.1f" \
            % (len(gc_values),min(gc_values),max(gc_values)))
pylab.xlabel("Genes")
pylab.ylabel("GC%")
pylab.show()
</PRE><P>
As in the previous example, that should pop up a new window containing a graph:</P><P><IMG SRC="images/gc_plot.png" width=600, height=450></P><P>

If you tried this on the full set of genes from one organism, you&#X2019;d probably get a much
smoother plot than this.</P><!--TOC subsection Nucleotide dot plots-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc235">16.2.3</A>&#XA0;&#XA0;Nucleotide dot plots</H3><!--SEC END --><P>
A dot plot is a way of visually comparing two nucleotide sequences for similarity to
each other. A sliding window is used to compare short sub-sequences to each other,
often with a mis-match threshold. Here for simplicity we&#X2019;ll only look for perfect
matches (shown in black


in the plot below).
</P><P>To start off, we&#X2019;ll need two sequences. For the sake of argument, we&#X2019;ll just take
the first two from our orchid FASTA file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta"><TT>ls_orchid.fasta</TT></A>:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.fasta")
record_iterator = SeqIO.parse(handle, "fasta")
rec_one = record_iterator.next()
rec_two = record_iterator.next()
handle.close()
</PRE><P>We&#X2019;re going to show two approaches. Firstly, a simple naive implementation
which compares all the window sized sub-sequences to each other to compiles a
similarity matrix. You could construct a matrix or array object, but here we
just use a list of lists of booleans created with a nested list
comprehension:</P><PRE CLASS="verbatim">window = 7
seq_one = str(rec_one.seq).upper()
seq_two = str(rec_two.seq).upper()
data = [[(seq_one[i:i+window] &lt;&gt; seq_two[j:j+window]) \
        for j in range(len(seq_one)-window)] \
       for i in range(len(seq_two)-window)]
</PRE><P>Note that we have <EM>not</EM> checked for reverse complement matches here.
Now we&#X2019;ll use the matplotlib&#X2019;s <CODE>pylab.imshow()</CODE> function to display this
data, first requesting the gray color scheme so this is done in black and
white:</P><PRE CLASS="verbatim">import pylab
pylab.gray()
pylab.imshow(data)
pylab.xlabel("%s (length %i bp)" % (rec_one.id, len(rec_one)))
pylab.ylabel("%s (length %i bp)" % (rec_two.id, len(rec_two)))
pylab.title("Dot plot using window size %i\n(allowing no mis-matches)" % window)
pylab.show()
</PRE><P>
That should pop up a new window containing a graph like this:</P><P><IMG SRC="images/dot_plot.png" width=600, height=450></P><P>

As you might have expected, these two sequences are very similar with a
partial line of window sized matches along the diagonal. There are no off
diagonal matches which would be indicative of inversions or other interesting
events.</P><P>The above code works fine on small examples, but there are two problems
applying this to larger sequences, which we will address below.
First off all, this brute force approach to the all against all comparisons
is very slow. Instead, we&#X2019;ll compile dictionaries mapping the window sized
sub-sequences to their locations, and then take the set intersection to find
those sub-sequences found in both sequences. This uses more memory, but is
<EM>much</EM> faster. Secondly, the <CODE>pylab.imshow()</CODE> function is limited
in the size of matrix it can display. As an alternative, we&#X2019;ll use the
<CODE>pylab.scatter()</CODE> function.</P><P>We start by creating dictionaries mapping the window-sized sub-sequences to locations:
</P><PRE CLASS="verbatim">window = 7
dict_one = {}
dict_two = {}
for (seq, section_dict) in [(str(rec_one.seq).upper(), dict_one),
                            (str(rec_two.seq).upper(), dict_two)]:
    for i in range(len(seq)-window):
        section = seq[i:i+window]
        try:
            section_dict[section].append(i)
        except KeyError:
            section_dict[section] = [i]
#Now find any sub-sequences found in both sequences
#(Python 2.3 would require slightly different code here)
matches = set(dict_one).intersection(dict_two)
print "%i unique matches" % len(matches)
</PRE><P>In order to use the <CODE>pylab.scatter()</CODE> we need separate lists for the <I>x</I> and <I>y</I> co-ordinates:
</P><PRE CLASS="verbatim">#Create lists of x and y co-ordinates for scatter plot
x = []
y = []
for section in matches:
    for i in dict_one[section]:
        for j in dict_two[section]:
            x.append(i)
            y.append(j)
</PRE><P>We are now ready to draw the revised dot plot as a scatter plot:
</P><PRE CLASS="verbatim">import pylab
pylab.cla() #clear any prior graph
pylab.gray()
pylab.scatter(x,y)
pylab.xlim(0, len(rec_one)-window)
pylab.ylim(0, len(rec_two)-window)
pylab.xlabel("%s (length %i bp)" % (rec_one.id, len(rec_one)))
pylab.ylabel("%s (length %i bp)" % (rec_two.id, len(rec_two)))
pylab.title("Dot plot using window size %i\n(allowing no mis-matches)" % window)
pylab.show()
</PRE><P>
That should pop up a new window containing a graph like this:</P><P><IMG SRC="images/dot_plot_scatter.png" width=600, height=450></P><P>

Personally I find this second plot much easier to read!
Again note that we have <EM>not</EM> checked for reverse complement matches here
&#X2013; you could extend this example to do this, and perhaps plot the forward
matches in one color and the reverse matches in another.</P><!--TOC subsection Plotting the quality scores of sequencing read data-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc236">16.2.4</A>&#XA0;&#XA0;Plotting the quality scores of sequencing read data</H3><!--SEC END --><P>If you are working with second generation sequencing data, you may want to try plotting
the quality data. Here is an example using two FASTQ files containing paired end reads,
<TT>SRR001666_1.fastq</TT> for the forward reads, and <TT>SRR001666_2.fastq</TT> for
the reverse reads. These were downloaded from the ENA sequence read archive FTP site
(<A HREF="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_1.fastq.gz"><TT>ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_1.fastq.gz</TT></A> and
<A HREF="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_2.fastq.gz"><TT>ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR001/SRR001666/SRR001666_2.fastq.gz</TT></A>), and
are from <I>E. coli</I> &#X2013; see <A HREF="http://www.ebi.ac.uk/ena/data/view/SRR001666"><TT>http://www.ebi.ac.uk/ena/data/view/SRR001666</TT></A>
for details.
</P><P>In the following code the <CODE>pylab.subplot(...)</CODE> function is used in order to show
the forward and reverse qualities on two subplots, side by side. There is also a little
bit of code to only plot the first fifty reads.</P><PRE CLASS="verbatim">import pylab
from Bio import SeqIO
for subfigure in [1,2]:
    filename = "SRR001666_%i.fastq" % subfigure
    pylab.subplot(1, 2, subfigure)
    for i,record in enumerate(SeqIO.parse(filename, "fastq")):
        if i &gt;= 50 : break #trick!
        pylab.plot(record.letter_annotations["phred_quality"])
    pylab.ylim(0,45)
    pylab.ylabel("PHRED quality score")
    pylab.xlabel("Position")
pylab.savefig("SRR001666.png")
print "Done"
</PRE><P>You should note that we are using the <CODE>Bio.SeqIO</CODE> format name <TT>fastq</TT>
here because the NCBI has saved these reads using the standard Sanger FASTQ format
with PHRED scores. However, as you might guess from the read lengths, this data was
from an Illumina Genome Analyzer and was probably originally in one of the two
Solexa/Illumina FASTQ variant file formats instead.</P><P>This example uses the <CODE>pylab.savefig(...)</CODE> function instead of
<CODE>pylab.show(...)</CODE>, but as mentioned before both are useful.


Here is the result:</P><P><IMG SRC="images/SRR001666.png" width=600, height=600></P><!--TOC section Dealing with alignments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc237">16.3</A>&#XA0;&#XA0;Dealing with alignments</H2><!--SEC END --><P>This section can been seen as a follow on to Chapter&#XA0;<A HREF="#chapter:Bio.AlignIO">6</A>.</P><!--TOC subsection Calculating summary information-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc238">16.3.1</A>&#XA0;&#XA0;Calculating summary information</H3><!--SEC END --><P>
<A NAME="sec:summary_info"></A></P><P>Once you have an alignment, you are very likely going to want to find out information about it. Instead of trying to have all of the functions that can generate information about an alignment in the alignment object itself, we&#X2019;ve tried to separate out the functionality into separate classes, which act on the alignment.</P><P>Getting ready to calculate summary information about an object is quick to do. Let&#X2019;s say we&#X2019;ve got an alignment object called <CODE>alignment</CODE>, for example read in using <CODE>Bio.AlignIO.read(...)</CODE> as described in Chapter&#XA0;<A HREF="#chapter:Bio.AlignIO">6</A>. All we need to do to get an object that will calculate summary information is:</P><PRE CLASS="verbatim">from Bio.Align import AlignInfo
summary_align = AlignInfo.SummaryInfo(alignment)
</PRE><P>The <CODE>summary_align</CODE> object is very useful, and will do the following neat things for you:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Calculate a quick consensus sequence &#X2013; see section&#XA0;<A HREF="#sec:consensus">16.3.2</A>
</LI><LI CLASS="li-enumerate">Get a position specific score matrix for the alignment &#X2013; see section&#XA0;<A HREF="#sec:pssm">16.3.3</A>
</LI><LI CLASS="li-enumerate">Calculate the information content for the alignment &#X2013; see section&#XA0;<A HREF="#sec:getting_info_content">16.3.4</A>
</LI><LI CLASS="li-enumerate">Generate information on substitutions in the alignment &#X2013; section&#XA0;<A HREF="#sec:sub_matrix">16.4</A> details using this to generate a substitution matrix.
</LI></OL><!--TOC subsection Calculating a quick consensus sequence-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc239">16.3.2</A>&#XA0;&#XA0;Calculating a quick consensus sequence</H3><!--SEC END --><P>
<A NAME="sec:consensus"></A></P><P>The <CODE>SummaryInfo</CODE> object, described in section&#XA0;<A HREF="#sec:summary_info">16.3.1</A>, provides functionality to calculate a quick consensus of an alignment. Assuming we&#X2019;ve got a <CODE>SummaryInfo</CODE> object called <CODE>summary_align</CODE> we can calculate a consensus by doing:</P><PRE CLASS="verbatim">consensus = summary_align.dumb_consensus()
</PRE><P>As the name suggests, this is a really simple consensus calculator, and will just add up all of the residues at each point in the consensus, and if the most common value is higher than some threshold value will add the common residue to the consensus. If it doesn&#X2019;t reach the threshold, it adds an ambiguity character to the consensus. The returned consensus object is Seq object whose alphabet is inferred from the alphabets of the sequences making up the consensus. So doing a <CODE>print consensus</CODE> would give:</P><PRE CLASS="verbatim">consensus Seq('TATACATNAAAGNAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
...', IUPACAmbiguousDNA())
</PRE><P>You can adjust how <CODE>dumb_consensus</CODE> works by passing optional parameters:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>the threshold</B></DT><DD CLASS="dd-description"> This is the threshold specifying how common a particular residue has to be at a position before it is added. The default is 0.7 (meaning 70%).</DD><DT CLASS="dt-description"><B>the ambiguous character</B></DT><DD CLASS="dd-description"> This is the ambiguity character to use. The default is &#X2019;N&#X2019;.</DD><DT CLASS="dt-description"><B>the consensus alphabet</B></DT><DD CLASS="dd-description"> This is the alphabet to use for the consensus sequence. If an alphabet is not specified than we will try to guess the alphabet based on the alphabets of the sequences in the alignment.
</DD></DL><!--TOC subsection Position Specific Score Matrices-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc240">16.3.3</A>&#XA0;&#XA0;Position Specific Score Matrices</H3><!--SEC END --><P>
<A NAME="sec:pssm"></A></P><P>Position specific score matrices (PSSMs) summarize the alignment information in a different way than a consensus, and may be useful for different tasks. Basically, a PSSM is a count matrix. For each column in the alignment, the number of each alphabet letters is counted and totaled. The totals are displayed relative to some representative sequence along the left axis. This sequence may be the consesus sequence, but can also be any sequence in the alignment. For instance for the alignment,</P><PRE CLASS="verbatim">GTATC
AT--C
CTGTC
</PRE><P>the PSSM is:</P><PRE CLASS="verbatim">      G A T C
    G 1 1 0 1
    T 0 0 3 0
    A 1 1 0 0
    T 0 0 2 0
    C 0 0 0 3
</PRE><P>Let&#X2019;s assume we&#X2019;ve got an alignment object called <CODE>c_align</CODE>. To get a PSSM with the consensus sequence along the side we first get a summary object and calculate the consensus sequence:</P><PRE CLASS="verbatim">summary_align = AlignInfo.SummaryInfo(c_align)
consensus = summary_align.dumb_consensus()
</PRE><P>Now, we want to make the PSSM, but ignore any <CODE>N</CODE> ambiguity residues when calculating this:</P><PRE CLASS="verbatim">my_pssm = summary_align.pos_specific_score_matrix(consensus,
                                                  chars_to_ignore = ['N'])
</PRE><P>Two notes should be made about this:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
To maintain strictness with the alphabets, you can only include characters along the top of the PSSM that are in the alphabet of the alignment object. Gaps are not included along the top axis of the PSSM.</LI><LI CLASS="li-enumerate">The sequence passed to be displayed along the left side of the axis does not need to be the consensus. For instance, if you wanted to display the second sequence in the alignment along this axis, you would need to do:<PRE CLASS="verbatim">second_seq = alignment.get_seq_by_num(1)
my_pssm = summary_align.pos_specific_score_matrix(second_seq
                                                  chars_to_ignore = ['N'])
</PRE></LI></OL><P>The command above returns a <CODE>PSSM</CODE> object. To print out the PSSM as we showed above, we simply need to do a <CODE>print my_pssm</CODE>, which gives:</P><PRE CLASS="verbatim">    A   C   G   T
T  0.0 0.0 0.0 7.0
A  7.0 0.0 0.0 0.0
T  0.0 0.0 0.0 7.0
A  7.0 0.0 0.0 0.0
C  0.0 7.0 0.0 0.0
A  7.0 0.0 0.0 0.0
T  0.0 0.0 0.0 7.0
T  1.0 0.0 0.0 6.0
...
</PRE><P>You can access any element of the PSSM by subscripting like <CODE>your_pssm[sequence_number][residue_count_name]</CODE>. For instance, to get the counts for the &#X2019;A&#X2019; residue in the second element of the above PSSM you would do:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print my_pssm[1]["A"]
7.0
</PRE><P>The structure of the PSSM class hopefully makes it easy both to access elements and to pretty print the matrix.</P><!--TOC subsection Information Content-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc241">16.3.4</A>&#XA0;&#XA0;Information Content</H3><!--SEC END --><P>
<A NAME="sec:getting_info_content"></A></P><P>A potentially useful measure of evolutionary conservation is the information content of a sequence.</P><P>A useful introduction to information theory targeted towards molecular biologists can be found at <A HREF="http://www.lecb.ncifcrf.gov/~toms/paper/primer/"><TT>http://www.lecb.ncifcrf.gov/~toms/paper/primer/</TT></A>. For our purposes, we will be looking at the information content of a consesus sequence, or a portion of a consensus sequence. We calculate information content at a particular column in a multiple sequence alignment using the following formula:</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>IC</I><SUB><I>j</I></SUB>&#XA0;=&#XA0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>a</I></SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#XA0;<I>P</I><SUB><I>ij</I></SUB>&#XA0;<I>log</I></TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>ij</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Q</I><SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>where:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>IC</I><SUB><I>j</I></SUB> &#X2013; The information content for the <I>j</I>-th column in an alignment.
</LI><LI CLASS="li-itemize"><I>N</I><SUB><I>a</I></SUB> &#X2013; The number of letters in the alphabet.
</LI><LI CLASS="li-itemize"><I>P</I><SUB><I>ij</I></SUB> &#X2013; The frequency of a particular letter <I>i</I> in the <I>j</I>-th column (i.&#XA0;e.&#XA0;if G occured 3 out of 6 times in an aligment column, this would be 0.5)
</LI><LI CLASS="li-itemize"><I>Q</I><SUB><I>i</I></SUB> &#X2013; The expected frequency of a letter <I>i</I>. This is an
optional argument, usage of which is left at the user&#X2019;s
discretion. By default, it is automatically assigned to 0.05 = 1/20 for a
protein alphabet, and 0.25 = 1/4 for a nucleic acid alphabet. This is for
geting the information content without any assumption of prior
distributions. When assuming priors, or when using a non-standard
alphabet, you should supply the values for <I>Q</I><SUB><I>i</I></SUB>.
</LI></UL><P>Well, now that we have an idea what information content is being calculated in Biopython, let&#X2019;s look at how to get it for a particular region of the alignment.</P><P>First, we need to use our alignment to get a alignment summary object, which we&#X2019;ll assume is called <CODE>summary_align</CODE> (see section&#XA0;<A HREF="#sec:summary_info">16.3.1</A>) for instructions on how to get this. Once we&#X2019;ve got this object, calculating the information content for a region is as easy as:</P><PRE CLASS="verbatim">info_content = summary_align.information_content(5, 30,
                                                 chars_to_ignore = ['N'])
</PRE><P>Wow, that was much easier then the formula above made it look! The variable <CODE>info_content</CODE> now contains a float value specifying the information content over the specified region (from 5 to 30 of the alignment). We specifically ignore the ambiguity residue &#X2019;N&#X2019; when calculating the information content, since this value is not included in our alphabet (so we shouldn&#X2019;t be interested in looking at it!).</P><P>As mentioned above, we can also calculate relative information content by supplying the expected frequencies:</P><PRE CLASS="verbatim">expect_freq = {
    'A' : .3,
    'G' : .2,
    'T' : .3,
    'C' : .2}
</PRE><P>The expected should not be passed as a raw dictionary, but instead by passed as a <CODE>SubsMat.FreqTable</CODE> object (see section&#XA0;<A HREF="#sec:freq_table">18.2.2</A> for more information about FreqTables). The FreqTable object provides a standard for associating the dictionary with an Alphabet, similar to how the Biopython Seq class works.</P><P>To create a FreqTable object, from the frequency dictionary you just need to do:</P><PRE CLASS="verbatim">from Bio.Alphabet import IUPAC
from Bio.SubsMat import FreqTable

e_freq_table = FreqTable.FreqTable(expect_freq, FreqTable.FREQ,
                                   IUPAC.unambiguous_dna)
</PRE><P>Now that we&#X2019;ve got that, calculating the relative information content for our region of the alignment is as simple as:</P><PRE CLASS="verbatim">info_content = summary_align.information_content(5, 30,
                                                 e_freq_table = e_freq_table,
                                                 chars_to_ignore = ['N'])
</PRE><P>Now, <CODE>info_content</CODE> will contain the relative information content over the region in relation to the expected frequencies.</P><P>The value return is calculated using base 2 as the logarithm base in the formula above. You can modify this by passing the parameter <CODE>log_base</CODE> as the base you want:</P><PRE CLASS="verbatim">info_content = summary_align.information_content(5, 30, log_base = 10,
                                                 chars_to_ignore = ['N'])
</PRE><P>Well, now you are ready to calculate information content. If you want to try applying this to some real life problems, it would probably be best to dig into the literature on information content to get an idea of how it is used. Hopefully your digging won&#X2019;t reveal any mistakes made in coding this function!</P><!--TOC section Substitution Matrices-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc242">16.4</A>&#XA0;&#XA0;Substitution Matrices</H2><!--SEC END --><P>
<A NAME="sec:sub_matrix"></A></P><P>Substitution matrices are an extremely important part of everyday bioinformatics work. They provide the scoring terms for classifying how likely two different residues are to substitute for each other. This is essential in doing sequence comparisons. The book &#X201C;Biological Sequence Analysis&#X201D; by Durbin et al. provides a really nice introduction to Substitution Matrices and their uses. Some famous substitution matrices are the PAM and BLOSUM series of matrices.</P><P>Biopython provides a ton of common substitution matrices, and also provides functionality for creating your own substitution matrices.</P><!--TOC subsection Using common substitution matrices-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc243">16.4.1</A>&#XA0;&#XA0;Using common substitution matrices</H3><!--SEC END --><!--TOC subsection Creating your own substitution matrix from an alignment-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc244">16.4.2</A>&#XA0;&#XA0;Creating your own substitution matrix from an alignment</H3><!--SEC END --><P>
<A NAME="sec:subs_mat_ex"></A></P><P>A very cool thing that you can do easily with the substitution matrix
classes is to create your own substitution matrix from an
alignment. In practice, this is normally done with protein
alignments. In this example, we&#X2019;ll first get a Biopython alignment
object and then get a summary object to calculate info about the
alignment. The file containing <A HREF="examples/protein.aln">protein.aln</A>
(also available online
<A HREF="http://biopython.org/DIST/docs/tutorial/examples/protein.aln">here</A>)
contains the Clustalw alignment output.</P><PRE CLASS="verbatim">from Bio import Clustalw
from Bio.Alphabet import IUPAC
from Bio.Align import AlignInfo

# get an alignment object from a Clustalw alignment output
c_align = Clustalw.parse_file("protein.aln", IUPAC.protein)
summary_align = AlignInfo.SummaryInfo(c_align)
</PRE><P>Sections&#XA0;<A HREF="#sec:align_clustal">6.4.1</A> and&#XA0;<A HREF="#sec:summary_info">16.3.1</A> contain
more information on doing this.</P><P>Now that we&#X2019;ve got our <CODE>summary_align</CODE> object, we want to use it
to find out the number of times different residues substitute for each
other. To make the example more readable, we&#X2019;ll focus on only amino
acids with polar charged side chains. Luckily, this can be done easily
when generating a replacement dictionary, by passing in all of the
characters that should be ignored. Thus we&#X2019;ll create a dictionary of
replacements for only charged polar amino acids using:</P><PRE CLASS="verbatim">replace_info = summary_align.replacement_dictionary(["G", "A", "V", "L", "I",
                                                     "M", "P", "F", "W", "S",
                                                     "T", "N", "Q", "Y", "C"])
</PRE><P>This information about amino acid replacements is represented as a
python dictionary which will look something like:</P><PRE CLASS="verbatim">{('R', 'R'): 2079.0, ('R', 'H'): 17.0, ('R', 'K'): 103.0, ('R', 'E'): 2.0,
('R', 'D'): 2.0, ('H', 'R'): 0, ('D', 'H'): 15.0, ('K', 'K'): 3218.0,
('K', 'H'): 24.0, ('H', 'K'): 8.0, ('E', 'H'): 15.0, ('H', 'H'): 1235.0,
('H', 'E'): 18.0, ('H', 'D'): 0, ('K', 'D'): 0, ('K', 'E'): 9.0,
('D', 'R'): 48.0, ('E', 'R'): 2.0, ('D', 'K'): 1.0, ('E', 'K'): 45.0,
('K', 'R'): 130.0, ('E', 'D'): 241.0, ('E', 'E'): 3305.0,
('D', 'E'): 270.0, ('D', 'D'): 2360.0}
</PRE><P>This information gives us our accepted number of replacements, or how
often we expect different things to substitute for each other. It
turns out, amazingly enough, that this is all of the information we
need to go ahead and create a substitution matrix. First, we use the
replacement dictionary information to create an Accepted Replacement
Matrix (ARM):</P><PRE CLASS="verbatim">from Bio import SubsMat
my_arm = SubsMat.SeqMat(replace_info)
</PRE><P>With this accepted replacement matrix, we can go right ahead and
create our log odds matrix (i.&#XA0;e.&#XA0;a standard type Substitution Matrix):</P><PRE CLASS="verbatim">my_lom = SubsMat.make_log_odds_matrix(my_arm)
</PRE><P>The log odds matrix you create is customizable with the following
optional arguments:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>exp_freq_table</CODE> &#X2013; You can pass a table of expected
frequencies for each alphabet. If supplied, this will be used
instead of the passed accepted replacement matrix when calculate
expected replacments.</LI><LI CLASS="li-itemize"><CODE>logbase</CODE> - The base of the logarithm taken to create the
log odd matrix. Defaults to base 10.</LI><LI CLASS="li-itemize"><CODE>factor</CODE> - The factor to multiply each matrix entry
by. This defaults to 10, which normally makes the matrix numbers
easy to work with.</LI><LI CLASS="li-itemize"><CODE>round_digit</CODE> - The digit to round to in the matrix. This
defaults to 0 (i.&#XA0;e.&#XA0;no digits).</LI></UL><P>Once you&#X2019;ve got your log odds matrix, you can display it prettily
using the function <CODE>print_mat</CODE>. Doing this on our created matrix
gives:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_lom.print_mat()
D   6
E  -5   5
H -15 -13  10
K -31 -15 -13   6
R -13 -25 -14  -7   7
   D   E   H   K   R
</PRE><P>Very nice. Now we&#X2019;ve got our very own substitution matrix to play with!</P><!--TOC section BioSQL &#X2013; storing sequences in a relational database-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc245">16.5</A>&#XA0;&#XA0;BioSQL &#X2013; storing sequences in a relational database</H2><!--SEC END --><P>
<A NAME="sec:BioSQL"></A>
<A HREF="http://www.biosql.org/">BioSQL</A> is a joint effort between the
<A HREF="http://open-bio.org/">OBF</A> projects (BioPerl, BioJava etc) to support a
shared database schema for storing sequence data. In theory, you could load a
GenBank file into the database with BioPerl, then using Biopython extract this
from the database as a record object with features - and get more or less the same
thing as if you had loaded the GenBank file directly as a SeqRecord using
<CODE>Bio.SeqIO</CODE> (Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">5</A>).</P><P>Biopython&#X2019;s BioSQL module is currently documented at
<A HREF="http://biopython.org/wiki/BioSQL"><TT>http://biopython.org/wiki/BioSQL</TT></A> which is part of our wiki pages.</P><!--TOC chapter The Biopython testing framework-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc246">Chapter&#XA0;17</A>&#XA0;&#XA0;The Biopython testing framework</H1><!--SEC END --><P>
<A NAME="sec:regr_test"></A></P><P>Biopython has a regression testing framework (the file
<CODE>run_tests.py</CODE>) based on
<A HREF="http://docs.python.org/library/unittest.html">unittest</A>,
the standard unit testing framework for Python. Providing comprehensive
tests for modules is one of the most important aspects of making sure that
the Biopython code is as bug-free as possible before going out.
It also tends to be one of the most undervalued aspects of contributing.
This chapter is designed to make running the Biopython tests and
writing good test code as easy as possible.
Ideally, every module that goes into Biopython
should have a test (and should also have documentation!).
All our developers, and anyone installing Biopython from source,
are strongly encouraged to run the unit tests.</P><!--TOC section Running the tests-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc247">17.1</A>&#XA0;&#XA0;Running the tests</H2><!--SEC END --><P>When you download the Biopython source code, or check it out from
our source code repository, you should find a subdirectory call
<CODE>Tests</CODE>. This contains the key script <CODE>run_tests.py</CODE>,
lots of individual scripts named <CODE>test_XXX.py</CODE>, a subdirectory
called <CODE>output</CODE> and lots of other subdirectories which
contain input files for the test suite.</P><P>As part of building and installing Biopython you will typically
run the full test suite at the command line from the Biopython
source top level directory using the following:
</P><PRE CLASS="verbatim">python setup.py test
</PRE><P>This is actually equivalent to going to the <CODE>Tests</CODE>
subdirectory and running:
</P><PRE CLASS="verbatim">python run_tests.py
</PRE><P>You&#X2019;ll often want to run just some of the tests, and this is done
like this:
</P><PRE CLASS="verbatim">python run_tests.py test_SeqIO.py test_AlignIO.py
</PRE><P>When giving the list of tests, the <CODE>.py</CODE> extension is optional,
so you can also just type:
</P><PRE CLASS="verbatim">python run_tests.py test_SeqIO test_AlignIO
</PRE><P>To run the docstring tests (see section <A HREF="#section:doctest">17.3</A>), you can use
</P><PRE CLASS="verbatim">python run_tests.py doctest
</PRE><P>By default, <CODE>run_tests.py</CODE> runs all tests, including the docstring tests.</P><P>If an individual test is failing, you can also try running it
directly, which may give you more information.</P><P>Importantly, note that the individual unit tests come in two types:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Simple print-and-compare scripts. These unit tests are
essentially short example Python programs, which print out
various output text. For a test file named <CODE>test_XXX.py</CODE>
there will be a matching text file called <CODE>test_XXX</CODE> under
the <CODE>output</CODE> subdirectory which contains the expected
output. All that the test framework does to is run the script,
and check the output agrees.
</LI><LI CLASS="li-itemize">Standard <CODE>unittest</CODE>- based tests. These will <CODE>import unittest</CODE>
and then define <CODE>unittest.TestCase</CODE> classes, each with one
or more sub-tests as methods starting with <CODE>test_</CODE> which
check some specific aspect of the code.
These tests should not print any output directly.
</LI></UL><P>
Currently, about half of the Biopython tests are <CODE>unittest</CODE>-style tests, and half are print-and-compare tests.</P><P>Running a simple print-and-compare test directly will usually give lots
of output on screen, but does not check the output matches the expected
output. If the test is failing with an exception error, it should be
very easy to locate where exactly the script is failing.
For an example of a print-and-compare test, try:
</P><PRE CLASS="verbatim">python test_SeqIO.py
</PRE><P>The <CODE>unittest</CODE>-based tests instead show you exactly which sub-section(s) of
the test are failing. For example,
</P><PRE CLASS="verbatim">python test_Cluster.py
</PRE><!--TOC section Writing tests-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc248">17.2</A>&#XA0;&#XA0;Writing tests</H2><!--SEC END --><P>Let&#X2019;s say you want to write some tests for a module called <CODE>Biospam</CODE>.
This can be a module you wrote, or an existing module that doesn&#X2019;t have
any tests yet. In the examples below, we assume that
<CODE>Biospam</CODE> is a module that does simple math.</P><P>Each Biopython test can have three important files and directories involved with it:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<CODE>test_Biospam.py</CODE> &#X2013; The actual test code for your module.
</LI><LI CLASS="li-enumerate"><CODE>Biospam</CODE> [optional]&#X2013; A directory where any necessary input files
will be located. Any output files that will be generated should also
be written here (and preferably cleaned up after the tests are
done) to prevent clogging up the main Tests directory.
</LI><LI CLASS="li-enumerate"><CODE>output/Biospam</CODE> &#X2013; [for print-and-compare tests only] This
file contains the expected output from running <CODE>test_Biospam.py</CODE>.
This file is not needed for <CODE>unittest</CODE>-style tests, since there
the validation is done in the test script <CODE>test_Biospam.py</CODE> itself.
</LI></OL><P>It&#X2019;s up to you to decide whether you want to write a print-and-compare test script or a <CODE>unittest</CODE>-style test script. The important thing is that you cannot mix these two styles in a single test script. Particularly, don&#X2019;t use <CODE>unittest</CODE> features in a print-and-compare test.</P><P>Any script with a <CODE>test_</CODE> prefix in the <CODE>Tests</CODE> directory will be found and run by <CODE>run_tests.py</CODE>. Below, we show an example test script <CODE>test_Biospam.py</CODE> both for a print-and-compare test and for a <CODE>unittest</CODE>-based test. If you put this script in the Biopython <CODE>Tests</CODE> directory, then <CODE>run_tests.py</CODE> will find it and execute the tests contained in it:
</P><PRE CLASS="verbatim">$ python run_tests.py     
test_Ace ... ok
test_AlignIO ... ok
test_BioSQL ... ok
test_BioSQL_SeqIO ... ok
test_Biospam ... ok
test_CAPS ... ok
test_Clustalw ... ok
</PRE><P>&#X2026;</P><PRE CLASS="verbatim">----------------------------------------------------------------------
Ran 107 tests in 86.127 seconds
</PRE><!--TOC subsection Writing a print-and-compare test-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc249">17.2.1</A>&#XA0;&#XA0;Writing a print-and-compare test</H3><!--SEC END --><P>A print-and-compare style test should be much simpler for beginners
or novices to write - essentially it is just an example script using
your new module.</P><P>Here is what you should do to make a print-and-compare test for the
<CODE>Biospam</CODE> module.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Write a script called <CODE>test_Biospam.py</CODE><UL CLASS="itemize"><LI CLASS="li-itemize">This script should live in the Tests directory</LI><LI CLASS="li-itemize">The script should test all of the important functionality
of the module (the more you test the better your test is, of course!).</LI><LI CLASS="li-itemize">Try to avoid anything which might be platform specific,
such as printing floating point numbers without using an explicit
formatting string to avoid having too many decimal places
(different platforms can give very slightly different values).</LI></UL></LI><LI CLASS="li-enumerate">If the script requires files to do the testing, these should go in
the directory Tests/Biospam (if you just need something generic, like
a FASTA sequence file, or a GenBank record, try and use an existing
sample input file instead).</LI><LI CLASS="li-enumerate">Write out the test output and verify the output to be correct.<P>There are two ways to do this:</P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
The long way:<UL CLASS="itemize"><LI CLASS="li-itemize">Run the script and write its output to a file. On UNIX (including
Linux and Mac OS X) machines, you would do something like:
<CODE>python test_Biospam.py &gt; test_Biospam</CODE> which would write the
output to the file <CODE>test_Biospam</CODE>.</LI><LI CLASS="li-itemize">Manually look at the file <CODE>test_Biospam</CODE> to make sure the output is correct. When you are sure it is all right and there are no bugs, you need to quickly edit the <CODE>test_Biospam</CODE> file so that the first line is: &#X2018;<CODE>test_Biospam</CODE>&#X2019; (no quotes).</LI><LI CLASS="li-itemize">copy the <CODE>test_Biospam</CODE> file to the directory Tests/output</LI></UL></LI><LI CLASS="li-enumerate">The quick way:<UL CLASS="itemize"><LI CLASS="li-itemize">
Run <CODE>python run_tests.py -g test_Biospam.py</CODE>. The
regression testing framework is nifty enough that it&#X2019;ll put
the output in the right place in just the way it likes it. </LI><LI CLASS="li-itemize">Go to the output (which should be in <CODE>Tests/output/test_Biospam</CODE>) and double check the output to make sure it is all correct.</LI></UL></LI></OL></LI><LI CLASS="li-enumerate">Now change to the Tests directory and run the regression tests
with <CODE>python run_tests.py</CODE>. This will run all of the tests, and
you should see your test run (and pass!).</LI><LI CLASS="li-enumerate">That&#X2019;s it! Now you&#X2019;ve got a nice test for your module ready to check in,
or submit to Biopython. Congratulations!
</LI></OL><P>As an example, the <CODE>test_Biospam.py</CODE> test script to test the
<CODE>addition</CODE> and <CODE>multiplication</CODE> functions in the <CODE>Biospam</CODE>
module could look as follows:</P><PRE CLASS="verbatim">from Bio import Biospam

print "2 + 3 =", Biospam.addition(2, 3)
print "9 - 1 =", Biospam.addition(9, -1)
print "2 * 3 =", Biospam.multiplication(2, 3)
print "9 * (- 1) =", Biospam.multiplication(9, -1)
</PRE><P>We generate the corresponding output with <CODE>python run_tests.py -g test_Biospam.py</CODE>, and check the output file <CODE>output/test_Biospam</CODE>:</P><PRE CLASS="verbatim">test_Biospam
2 + 3 = 5
9 - 1 = 8
2 * 3 = 6
9 * (- 1) = -9
</PRE><P>Often, the difficulty with larger print-and-compare tests is to keep track which line in the output corresponds to which command in the test script. For this purpose, it is important to print out some markers to help you match lines in the input script with the generated output.</P><!--TOC subsection Writing a unittest-based test-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc250">17.2.2</A>&#XA0;&#XA0;Writing a unittest-based test</H3><!--SEC END --><P>We want all the modules in Biopython to have unit tests, and a simple
print-and-compare test is better than no test at all. However, although
there is a steeper learning curve, using the <CODE>unittest</CODE> framework
gives a more structured result, and if there is a test failure this can
clearly pinpoint which part of the test is going wrong. The sub-tests can
also be run individually which is helpful for testing or debugging.</P><P>The <CODE>unittest</CODE>-framework has been included with Python since version
2.1, and is documented in the Python Library Reference (which I know you
are keeping under your pillow, as recommended). There is also
<A HREF="http://docs.python.org/library/unittest.html">online documentaion
for unittest</A>.
If you are familiar with the <CODE>unittest</CODE> system (or something similar
like the nose test framework), you shouldn&#X2019;t have any trouble. You may
find looking at the existing example within Biopython helpful too.</P><P>Here&#X2019;s a minimal <CODE>unittest</CODE>-style test script for <CODE>Biospam</CODE>,
which you can copy and paste to get started:</P><PRE CLASS="verbatim">import unittest
from Bio import Biospam

class BiospamTestAddition(unittest.TestCase):

    def test_addition1(self):
        result = Biospam.addition(2, 3)
        self.assertEqual(result, 5)

    def test_addition2(self):
        result = Biospam.addition(9, -1)
        self.assertEqual(result, 8)

class BiospamTestDivision(unittest.TestCase):

    def test_division1(self):
        result = Biospam.division(3.0, 2.0)
        self.assertAlmostEqual(result, 1.5)

    def test_division2(self):
        result = Biospam.division(10.0, -2.0)
        self.assertAlmostEqual(result, -5.0)


if __name__ == "__main__":
    runner = unittest.TextTestRunner(verbosity = 2)
    unittest.main(testRunner=runner)
</PRE><P>In the division tests, we use <CODE>assertAlmostEqual</CODE> instead of <CODE>assertEqual</CODE> to avoid tests failing due to roundoff errors; see the <CODE>unittest</CODE> chapter in the Python documentation for details and for other functionality available in <CODE>unittest</CODE> (<A HREF="http://docs.python.org/library/unittest.html">online reference</A>).</P><P>These are the key points of <CODE>unittest</CODE>-based tests:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Test cases are stored in classes that derive from
<CODE>unittest.TestCase</CODE> and cover one basic aspect of your code</LI><LI CLASS="li-itemize">You can use methods <CODE>setUp</CODE> and <CODE>tearDown</CODE> for any repeated
code which should be run before and after each test method. For example,
the <CODE>setUp</CODE> method might be used to create an instance of the object
you are testing, or open a file handle. The <CODE>tearDown</CODE> should do any
&#X201C;tidying up&#X201D;, for example closing the file handle.</LI><LI CLASS="li-itemize">The tests are prefixed with <CODE>test_</CODE> and each test should cover
one specific part of what you are trying to test. You can have as
many tests as you want in a class.</LI><LI CLASS="li-itemize">At the end of the test script, you can use
<PRE CLASS="verbatim">if __name__ == "__main__":
    runner = unittest.TextTestRunner(verbosity = 2)
    unittest.main(testRunner=runner)
</PRE>to execute the tests when the script is run by itself (rather than
imported from <CODE>run_tests.py</CODE>).
If you run this script, then you&#X2019;ll see something like the following:<PRE CLASS="verbatim">$ python test_BiospamMyModule.py
test_addition1 (__main__.TestAddition) ... ok
test_addition2 (__main__.TestAddition) ... ok
test_division1 (__main__.TestDivision) ... ok
test_division2 (__main__.TestDivision) ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.059s

OK
</PRE></LI><LI CLASS="li-itemize">To indicate more clearly what each test is doing, you can add
docstrings to each test. These are shown when running the tests,
which can be useful information if a test is failing.<PRE CLASS="verbatim">import unittest
from Bio import Biospam

class BiospamTestAddition(unittest.TestCase):

    def test_addition1(self):
        """An addition test"""
        result = Biospam.addition(2, 3)
        self.assertEqual(result, 5)

    def test_addition2(self):
        """A second addition test"""
        result = Biospam.addition(9, -1)
        self.assertEqual(result, 8)

class BiospamTestDivision(unittest.TestCase):

    def test_division1(self):
        """Now let's check division"""
        result = Biospam.division(3.0, 2.0)
        self.assertAlmostEqual(result, 1.5)

    def test_division2(self):
        """A second division test"""
        result = Biospam.division(10.0, -2.0)
        self.assertAlmostEqual(result, -5.0)


if __name__ == "__main__":
    runner = unittest.TextTestRunner(verbosity = 2)
    unittest.main(testRunner=runner)
</PRE><P>Running the script will now show you:</P><PRE CLASS="verbatim">$ python test_BiospamMyModule.py
An addition test ... ok
A second addition test ... ok
Now let's check division ... ok
A second division test ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
</PRE></LI></UL><P>If your module contains docstring tests (see section <A HREF="#section:doctest">17.3</A>),
you may want to include those in the tests to be run. You can do so as
follows by modifying the code under <CODE>if __name__ == "__main__":</CODE>
to look like this:</P><PRE CLASS="verbatim">if __name__ == "__main__":
    unittest_suite = unittest.TestLoader().loadTestsFromName("test_Biospam")
    doctest_suite = doctest.DocTestSuite(Biospam)
    suite = unittest.TestSuite((unittest_suite, doctest_suite))
    runner = unittest.TextTestRunner(sys.stdout, verbosity = 2)
    runner.run(suite)
</PRE><P>This is only relevant if you want to run the docstring tests when you
execute <CODE>python test_Biospam.py</CODE>; with
<CODE>python run_tests.py</CODE>, the docstring tests are run automatically
(assuming they are included in the list of docstring tests in
<CODE>run_tests.py</CODE>, see the section below).</P><!--TOC section Writing doctests-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc251">17.3</A>&#XA0;&#XA0;Writing doctests</H2><!--SEC END --><P>
<A NAME="section:doctest"></A></P><P>Python modules, classes and functions support built in documentation using
docstrings. The <A HREF="http://docs.python.org/library/doctest.html">doctest
framework</A> (included with Python) allows the developer to embed working
examples in the docstrings, and have these examples automatically tested.</P><P>Currently only a small part of Biopython includes doctests. The
<CODE>run_tests.py</CODE> script takes care of running the doctests.
For this purpose, at the top of the <CODE>run_tests.py</CODE> script is a
manually compiled list of modules to test, which
allows us to skip modules with optional external dependencies which may
not be installed (e.g. the Reportlab and NumPy libraries). So, if you&#X2019;ve
added some doctests to the docstrings in a Biopython module, in order to
have them included in the Biopython test suite, you must update
<CODE>run_tests.py</CODE> to include your module. Currently, the relevant part
of <CODE>run_tests.py</CODE> looks as follows:</P><PRE CLASS="verbatim"># This is the list of modules containing docstring tests.
# If you develop docstring tests for other modules, please add
# those modules here.
DOCTEST_MODULES = ["Bio.Seq",
                   "Bio.SeqRecord",
                   "Bio.SeqIO",
                   "Bio.Align.Generic",
                   "Bio.AlignIO",
                   "Bio.KEGG.Compound",
                   "Bio.KEGG.Enzyme",
                   "Bio.Wise",
                   "Bio.Wise.psw",
                  ]
#Silently ignore any doctests for modules requiring numpy!
try:
    import numpy
    DOCTEST_MODULES.extend(["Bio.Statistics.lowess"])
except ImportError:
    pass
</PRE><P>Note that we regard doctests primarily as documentation, so you should
stick to typical usage. Generally complicated examples dealing with error
conditions and the like would be best left to a dedicated unit test.</P><P>Note that if you want to write doctests involving file parsing, defining
the file location complicates matters. Ideally use relative paths assuming
the code will be run from the <CODE>Tests</CODE> directory, see the
<CODE>Bio.SeqIO</CODE> doctests for an example of this.</P><P>To run the docstring tests only, use
</P><PRE CLASS="verbatim">$ python run_tests.py doctest
</PRE><!--TOC chapter Advanced-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc252">Chapter&#XA0;18</A>&#XA0;&#XA0;Advanced</H1><!--SEC END --><P>
<A NAME="chapter:advanced"></A></P><!--TOC section Parser Design-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc253">18.1</A>&#XA0;&#XA0;Parser Design</H2><!--SEC END --><P>Many of the older Biopython parsers were built around an event-oriented
design that includes Scanner and Consumer objects.</P><P>Scanners take input from a data source and analyze it line by line,
sending off an event whenever it recognizes some information in the
data. For example, if the data includes information about an organism
name, the scanner may generate an <CODE>organism_name</CODE> event whenever it
encounters a line containing the name.</P><P>Consumers are objects that receive the events generated by Scanners.
Following the previous example, the consumer receives the
<CODE>organism_name</CODE> event, and the processes it in whatever manner
necessary in the current application.</P><P>This is a very flexible framework, which is advantageous if you want to
be able to parse a file format into more than one representation. For
example, the <CODE>Bio.GenBank</CODE> module uses this to construct either
<CODE>SeqRecord</CODE> objects or file-format-specific record objects.</P><P>More recently, many of the parsers added for <CODE>Bio.SeqIO</CODE> and
<CODE>Bio.AlignIO</CODE> take a much simpler approach, but only generate a
single object representation (<CODE>SeqRecord</CODE> and
<CODE>MultipleSeqAlignment</CODE> objects respectively). In some cases the
<CODE>Bio.SeqIO</CODE> parsers actually wrap
another Biopython parser - for example, the <CODE>Bio.SwissProt</CODE> parser
produces SwissProt format specific record objects, which get converted
into <CODE>SeqRecord</CODE> objects.</P><!--TOC section Substitution Matrices-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc254">18.2</A>&#XA0;&#XA0;Substitution Matrices</H2><!--SEC END --><!--TOC subsection SubsMat-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc255">18.2.1</A>&#XA0;&#XA0;SubsMat</H3><!--SEC END --><P>This module provides a class and a few routines for generating substitution matrices, similar to BLOSUM or PAM matrices, but based on user-provided data. Additionally, you may select a matrix from MatrixInfo.py, a collection of established substitution matrices. The <CODE>SeqMat</CODE> class derives from a dictionary:
</P><PRE CLASS="verbatim">class SeqMat(dict)
</PRE><P>The dictionary is of the form <CODE>{(i1,j1):n1, (i1,j2):n2,...,(ik,jk):nk}</CODE> where i, j are alphabet letters, and n is a value.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Attributes
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<CODE>self.alphabet</CODE>: a class as defined in Bio.Alphabet</LI><LI CLASS="li-enumerate"><CODE>self.ab_list</CODE>: a list of the alphabet&#X2019;s letters, sorted. Needed mainly for internal purposes
</LI></OL></LI><LI CLASS="li-enumerate">Methods<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate"><PRE CLASS="verbatim">__init__(self,data=None,alphabet=None, mat_name='', build_later=0):
</PRE><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate"><CODE>data</CODE>: can be either a dictionary, or another SeqMat instance.
</LI><LI CLASS="li-enumerate"><CODE>alphabet</CODE>: a Bio.Alphabet instance. If not provided, construct an alphabet from data.</LI><LI CLASS="li-enumerate"><CODE>mat_name</CODE>: matrix name, such as "BLOSUM62" or "PAM250"</LI><LI CLASS="li-enumerate"><CODE>build_later</CODE>: default false. If true, user may supply only alphabet and empty dictionary, if intending to build the matrix later. this skips the sanity check of alphabet size vs. matrix size.</LI></OL></LI><LI CLASS="li-enumerate"><PRE CLASS="verbatim">entropy(self,obs_freq_mat)
</PRE><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
<CODE>obs_freq_mat</CODE>: an observed frequency matrix. Returns the matrix&#X2019;s entropy, based on the frequency in <CODE>obs_freq_mat</CODE>. The matrix instance should be LO or SUBS.
</LI></OL></LI><LI CLASS="li-enumerate"><PRE CLASS="verbatim">sum(self)
</PRE>Calculates the sum of values for each letter in the matrix&#X2019;s alphabet, and returns it as a dictionary of the form <CODE>{i1: s1, i2: s2,...,in:sn}</CODE>, where:
<UL CLASS="itemize"><LI CLASS="li-itemize">
i: an alphabet letter;
</LI><LI CLASS="li-itemize">s: sum of all values in a half-matrix for that letter;
</LI><LI CLASS="li-itemize">n: number of letters in alphabet.
</LI></UL></LI><LI CLASS="li-enumerate"><PRE CLASS="verbatim">print_mat(self,f,format="%4d",bottomformat="%4s",alphabet=None)
</PRE><P>prints the matrix to file handle f. <CODE>format</CODE> is the format field for the matrix values; <CODE>bottomformat</CODE> is the format field for the bottom row, containing matrix letters. Example output for a 3-letter alphabet matrix:</P><PRE CLASS="verbatim">A 23
B 12 34
C 7  22  27
  A   B   C
</PRE><P>The <CODE>alphabet</CODE> optional argument is a string of all characters in the alphabet. If supplied, the order of letters along the axes is taken from the string, rather than by alphabetical order.</P></LI></OL></LI><LI CLASS="li-enumerate">Usage<P>The following section is layed out in the order by which most people wish to generate a log-odds matrix. Of course, interim matrices can be generated and
investigated. Most people just want a log-odds matrix, that&#X2019;s all.</P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">Generating an Accepted Replacement Matrix<P>Initially, you should generate an accepted replacement matrix (ARM) from your data. The values in ARM are the counted number of replacements according to your data. The data could be a set of pairs or multiple alignments. So for instance if Alanine was replaced by Cysteine 10 times, and Cysteine by Alanine 12 times, the corresponding ARM entries would be:</P><PRE CLASS="verbatim">('A','C'): 10, ('C','A'): 12
</PRE><P>as order doesn&#X2019;t matter, user can already provide only one entry:</P><PRE CLASS="verbatim">('A','C'): 22
</PRE><P>A SeqMat instance may be initialized with either a full (first method of counting: 10, 12) or half (the latter method, 22) matrices. A full protein
alphabet matrix would be of the size 20x20 = 400. A half matrix of that alphabet would be 20x20/2 + 20/2 = 210. That is because same-letter entries don&#X2019;t
change. (The matrix diagonal). Given an alphabet size of N:</P><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
Full matrix size:N*N</LI><LI CLASS="li-enumerate">Half matrix size: N(N+1)/2
</LI></OL><P>The SeqMat constructor automatically generates a half-matrix, if a full matrix is passed. If a half matrix is passed, letters in the key should be provided in alphabetical order: (&#X2019;A&#X2019;,&#X2019;C&#X2019;) and not (&#X2019;C&#X2019;,A&#X2019;).</P><P>At this point, if all you wish to do is generate a log-odds matrix, please go to the section titled Example of Use. The following text describes the nitty-gritty of internal functions, to be used by people who wish to investigate their nucleotide/amino-acid frequency data more thoroughly.</P></LI><LI CLASS="li-enumerate">Generating the observed frequency matrix (OFM)<P>Use:
</P><PRE CLASS="verbatim">OFM = SubsMat._build_obs_freq_mat(ARM)
</PRE><P>The OFM is generated from the ARM, only instead of replacement counts, it contains replacement frequencies.</P></LI><LI CLASS="li-enumerate">Generating an expected frequency matrix (EFM)<P>Use:</P><PRE CLASS="verbatim">EFM = SubsMat._build_exp_freq_mat(OFM,exp_freq_table)
</PRE><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
<CODE>exp_freq_table</CODE>: should be a FreqTable instance. See section&#XA0;<A HREF="#sec:freq_table">18.2.2</A> for detailed information on FreqTable. Briefly, the expected frequency table has the frequencies of appearance for each member of the alphabet. It is
implemented as a dictionary with the alphabet letters as keys, and each letter&#X2019;s frequency as a value. Values sum to 1.
</LI></OL><P>The expected frequency table can (and generally should) be generated from the observed frequency matrix. So in most cases you will generate <CODE>exp_freq_table</CODE> using:</P><PRE CLASS="verbatim">&gt;&gt;&gt; exp_freq_table = SubsMat._exp_freq_table_from_obs_freq(OFM)
&gt;&gt;&gt; EFM = SubsMat._build_exp_freq_mat(OFM,exp_freq_table)
</PRE><P>But you can supply your own <CODE>exp_freq_table</CODE>, if you wish</P></LI><LI CLASS="li-enumerate">Generating a substitution frequency matrix (SFM)<P>Use:</P><PRE CLASS="verbatim">SFM = SubsMat._build_subs_mat(OFM,EFM)
</PRE><P>Accepts an OFM, EFM. Provides the division product of the corresponding values.</P></LI><LI CLASS="li-enumerate">Generating a log-odds matrix (LOM)<P>Use:
</P><PRE CLASS="verbatim">LOM=SubsMat._build_log_odds_mat(SFM[,logbase=10,factor=10.0,round_digit=1])
</PRE><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
Accepts an SFM.</LI><LI CLASS="li-enumerate"><CODE>logbase</CODE>: base of the logarithm used to generate the log-odds values.</LI><LI CLASS="li-enumerate"><CODE>factor</CODE>: factor used to multiply the log-odds values. Each entry is generated by log(LOM[key])*factor And rounded to the <CODE>round_digit</CODE> place after the decimal point, if required.</LI></OL></LI></OL></LI><LI CLASS="li-enumerate">Example of use<P>As most people would want to generate a log-odds matrix, with minimum hassle, SubsMat provides one function which does it all:</P><PRE CLASS="verbatim">make_log_odds_matrix(acc_rep_mat,exp_freq_table=None,logbase=10,
                      factor=10.0,round_digit=0):
</PRE><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<CODE>acc_rep_mat</CODE>: user provided accepted replacements matrix
</LI><LI CLASS="li-enumerate"><CODE>exp_freq_table</CODE>: expected frequencies table. Used if provided, if not, generated from the <CODE>acc_rep_mat</CODE>.
</LI><LI CLASS="li-enumerate"><CODE>logbase</CODE>: base of logarithm for the log-odds matrix. Default base 10.
</LI><LI CLASS="li-enumerate"><CODE>round_digit</CODE>: number after decimal digit to which result should be rounded. Default zero.
</LI></OL></LI></OL><!--TOC subsection FreqTable-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc256">18.2.2</A>&#XA0;&#XA0;FreqTable</H3><!--SEC END --><P>
<A NAME="sec:freq_table"></A></P><PRE CLASS="verbatim">FreqTable.FreqTable(UserDict.UserDict)
</PRE><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Attributes:<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<CODE>alphabet</CODE>: A Bio.Alphabet instance.
</LI><LI CLASS="li-enumerate"><CODE>data</CODE>: frequency dictionary
</LI><LI CLASS="li-enumerate"><CODE>count</CODE>: count dictionary (in case counts are provided).
</LI></OL></LI><LI CLASS="li-enumerate">Functions:
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<CODE>read_count(f)</CODE>: read a count file from stream f. Then convert to frequencies
</LI><LI CLASS="li-enumerate"><CODE>read_freq(f)</CODE>: read a frequency data file from stream f. Of course, we then don&#X2019;t have the counts, but it is usually the letter frquencies which are interesting.
</LI></OL></LI><LI CLASS="li-enumerate">Example of use:
The expected count of the residues in the database is sitting in a file, whitespace delimited, in the following format (example given for a 3-letter alphabet):<PRE CLASS="verbatim">A   35
B   65
C   100
</PRE><P>And will be read using the <CODE>FreqTable.read_count(file_handle)</CODE> function.</P><P>An equivalent frequency file:</P><PRE CLASS="verbatim">A  0.175
B  0.325
C  0.5
</PRE><P>Conversely, the residue frequencies or counts can be passed as a dictionary.
Example of a count dictionary (3-letter alphabet):</P><PRE CLASS="verbatim">{'A': 35, 'B': 65, 'C': 100}
</PRE><P>Which means that an expected data count would give a 0.5 frequency
for &#X2019;C&#X2019;, a 0.325 probability of &#X2019;B&#X2019; and a 0.175 probability of &#X2019;A&#X2019;
out of 200 total, sum of A, B and C)</P><P>A frequency dictionary for the same data would be:</P><PRE CLASS="verbatim">{'A': 0.175, 'B': 0.325, 'C': 0.5}
</PRE><P>Summing up to 1.</P><P>When passing a dictionary as an argument, you should indicate whether it is a count or a frequency dictionary. Therefore the FreqTable class constructor requires two arguments: the dictionary itself, and FreqTable.COUNT or FreqTable.FREQ indicating counts or frequencies, respectively.</P><P>Read expected counts. readCount will already generate the frequencies
Any one of the following may be done to geerate the frequency table (ftab):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from SubsMat import *
&gt;&gt;&gt; ftab = FreqTable.FreqTable(my_frequency_dictionary,FreqTable.FREQ)
&gt;&gt;&gt; ftab = FreqTable.FreqTable(my_count_dictionary,FreqTable.COUNT)
&gt;&gt;&gt; ftab = FreqTable.read_count(open('myCountFile'))
&gt;&gt;&gt; ftab = FreqTable.read_frequency(open('myFrequencyFile'))
</PRE></LI></OL><!--TOC chapter Where to go from here &#X2013; contributing to Biopython-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc257">Chapter&#XA0;19</A>&#XA0;&#XA0;Where to go from here &#X2013; contributing to Biopython</H1><!--SEC END --><!--TOC section Bug Reports + Feature Requests-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc258">19.1</A>&#XA0;&#XA0;Bug Reports + Feature Requests</H2><!--SEC END --><P>Getting feedback on the Biopython modules is very important to us. Open-source projects like this benefit greatly from feedback, bug-reports (and patches!) from a wide variety of contributors.</P><P>The main forums for discussing feature requests and potential bugs are the
<A HREF="http://biopython.org/wiki/Mailing_lists">Biopython mailing lists</A>:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="mailto:biopython@biopython.org">biopython@biopython.org</A> &#X2013; An unmoderated list for discussion of anything to do with Biopython.</LI><LI CLASS="li-itemize"><A HREF="mailto:biopython-dev@biopython.org">biopython-dev@biopython.org</A> &#X2013; A more development oriented list that is mainly used by developers (but anyone is free to contribute!).
</LI></UL><P>Additionally, if you think you&#X2019;ve found a bug, you can submit it to our
bug-tracking page at <A HREF="http://redmine.open-bio.org/projects/biopython"><TT>http://redmine.open-bio.org/projects/biopython</TT></A>.
This way, it won&#X2019;t get buried in anyone&#X2019;s Inbox and forgotten about.</P><!--TOC section Mailing lists and helping newcomers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc259">19.2</A>&#XA0;&#XA0;Mailing lists and helping newcomers</H2><!--SEC END --><P>We encourage all our uses to sign up to the main Biopython mailing list.
Once you&#X2019;ve got the hang of an area of Biopython, we&#X2019;d encourage you to
help answer questions from beginners. After all, you were a beginner once.</P><!--TOC section Contributing Documentation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc260">19.3</A>&#XA0;&#XA0;Contributing Documentation</H2><!--SEC END --><P>We&#X2019;re happy to take feedback or contributions - either via a bug-report or on the Mailing List.
While reading this tutorial, perhaps you noticed some topics you were interested in which were missing, or not clearly explained. There is also Biopython&#X2019;s built in documentation (the docstrings, these are also 
<A HREF="http://biopython.org/DIST/docs/api">online</A>), where again, you may be able to help fill in any blanks.</P><!--TOC section Contributing cookbook examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc261">19.4</A>&#XA0;&#XA0;Contributing cookbook examples</H2><!--SEC END --><P>
As explained in Chapter&#XA0;<A HREF="#chapter:cookbook">16</A>, Biopython now has a wiki
collection of user contributed &#X201C;cookbook&#X201D; examples,
<A HREF="http://biopython.org/wiki/Category:Cookbook"><TT>http://biopython.org/wiki/Category:Cookbook</TT></A> &#X2013; maybe you can add
to this?</P><!--TOC section Maintaining a distribution for a platform-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc262">19.5</A>&#XA0;&#XA0;Maintaining a distribution for a platform</H2><!--SEC END --><P>
<A NAME="sec:maintain_dist"></A></P><P>We currently provide source code archives (suitable for any OS, if you have the right build tools installed), and Windows Installers which are just click and run. This covers all the major operating systems.</P><P>Most major Linux distributions have volunteers who take these source code releases, and compile them into packages for Linux users to easily install (taking care of dependencies etc). This is really great and we are of course very grateful. If you would like to contribute to this work, please find out more about how your Linux distribution handles this.</P><P>Below are some tips for certain platforms to maybe get people started with helping out:</P><DL CLASS="description"><DT CLASS="dt-description"><B>Windows</B></DT><DD CLASS="dd-description"> &#X2013; Windows products typically have a nice graphical installer that installs all of the essential components in the right place. We use Distutils to create a installer of this type fairly easily.<P>You must first make sure you have a C compiler on your Windows computer, and that you can compile and install things (this is the hard bit - see the Biopython installation instructions for info on how to do this).</P><P>Once you are setup with a C compiler, making the installer just requires doing:</P><PRE CLASS="verbatim">python setup.py bdist_wininst
</PRE><P>Now you&#X2019;ve got a Windows installer. Congrats! At the moment we have no trouble shipping installers built on 32 bit windows. If anyone would like to look into supporting 64 bit Windows that would be great.</P></DD><DT CLASS="dt-description"><B>RPMs</B></DT><DD CLASS="dd-description"> &#X2013; RPMs are pretty popular package systems on some Linux platforms. There is lots of documentation on RPMs available at <A HREF="http://www.rpm.org"><TT>http://www.rpm.org</TT></A> to help you get started with them. To create an RPM for your platform is really easy. You just need to be able to build the package from source (having a C compiler that works is thus essential) &#X2013; see the Biopython installation instructions for more info on this.<P>To make the RPM, you just need to do:</P><PRE CLASS="verbatim">python setup.py bdist_rpm
</PRE><P>This will create an RPM for your specific platform and a source RPM in the directory <CODE>dist</CODE>. This RPM should be good and ready to go, so this is all you need to do! Nice and easy.</P></DD><DT CLASS="dt-description"><B>Macintosh</B></DT><DD CLASS="dd-description"> &#X2013; Since Apple moved to Mac OS X, things have become much easier on the Mac. We generally
treat it as just another Unix variant, and installing Biopython from source is just as easy as on Linux.
The easiest way to get all the GCC compilers etc installed is to install Apple&#X2019;s X-Code.
We might be able to provide click and run installers for Mac OS X, but to date there hasn&#X2019;t been any demand.</DD></DL><P>Once you&#X2019;ve got a package, please test it on your system to make sure it installs everything in a good way and seems to work properly. Once you feel good about it, send it off to one of the Biopython developers (write to our main mailing list at biopython@biopython.org if you&#X2019;re not sure who to send it to) and you&#X2019;ve done it. Thanks!</P><!--TOC section Contributing Unit Tests-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc263">19.6</A>&#XA0;&#XA0;Contributing Unit Tests</H2><!--SEC END --><P>Even if you don&#X2019;t have any new functionality to add to Biopython, but you want to write some code, please
consider extending our unit test coverage. We&#X2019;ve devoted all of Chapter&#XA0;<A HREF="#sec:regr_test">17</A> to this topic.</P><!--TOC section Contributing Code-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc264">19.7</A>&#XA0;&#XA0;Contributing Code</H2><!--SEC END --><P>There are no barriers to joining Biopython code development other
than an interest in creating biology-related code in Python. The
best place to express an interest is on the Biopython mailing lists
&#X2013; just let us know you are interested in coding and what kind of
stuff you want to work on. Normally, we try to have some discussion
on modules before coding them, since that helps generate good ideas
&#X2013; then just feel free to jump right in and start coding!</P><P>The main Biopython release tries to be fairly uniform and interworkable,
to make it easier for users. You can read about some of (fairly
informal) coding style guidelines we try to use in Biopython in the
contributing documentation at
<A HREF="http://biopython.org/wiki/Contributing"><TT>http://biopython.org/wiki/Contributing</TT></A>. We also try to add code to the distribution along with tests (see Chapter&#XA0;<A HREF="#sec:regr_test">17</A> for more info on the regression testing framework) and documentation, so that everything can stay as workable and well documented as possible (including docstrings). This is, of course, the most ideal situation, under many situations you&#X2019;ll be able to find other people on the list who will be willing to help add documentation or more tests for your code once you make it available. So, to end this paragraph like the last, feel free to start working!</P><P>Please note that to make a code contribution you must have the legal right to contribute it and license it under the Biopython license. If you wrote it all yourself, and it is not based on any other code, this shouldn&#X2019;t be a problem. However, there are issues if you want to contribute a derivative work - for example something based on GPL or LPGL licenced code would not be compatible with our license. If you have any queries on this, please discuss the issue on the biopython-dev mailing list.</P><P>Another point of concern for any additions to Biopython regards any build time or run time dependencies. Generally speaking, writing code to interact with a standalone tool (like BLAST, EMBOSS or ClustalW) doesn&#X2019;t present a big problem. However, any dependency on another library - even a Python library (especially one needed in order to compile and install Biopython like NumPy) would need further discussion.</P><P>Additionally, if you have code that you don&#X2019;t think fits in the
distribution, but that you want to make available, we maintain Script
Central (<A HREF="http://biopython.org/wiki/Scriptcentral"><TT>http://biopython.org/wiki/Scriptcentral</TT></A>)
which has pointers to freely available code in Python for bioinformatics.</P><P>Hopefully this documentation has got you excited enough about
Biopython to try it out (and most importantly, contribute!). Thanks
for reading all the way through!</P><!--TOC chapter Appendix: Useful stuff about Python-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc265">Chapter&#XA0;20</A>&#XA0;&#XA0;Appendix: Useful stuff about Python</H1><!--SEC END --><P>
<A NAME="sec:appendix"></A></P><P>If you haven&#X2019;t spent a lot of time programming in Python, many
questions and problems that come up in using Biopython are often
related to Python itself. This section tries to present some ideas and
code that come up often (at least for us!) while using the Biopython
libraries. If you have any suggestions for useful pointers that could
go here, please contribute!</P><!--TOC section What the heck is a handle?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc266">20.1</A>&#XA0;&#XA0;What the heck is a handle?</H2><!--SEC END --><P>
<A NAME="sec:appendix-handles"></A></P><P>Handles are mentioned quite frequently throughout this documentation,
and are also fairly confusing (at least to me!). Basically, you can
think of a handle as being a &#X201C;wrapper&#X201D; around text information.</P><P>Handles provide (at least) two benefits over plain text information:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
They provide a standard way to deal with information stored in
different ways. The text information can be in a file, or in a
string stored in memory, or the output from a command line program,
or at some remote website, but the handle provides a common way of
dealing with information in all of these formats.</LI><LI CLASS="li-enumerate">They allow text information to be read incrementally, instead
of all at once. This is really important when you are dealing with
huge text files which would use up all of your memory if you had to
load them all.
</LI></OL><P>Handles can deal with text information that is being read (e.&#XA0;g.&#XA0;reading
from a file) or written (e.&#XA0;g.&#XA0;writing information to a file). In the
case of a &#X201C;read&#X201D; handle, commonly used functions are <CODE>read()</CODE>,
which reads the entire text information from the handle, and
<CODE>readline()</CODE>, which reads information one line at a time. For
&#X201C;write&#X201D; handles, the function <CODE>write()</CODE> is regularly used.</P><P>The most common usage for handles is reading information from a file,
which is done using the built-in Python function <CODE>open</CODE>. Here, we open a
handle to the file <A HREF="examples/m_cold.fasta">m_cold.fasta</A>
(also available online
<A HREF="http://biopython.org/DIST/docs/tutorial/examples/m_cold.fasta">here</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = open("m_cold.fasta", "r")
&gt;&gt;&gt; handle.readline()
"&gt;gi|8332116|gb|BE037100.1|BE037100 MP14H09 MP Mesembryanthemum ...\n"
</PRE><P>Handles are regularly used in Biopython for passing information to parsers.
For example, since Biopython 1.54 the main functions in <CODE>Bio.SeqIO</CODE>
and <CODE>Bio.AlignIO</CODE> have allowed you to use a filename instead of a
handle:</P><PRE CLASS="verbatim">from Bio import SeqIO
for record in SeqIO.parse("m_cold.fasta", "fasta"):
    print record.id, len(record)
</PRE><P>On older versions of Biopython you had to use a handle, e.g.</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("m_cold.fasta", "r")
for record in SeqIO.parse(handle, "fasta"):
    print record.id, len(record)
handle.close()
</PRE><P>This pattern is still useful - for example suppose you have a gzip
compressed FASTA file you want to parse:</P><PRE CLASS="verbatim">import gzip
from Bio import SeqIO
handle = gzip.open("m_cold.fasta.gz")
for record in SeqIO.parse(handle, "fasta"):
    print record.id, len(record)
handle.close()
</PRE><P>See Section&#XA0;<A HREF="#sec:SeqIO_compressed">5.2</A> for more examples like this,
including reading bzip2 compressed files.</P><!--TOC subsection Creating a handle from a string-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc267">20.1.1</A>&#XA0;&#XA0;Creating a handle from a string</H3><!--SEC END --><P>One useful thing is to be able to turn information contained in a
string into a handle. The following example shows how to do this using
<CODE>cStringIO</CODE> from the Python standard library:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_info = 'A string\n with multiple lines.'
&gt;&gt;&gt; print my_info
A string
 with multiple lines.
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; my_info_handle = StringIO(my_info)
&gt;&gt;&gt; first_line = my_info_handle.readline()
&gt;&gt;&gt; print first_line
A string
&lt;BLANKLINE&gt;
&gt;&gt;&gt; second_line = my_info_handle.readline()
&gt;&gt;&gt; print second_line
 with multiple lines.
</PRE><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
