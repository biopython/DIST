<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Biopython Tutorial and Cookbook
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: c:\cygwin\usr\local\hevea-1.10\hevea -exec xxdate.exe -fix Tutorial.tex -->
<!--CUT DEF chapter 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Biopython Tutorial and Cookbook</H1><H3 CLASS="titlerest">Jeff Chang, Brad Chapman, Iddo Friedberg, Thomas Hamelryck, Michiel de Hoon, Peter Cock</H3><H3 CLASS="titlerest">Last Update&#X2013;15 June 2008</H3></TD></TR>
</TABLE><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter&#XA0;1&#XA0;&#XA0;Introduction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1&#XA0;&#XA0;What is Biopython?</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">1.1.1&#XA0;&#XA0;What can I find in the Biopython package</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.2&#XA0;&#XA0;Installing Biopython</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">1.3&#XA0;&#XA0;FAQ</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">Chapter&#XA0;2&#XA0;&#XA0;Quick Start &#X2013; What can you do with Biopython?</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc7">2.1&#XA0;&#XA0;General overview of what Biopython provides</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">2.2&#XA0;&#XA0;Working with sequences</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">2.3&#XA0;&#XA0;A usage example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">2.4&#XA0;&#XA0;Parsing sequence file formats</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc11">2.4.1&#XA0;&#XA0;Simple FASTA parsing example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">2.4.2&#XA0;&#XA0;Simple GenBank parsing example</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">2.4.3&#XA0;&#XA0;I love parsing &#X2013; please don&#X2019;t stop talking about it!</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">2.5&#XA0;&#XA0;Connecting with biological databases</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">2.6&#XA0;&#XA0;What to do next</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">Chapter&#XA0;3&#XA0;&#XA0;Sequence objects</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc17">3.1&#XA0;&#XA0;Sequences and Alphabets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">3.2&#XA0;&#XA0;Sequences act like strings</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">3.3&#XA0;&#XA0;Slicing a sequence</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">3.4&#XA0;&#XA0;Turning Seq objects into strings</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">3.5&#XA0;&#XA0;Nucleotide sequences and (reverse) complements</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">3.6&#XA0;&#XA0;Concatenating or adding sequences</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">3.7&#XA0;&#XA0;MutableSeq objects</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">3.8&#XA0;&#XA0;Transcribing and Translation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">3.9&#XA0;&#XA0;Working with directly strings</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">Chapter&#XA0;4&#XA0;&#XA0;Sequence Input/Output</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc27">4.1&#XA0;&#XA0;Parsing or Reading Sequences</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc28">4.1.1&#XA0;&#XA0;Reading Sequence Files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">4.1.2&#XA0;&#XA0;Iterating over the records in a sequence file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">4.1.3&#XA0;&#XA0;Getting a list of the records in a sequence file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">4.1.4&#XA0;&#XA0;Extracting data</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">4.2&#XA0;&#XA0;Parsing sequences from the net</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc33">4.2.1&#XA0;&#XA0;Parsing GenBank records from the net</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">4.2.2&#XA0;&#XA0;Parsing SwissProt sequences from the net</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">4.3&#XA0;&#XA0;Sequence files as Dictionaries</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc36">4.3.1&#XA0;&#XA0;Specifying the dictionary keys</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">4.3.2&#XA0;&#XA0;Indexing a dictionary using the SEGUID checksum</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">4.4&#XA0;&#XA0;Writing Sequence Files</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc39">4.4.1&#XA0;&#XA0;Converting between sequence file formats</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">4.4.2&#XA0;&#XA0;Converting a file of sequences to their reverse complements</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">Chapter&#XA0;5&#XA0;&#XA0;Sequence Alignment Input/Output</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc42">5.1&#XA0;&#XA0;Parsing or Reading Sequence Alignments</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc43">5.1.1&#XA0;&#XA0;Single Alignments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">5.1.2&#XA0;&#XA0;Multiple Alignments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">5.1.3&#XA0;&#XA0;Ambiguous Alignments</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">5.2&#XA0;&#XA0;Writing Alignments</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc47">5.2.1&#XA0;&#XA0;Converting between sequence alignment file formats</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">Chapter&#XA0;6&#XA0;&#XA0;BLAST</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc49">6.1&#XA0;&#XA0;Running BLAST locally</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">6.2&#XA0;&#XA0;Running BLAST over the Internet</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">6.3&#XA0;&#XA0;Saving BLAST output</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">6.4&#XA0;&#XA0;Parsing BLAST output</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">6.5&#XA0;&#XA0;The BLAST record class</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">6.6&#XA0;&#XA0;Deprecated BLAST parsers</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc55">6.6.1&#XA0;&#XA0;Parsing plain-text BLAST output</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">6.6.2&#XA0;&#XA0;Parsing a file full of BLAST runs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">6.6.3&#XA0;&#XA0;Finding a bad record somewhere in a huge file</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">6.7&#XA0;&#XA0;Dealing with PSIBlast</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">Chapter&#XA0;7&#XA0;&#XA0;Accessing NCBI&#X2019;s Entrez databases</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc60">7.1&#XA0;&#XA0;Entrez Guidelines</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">7.2&#XA0;&#XA0;EInfo: Obtaining information about the Entrez databases</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">7.3&#XA0;&#XA0;ESearch: Searching the Entrez databases</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">7.4&#XA0;&#XA0;EPost</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">7.5&#XA0;&#XA0;ESummary: Retrieving summaries from primary IDs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">7.6&#XA0;&#XA0;EFetch: Downloading full records from Entrez</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">7.7&#XA0;&#XA0;ELink</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">7.8&#XA0;&#XA0;EGQuery: Obtaining counts for search terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">7.9&#XA0;&#XA0;ESpell: Obtaining spelling suggestions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">7.10&#XA0;&#XA0;Examples</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc70">7.10.1&#XA0;&#XA0;Searching and downloading Entrez Nucleotide records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">7.10.2&#XA0;&#XA0;Finding the lineage of an organism</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">7.10.3&#XA0;&#XA0;Using the history and WebEnv</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">Chapter&#XA0;8&#XA0;&#XA0;Swiss-Prot, Prosite, Prodoc, and ExPASy</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc74">8.1&#XA0;&#XA0;Bio.SwissProt: Parsing Swiss-Prot files</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc75">8.1.1&#XA0;&#XA0;Parsing Swiss-Prot records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">8.1.2&#XA0;&#XA0;Parsing the Swiss-Prot keyword and category list</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc77">8.2&#XA0;&#XA0;Bio.Prosite: Parsing Prosite records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">8.3&#XA0;&#XA0;Bio.Prosite.Prodoc: Parsing Prodoc records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">8.4&#XA0;&#XA0;Bio.ExPASy: Accessing the ExPASy server</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc80">8.4.1&#XA0;&#XA0;Retrieving a Swiss-Prot record</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">8.4.2&#XA0;&#XA0;Searching Swiss-Prot</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">8.4.3&#XA0;&#XA0;Retrieving Prosite and Prodoc records</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">Chapter&#XA0;9&#XA0;&#XA0;Cookbook &#X2013; Cool things to do with it</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc84">9.1&#XA0;&#XA0;PubMed</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc85">9.1.1&#XA0;&#XA0;Sending a query to PubMed</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">9.1.2&#XA0;&#XA0;Retrieving a PubMed record</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">9.2&#XA0;&#XA0;GenBank</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc88">9.2.1&#XA0;&#XA0;Retrieving GenBank entries from NCBI</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">9.2.2&#XA0;&#XA0;Parsing GenBank records</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">9.2.3&#XA0;&#XA0;Iterating over GenBank records</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">9.3&#XA0;&#XA0;Dealing with alignments</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc92">9.3.1&#XA0;&#XA0;Clustalw</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc93">9.3.2&#XA0;&#XA0;Calculating summary information</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">9.3.3&#XA0;&#XA0;Calculating a quick consensus sequence</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">9.3.4&#XA0;&#XA0;Position Specific Score Matrices</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">9.3.5&#XA0;&#XA0;Information Content</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">9.3.6&#XA0;&#XA0;Translating between Alignment formats</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">9.4&#XA0;&#XA0;Substitution Matrices</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc99">9.4.1&#XA0;&#XA0;Using common substitution matrices</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">9.4.2&#XA0;&#XA0;Creating your own substitution matrix from an alignment</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">9.5&#XA0;&#XA0;BioSQL &#X2013; storing sequences in a relational database</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">9.6&#XA0;&#XA0;BioCorba</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">9.7&#XA0;&#XA0;Going 3D: The PDB module</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc104">9.7.1&#XA0;&#XA0;Structure representation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">9.7.2&#XA0;&#XA0;Disorder</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">9.7.3&#XA0;&#XA0;Hetero residues</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">9.7.4&#XA0;&#XA0;Some random usage examples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">9.7.5&#XA0;&#XA0;Common problems in PDB files</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc109">9.7.6&#XA0;&#XA0;Other features</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">9.8&#XA0;&#XA0;Bio.PopGen: Population genetics</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc111">9.8.1&#XA0;&#XA0;GenePop</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">9.8.2&#XA0;&#XA0;Coalescent simulation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">9.8.3&#XA0;&#XA0;Other applications</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">9.8.4&#XA0;&#XA0;Future Developments</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">9.9&#XA0;&#XA0;InterPro</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc116">Chapter&#XA0;10&#XA0;&#XA0;Advanced</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc117">10.1&#XA0;&#XA0;The SeqRecord and SeqFeature classes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc118">10.1.1&#XA0;&#XA0;Sequence ids and Descriptions &#X2013; dealing with SeqRecords</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">10.1.2&#XA0;&#XA0;Features and Annotations &#X2013; SeqFeatures</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc120">10.2&#XA0;&#XA0;Regression Testing Framework</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc121">10.2.1&#XA0;&#XA0;Writing a Regression Test</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">10.3&#XA0;&#XA0;Parser Design</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">10.4&#XA0;&#XA0;Substitution Matrices</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc124">10.4.1&#XA0;&#XA0;SubsMat</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">10.4.2&#XA0;&#XA0;FreqTable</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">Chapter&#XA0;11&#XA0;&#XA0;Where to go from here &#X2013; contributing to Biopython</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc127">11.1&#XA0;&#XA0;Maintaining a distribution for a platform</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc128">11.2&#XA0;&#XA0;Bug Reports + Feature Requests</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">11.3&#XA0;&#XA0;Contributing Code</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">Chapter&#XA0;12&#XA0;&#XA0;Appendix: Useful stuff about Python</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc131">12.1&#XA0;&#XA0;What the heck is a handle?</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc132">12.1.1&#XA0;&#XA0;Creating a handle from a string</A>
</LI></UL>
</LI></UL>
</LI></UL><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter&#XA0;1</A>&#XA0;&#XA0;Introduction</H1><!--SEC END --><P>
<A NAME="chapter:introduction"></A></P><!--TOC section What is Biopython?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>&#XA0;&#XA0;What is Biopython?</H2><!--SEC END --><P>The Biopython Project is an international association of developers of freely available Python (<A HREF="http://www.python.org"><TT>http://www.python.org</TT></A>) tools for computational molecular biology. The web site <A HREF="http://www.biopython.org"><TT>http://www.biopython.org</TT></A> provides an online resource for modules, scripts, and web links for developers of Python-based software for life science research.</P><P>Basically, we just like to program in python and want to make it as easy as possible to use python for bioinformatics by creating high-quality, reusable modules and scripts.</P><!--TOC subsection What can I find in the Biopython package-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">1.1.1</A>&#XA0;&#XA0;What can I find in the Biopython package</H3><!--SEC END --><P>The main Biopython releases have lots of functionality, including:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The ability to parse bioinformatics files into python utilizable data structures, including support for the following formats:<UL CLASS="itemize"><LI CLASS="li-itemize">
Blast output &#X2013; both from standalone and WWW Blast
</LI><LI CLASS="li-itemize">Clustalw
</LI><LI CLASS="li-itemize">FASTA
</LI><LI CLASS="li-itemize">GenBank
</LI><LI CLASS="li-itemize">PubMed and Medline
</LI><LI CLASS="li-itemize">Expasy files, like Enzyme, Prodoc and Prosite
</LI><LI CLASS="li-itemize">SCOP, including &#X2018;dom&#X2019; and &#X2018;lin&#X2019; files
</LI><LI CLASS="li-itemize">UniGene
</LI><LI CLASS="li-itemize">SwissProt
</LI></UL></LI><LI CLASS="li-itemize">Files in the supported formats can be iterated over record by record or indexed and accessed via a Dictionary interface.</LI><LI CLASS="li-itemize">Code to deal with popular on-line bioinformatics destinations such as:<UL CLASS="itemize"><LI CLASS="li-itemize">
NCBI &#X2013; Blast, Entrez and PubMed services
</LI><LI CLASS="li-itemize">Expasy &#X2013; Prodoc and Prosite entries
</LI></UL></LI><LI CLASS="li-itemize">Interfaces to common bioinformatics programs such as:<UL CLASS="itemize"><LI CLASS="li-itemize">
Standalone Blast from NCBI
</LI><LI CLASS="li-itemize">Clustalw alignment program.
</LI></UL></LI><LI CLASS="li-itemize">A standard sequence class that deals with sequences, ids on sequences, and sequence features.</LI><LI CLASS="li-itemize">Tools for performing common operations on sequences, such as translation, transcription and weight calculations.</LI><LI CLASS="li-itemize">Code to perform classification of data using k Nearest Neighbors, Naive Bayes or Support Vector Machines.</LI><LI CLASS="li-itemize">Code for dealing with alignments, including a standard way to create and deal with substitution matrices.</LI><LI CLASS="li-itemize">Code making it easy to split up parallelizable tasks into separate processes.</LI><LI CLASS="li-itemize">GUI-based programs to do basic sequence manipulations, translations, BLASTing, etc.</LI><LI CLASS="li-itemize">Extensive documentation and help with using the modules, including this file, on-line wiki documentation, the web site, and the mailing list.</LI><LI CLASS="li-itemize">Integration with other languages, including the Bioperl and Biojava projects, using the BioCorba interface standard (available with the biopython-corba module).</LI></UL><P>We hope this gives you plenty of reasons to download and start using Biopython!</P><!--TOC section Installing Biopython-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">1.2</A>&#XA0;&#XA0;Installing Biopython</H2><!--SEC END --><P>All of the installation information for Biopython was separated from
this document to make it easier to keep updated. The instructions cover
installation of python, Biopython dependencies and Biopython itself.
It is available in pdf
(<A HREF="http://biopython.org/DIST/docs/install/Installation.pdf"><TT>http://biopython.org/DIST/docs/install/Installation.pdf</TT></A>)
and html formats
(<A HREF="http://biopython.org/DIST/docs/install/Installation.html"><TT>http://biopython.org/DIST/docs/install/Installation.html</TT></A>).</P><!--TOC section FAQ-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">1.3</A>&#XA0;&#XA0;FAQ</H2><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.SeqIO</CODE> <EM>work? It imports fine but there is no parse function etc.</EM><BR>
 You need Biopython 1.43 or later. Older versions did contain some related code under the <CODE>Bio.SeqIO</CODE> name which has since been deprecated - and this is why the import &#X201C;works&#X201D;.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.SeqIO.read()</CODE> <EM>work? The module imports fine but there is no read function!</EM><BR>
 You need Biopython 1.45 or later.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.Blast</CODE> <EM>work with the latest plain text NCBI blast output?</EM><BR>
 The NCBI keep tweaking the plain text output from the BLAST tools, and keeping our parser up to date is an ongoing struggle. We recommend you use the XML output instead, which is designed to be read by a computer program.</LI><LI CLASS="li-enumerate"><EM>Why isn&#X2019;t</EM> <CODE>Bio.AlignIO)</CODE> <EM>present? The module import fails!</EM><BR>
 You need Biopython 1.46 or later.</LI><LI CLASS="li-enumerate"><EM>Why doesn&#X2019;t</EM> <CODE>Bio.Entrez.read()</CODE> <EM>work? The module imports fine but there is no read function!</EM><BR>
 You need Biopython 1.46 or later.</LI><LI CLASS="li-enumerate"><EM>I looked in a directory for code, but I couldn&#X2019;t seem to find the code that does something. Where&#X2019;s it hidden?</EM><BR>
 One thing to know is that we put code in <CODE>__init__.py</CODE> files. If you are not used to looking for code in this file this can be confusing. The reason we do this is to make the imports easier for users. For instance, instead of having to do a &#X201C;repetitive&#X201D; import like <CODE>from Bio.GenBank import GenBank</CODE>, you can just import like <CODE>from Bio import GenBank</CODE>.</LI></OL><!--TOC chapter Quick Start &#X2013; What can you do with Biopython?-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc6">Chapter&#XA0;2</A>&#XA0;&#XA0;Quick Start &#X2013; What can you do with Biopython?</H1><!--SEC END --><P>
<A NAME="chapter:quick-start"></A></P><P>This section is designed to get you started quickly with Biopython, and to give a general overview of what is available and how to use it. All of the examples in this section assume that you have some general working knowledge of python, and that you have successfully installed Biopython on your system. If you think you need to brush up on your python, the main python web site provides quite a bit of free documentation to get started with (<A HREF="http://www.python.org/doc/"><TT>http://www.python.org/doc/</TT></A>).</P><P>Since much biological work on the computer involves connecting with databases on the internet, some of the examples will also require a working internet connection in order to run.</P><P>Now that that is all out of the way, let&#X2019;s get into what we can do with Biopython.</P><!--TOC section General overview of what Biopython provides-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">2.1</A>&#XA0;&#XA0;General overview of what Biopython provides</H2><!--SEC END --><P>As mentioned in the introduction, Biopython is a set of libraries to provide the ability to deal with &#X201D;things&#X201D; of interest to biologists working on the computer. In general this means that you will need to have at least some programming experience (in python, of course!) or at least an interest in learning to program. Biopython&#X2019;s job is to make your job easier as a programmer by supplying reusable libraries so that you can focus on answering your specific question of interest, instead of focusing on the internals of parsing a particular file format (of course, if you want to help by writing a parser that doesn&#X2019;t exist and contributing it to Biopython, please go ahead!). So Biopython&#X2019;s job is to make you happy!</P><P>One thing to note about Biopython is that it often provides multiple ways of &#X201C;doing the same thing.&#X201D; To me, this can be frustrating since I often way to just know the one right way to do something. However, this is also a real benefit because it gives you lots of flexibility and control over the libraries. The tutorial helps to show you the common or easy ways to do things so that you can just make things work. To learn more about the alternative possibilities, look into the Cookbook section (which tells you some cools tricks and tips) and the Advanced section (which provides you with as much detail as you&#X2019;d ever want to know!).</P><!--TOC section Working with sequences-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">2.2</A>&#XA0;&#XA0;Working with sequences</H2><!--SEC END --><P>
<A NAME="sec:sequences"></A></P><P>Disputedly (of course!), the central object in bioinformatics is the sequence. Thus, we&#X2019;ll start with a quick introduction to the Biopython mechanisms for dealing with sequences, the <CODE>Seq</CODE> object, which we&#X2019;ll discuss in more detail in Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A>.</P><P>Most of the time when we think about sequences we have in my mind a string of letters like <CODE>'AGTACACTGGT'</CODE>. You can create such <CODE>Seq</CODE> object with this sequence as follows - the &#X201C;&gt;&gt;&gt;&#X201D; represents the python prompt followed by what you would type in:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; my_seq = Seq("AGTACACTGGT")
&gt;&gt;&gt; my_seq.alphabet
Alphabet()
&gt;&gt;&gt; print my_seq.tostring()
AGTACACTGGT
</PRE><P>What we have here is a sequence object with a <EM>generic</EM> alphabet - reflecting the fact we have <EM>not</EM> specified if this is a DNA or protein sequence (okay, a protein with a lot of Alanines, Glycines, Cysteines and Threonines!). We&#X2019;ll talk more about alphabets in Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A>.</P><P>In addition to having an alphabet, the <CODE>Seq</CODE> object differs from the python string in the methods it supports. You can&#X2019;t do this with a plain string:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq
Seq('AGTACACTGGT', Alphabet())
&gt;&gt;&gt; my_seq.complement()
Seq('TCATGTGACCA', Alphabet())
&gt;&gt;&gt; my_seq.reverse_complement()
Seq('ACCAGTGTACT', Alphabet())
</PRE><P>The next most important class is the <CODE>SeqRecord</CODE> or Sequence Record. This holds a sequence (as a <CODE>Seq</CODE> object) with additional annotation including an identifier, name and description. The <CODE>Bio.SeqIO</CODE> module for reading and writing sequence file formats works with <CODE>SeqRecord</CODE> objects, which will be introduced below and cover in more detail by Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>.</P><P>This covers the basic features and uses of the Biopython sequence class.
Now that you&#X2019;ve got some idea of what it is like to interact with the Biopython libraries, it&#X2019;s time to delve into the fun, fun world of dealing with biological file formats!</P><!--TOC section A usage example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">2.3</A>&#XA0;&#XA0;A usage example</H2><!--SEC END --><P>
<A NAME="sec:orchids"></A></P><P>Before we jump right into parsers and everything else to do with Biopython, let&#X2019;s set up an example to motivate everything we do and make life more interesting. After all, if there wasn&#X2019;t any biology in this tutorial, why would you want you read it?</P><P>Since I love plants, I think we&#X2019;re just going to have to have a plant based example (sorry to all the fans of other organisms out there!). Having just completed a recent trip to our local greenhouse, we&#X2019;ve suddenly developed an incredible obsession with Lady Slipper Orchids (if you wonder why, have a look at some <A HREF="http://www.flickr.com/search/?q=lady+slipper+orchid&s=int&z=t">Lady Slipper Orchids photos on Flickr</A>, or try a <A HREF="http://images.google.com/images?q=lady%20slipper%20orchid">Google Image Search</A>).</P><P>Of course, orchids are not only beautiful to look at, they are also extremely interesting for people studying evolution and systematics. So let&#X2019;s suppose we&#X2019;re thinking about writing a funding proposal to do a molecular study of Lady Slipper evolution, and would like to see what kind of research has already been done and how we can add to that.</P><P>After a little bit of reading up we discover that the Lady Slipper Orchids are in the Orchidaceae family and the Cypripedioideae sub-family and are made up of 5 genera: <EM>Cypripedium</EM>, <EM>Paphiopedilum</EM>, <EM>Phragmipedium</EM>, <EM>Selenipedium</EM> and <EM>Mexipedium</EM>.</P><P>That gives us enough to get started delving for more information. So, let&#X2019;s look at how the Biopython tools can help us. We&#X2019;ll start with sequence parsing in Section&#XA0;<A HREF="#sec:sequence-parsing">2.4</A>, but the orchids will be back later on as well - for example we&#X2019;ll extra data from Swiss-Prot from certain orchid proteins in Chapter&#XA0;<A HREF="#chapter:swiss_prot">8</A>, search PubMed for papers about orchids in Section&#XA0;<A HREF="#sec:pub_med">9.1</A>, extract sequence data from GenBank in Section&#XA0;<A HREF="#genbank-retrieval">9.2.1</A>, and work with ClustalW multiple sequence alignments of orchid proteins in Section&#XA0;<A HREF="#sec:align_clustal">9.3.1</A>.</P><!--TOC section Parsing sequence file formats-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">2.4</A>&#XA0;&#XA0;Parsing sequence file formats</H2><!--SEC END --><P>
<A NAME="sec:sequence-parsing"></A></P><P>A large part of much bioinformatics work involves dealing with the many types of file formats designed to hold biological data. These files are loaded with interesting biological data, and a special challenge is parsing these files into a format so that you can manipulate them with some kind of programming language. However the task of parsing these files can be frustrated by the fact that the formats can change quite regularly, and that formats may contain small subtleties which can break even the most well designed parsers.</P><P>We are now going to briefly introduce the <CODE>Bio.SeqIO</CODE> module &#X2013; you can find out more in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>. We&#X2019;ll start with an online search for our friends, the lady slipper orchids. To keep this introduction simple, we&#X2019;re just using the NCBI website by hand. Let&#X2019;s just take a look through the nucleotide databases at NCBI, using an Entrez online search (<A HREF="http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide"><TT>http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide</TT></A>) for everything mentioning the text Cypripedioideae (this is the subfamily of lady slipper orchids). </P><P>When this tutorial was originally written, this search gave us only 94 hits, which we saved as a FASTA formatted text file (<A HREF="examples/ls_orchid.fasta">ls_orchid.fasta</A>; also available online <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta">here</A>) and as a GenBank formatted text file (<A HREF="examples/ls_orchid.gbk">ls_orchid.gbk</A>; also available online <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">here</A>).</P><P>If you run the search today, you&#X2019;ll get hundreds of results! When following the tutorial, if you want to see the same list of genes, just download the two files above or copy them from <CODE>docs/examples/</CODE> in the Biopython source code. In Section&#XA0;<A HREF="#sec:connecting-with-biological-databases">2.5</A> we will look at how to do a search like this from within python.</P><!--TOC subsection Simple FASTA parsing example-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">2.4.1</A>&#XA0;&#XA0;Simple FASTA parsing example</H3><!--SEC END --><P>
<A NAME="sec:fasta-parsing"></A></P><P>If you open the lady slipper orchids FASTA file in your favourite text editor, you&#X2019;ll see that the file starts like this:</P><PRE CLASS="verbatim">&gt;gi|2765658|emb|Z78533.1|CIZ78533 C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA
CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAACGATCGAGTG
AATCCGGAGGACCGGTGTACTCAGCTCACCGGGGGCATTGCTCCCGTGGTGACCCTGATTTGTTGTTGGG
...
</PRE><P>It contains 94 records, each has a line starting with &#X201C;&gt;&#X201D; (greater-than symbol) followed by the sequence on one or more lines. Now try this in python:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.fasta")
for seq_record in SeqIO.parse(handle, "fasta") :
    print seq_record.id
    print repr(seq_record.seq)
    print len(seq_record)
handle.close()
</PRE><P>You should get something like this on your screen:</P><PRE CLASS="verbatim">gi|2765658|emb|Z78533.1|CIZ78533
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', SingleLetterAlphabet())
740
...
gi|2765564|emb|Z78439.1|PBZ78439
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACT...GCC', SingleLetterAlphabet())
592
</PRE><P>Notice that the FASTA format does not specify the alphabet, so <CODE>Bio.SeqIO</CODE> has defaulted to the rather generic <CODE>SingleLetterAlphabet()</CODE> rather than something DNA specific.</P><!--TOC subsection Simple GenBank parsing example-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">2.4.2</A>&#XA0;&#XA0;Simple GenBank parsing example</H3><!--SEC END --><P>Now let&#X2019;s load the GenBank file instead - notice that the code to do this is almost identical to the snippet used above for a FASTA file - the only difference is we changed the filename and the format string:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.gbk")
for seq_record in SeqIO.parse(handle, "genbank") :
    print seq_record.id
    print repr(seq_record.seq)
    print len(seq_record)
handle.close()
</PRE><P>This should give:</P><PRE CLASS="verbatim">Z78533.1
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', IUPACAmbiguousDNA())
740
...
Z78439.1
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACT...GCC', IUPACAmbiguousDNA())
592
</PRE><P>This time <CODE>Bio.SeqIO</CODE> has been able to choose a sensible alphabet, IUPAC Ambiguous DNA. You&#X2019;ll also notice that a shorter string has been used as the <CODE>seq_record.id</CODE> in this case.</P><!--TOC subsection I love parsing &#X2013; please don&#X2019;t stop talking about it!-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">2.4.3</A>&#XA0;&#XA0;I love parsing &#X2013; please don&#X2019;t stop talking about it!</H3><!--SEC END --><P>Biopython has a lot of parsers, and each has its own little special niches based on the sequence format it is parsing and all of that. While the most popular file formats have parsers integrated into <CODE>Bio.SeqIO</CODE>, for some of the rarer and unloved file formats there is either no parser at all, or an old parser which has not been linked in yet.</P><P>Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A> covers <CODE>Bio.SeqIO</CODE> in more detail. Please also check the wiki page (<A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A>) for the latest information, or ask on the mailing list. The wiki page should includes an up to date list of supported file types, and more examples including writing sequences to a file, and converting between file formats.</P><P>If you are interested in sequence alignments, then look at the <CODE>Bio.AlignIO</CODE> module introduced in Chapter&#XA0;<A HREF="#chapter:Bio.AlignIO">5</A>. Again, there is a wiki page for this too (<A HREF="http://biopython.org/wiki/AlignIO"><TT>http://biopython.org/wiki/AlignIO</TT></A>).</P><P>The next place to look for information about specific parsers and how to do cool things with them is in the Cookbook, Section&#XA0;<A HREF="#chapter:cookbook">9</A> of this Tutorial. If you don&#X2019;t find the information you are looking for, please consider helping out your poor overworked documentors and submitting a cookbook entry about it! (once you figure out how to do it, that is!)</P><!--TOC section Connecting with biological databases-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc14">2.5</A>&#XA0;&#XA0;Connecting with biological databases</H2><!--SEC END --><P>
<A NAME="sec:connecting-with-biological-databases"></A></P><P>One of the very common things that you need to do in bioinformatics is extract information from biological databases. It can be quite tedious to access these databases manually, especially if you have a lot of repetitive work to do. Biopython attempts to save you time and energy by making some on-line databases available from python scripts. Currently, Biopython has code to extract information from the following databases:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="http://www.expasy.org/">ExPASy</A> &#X2013; See Chapter&#XA0;<A HREF="#chapter:swiss_prot">8</A> in the Cookbook for more information.
</LI><LI CLASS="li-itemize"><A HREF="http://www.ncbi.nlm.nih.gov/Entrez/">Entrez from NCBI</A> &#X2013; See Section&#XA0;<A HREF="#sec:entrez_examples">7.10</A>.
</LI><LI CLASS="li-itemize"><A HREF="http://www.ncbi.nlm.nih.gov/PubMed/">PubMed from NCBI</A> &#X2013; See Section&#XA0;<A HREF="#sec:pub_med">9.1</A> in the Cookbook for example code detailing how to use this.
</LI><LI CLASS="li-itemize"><A HREF="http://scop.mrc-lmb.cam.ac.uk/scop/">SCOP</A>
</LI></UL><P>The code is these modules basically makes it easy to write python code that interact with the CGI scripts on these pages, so that you can get results in an easy to deal with format. In some cases, the results can be tightly integrated with the Biopython parsers to make it even easier to extract information.</P><!--TOC section What to do next-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc15">2.6</A>&#XA0;&#XA0;What to do next</H2><!--SEC END --><P>Now that you&#X2019;ve made it this far, you hopefully have a good understanding of the basics of Biopython and are ready to start using it for doing useful work. The best thing to do now is to start snooping around in the source code and looking at the automatically generated documentation.</P><P>Once you get a picture of what you want to do, and what libraries in Biopython will do it, you should take a peak at the Cookbook, which may have example code to do something similar to what you want to do.</P><P>If you know what you want to do, but can&#X2019;t figure out how to do it, please feel free to post questions to the main biopython list (biopython@biopython.org). This will not only help us answer your question, it will also allow us to improve the documentation so it can help the next person do what you want to do.</P><P>Enjoy the code!</P><!--TOC chapter Sequence objects-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc16">Chapter&#XA0;3</A>&#XA0;&#XA0;Sequence objects</H1><!--SEC END --><P>
<A NAME="chapter:Bio.Seq"></A></P><P>Biological sequences are arguably the central object in Bioinformatics, and in this chapter we&#X2019;ll introduce the Biopython mechanism for dealing with sequences, the <CODE>Seq</CODE> object.
In Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A> on Sequence Input/Output (and Section&#XA0;<A HREF="#sec:advanced-seq">10.1</A>), we&#X2019;ll see that the <CODE>Seq</CODE> object is also used in the <CODE>SeqRecord</CODE> object, which combines the sequence information with any annotation.</P><P>Sequences are essentially strings of letters like <CODE>AGTACACTGGT</CODE>, which seems very natural since this is the most common way that sequences are seen in biological file formats.</P><P>There are two important differences between the <CODE>Seq</CODE> object and standard python strings. First of all the Seq object has a slightly different set of methods to a plain python string (for example, a <CODE>reverse_complement()</CODE> method used for nucleotide sequences).
Secondly, the <CODE>Seq</CODE> object has an important attribute, <CODE>alphabet</CODE>, which is an object describing what the individual characters making up the sequence string &#X201C;mean&#X201D;, and how they should be interpreted. For example, is <CODE>AGTACACTGGT</CODE> a DNA sequence, or just a protein sequence that happens to be rich in Alanines, Glycines, Cysteines
and Threonines?</P><!--TOC section Sequences and Alphabets-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc17">3.1</A>&#XA0;&#XA0;Sequences and Alphabets</H2><!--SEC END --><P>The alphabet object is perhaps the important thing that makes the <CODE>Seq</CODE> object more than just a string. The currently available alphabets for Biopython are defined in the <CODE>Bio.Alphabet</CODE> module. We&#X2019;ll use the IUPAC alphabets (<A HREF="http://www.chem.qmw.ac.uk/iupac/"><TT>http://www.chem.qmw.ac.uk/iupac/</TT></A>) here to deal with some of our favorite objects: DNA, RNA and Proteins.</P><P><CODE>Bio.Alphabet.IUPAC</CODE> provides basic definitions for proteins, DNA and RNA, but additionally provides the ability to extend and customize the basic definitions. For instance, for proteins, there is a basic IUPACProtein class, but there is an additional ExtendedIUPACProtein class providing for the additional elements &#X201C;Asx&#X201D; (asparagine or aspartic acid), &#X201C;Sec&#X201D; (selenocysteine), and &#X201C;Glx&#X201D; (glutamine or glutamic acid). For DNA you&#X2019;ve got choices of IUPACUnambiguousDNA, which provides for just the basic letters, IUPACAmbiguousDNA (which provides for ambiguity letters for every possible situation) and ExtendedIUPACDNA, which allows letters for modified bases. Similarly, RNA can be represented by IUPACAmbiguousRNA or IUPACUnambiguousRNA.</P><P>The advantages of having an alphabet class are two fold. First, this gives an idea of the type of information the Seq object contains. Secondly, this provides a means of constraining the information, as a means of type checking.</P><P>Now that we know what we are dealing with, let&#X2019;s look at how to utilize this class to do interesting work.
You can create an ambiguous sequence with the default generic alphabet like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; my_seq = Seq("AGTACACTGGT")
&gt;&gt;&gt; my_seq
Seq('AGTACACTGGT', Alphabet())
&gt;&gt;&gt; my_seq.alphabet
Alphabet()
</PRE><P>However, where possible you should specify the alphabet explicitly when creating your sequence objects - in this case an unambiguous DNA alphabet object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq('AGTACACTGGT', IUPAC.unambiguous_dna)
&gt;&gt;&gt; my_seq
Seq('AGTACACTGGT', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq.alphabet
IUPACUnambiguousDNA()
</PRE><!--TOC section Sequences act like strings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc18">3.2</A>&#XA0;&#XA0;Sequences act like strings</H2><!--SEC END --><P>In many ways, we can deal with Seq objects as if they were normal python strings, for example getting the length, or iterating over the elements:</P><PRE CLASS="verbatim">from Bio.Seq import Seq
from Bio.Alphabet import IUPAC
my_seq = Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPAC.unambiguous_dna)
for index, letter in enumerate(my_seq) :
    print index, letter
print len(letter)
</PRE><P>You can access elements of the sequence in the same way as for strings (but remember, python counts from zero!):</P><PRE CLASS="verbatim">&gt;&gt;&gt; print my_seq[0] #first element
&gt;&gt;&gt; print my_seq[2] #third element
&gt;&gt;&gt; print my_seq[-1] #list element
</PRE><P>The <CODE>Seq</CODE> object has a <CODE>.count()</CODE> method, just like a string:</P><PRE CLASS="verbatim">&gt;&gt;&gt; len(my_seq)
32
&gt;&gt;&gt; my_seq.count("G")
10
&gt;&gt;&gt; float(my_seq.count("G") + my_seq.count("C")) / len(my_seq)
0.46875
</PRE><P>While you could use the above snippet of code to calculate a GC%, note that Biopython does have some GC functions already built in, see the <CODE>Bio.SeqUtils</CODE> module.</P><!--TOC section Slicing a sequence-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">3.3</A>&#XA0;&#XA0;Slicing a sequence</H2><!--SEC END --><P>A more complicated example, let&#X2019;s get a slice of the sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPAC.unambiguous_dna)
&gt;&gt;&gt; my_seq[4:12]
Seq('GATGGGCC', IUPACUnambiguousDNA())
</PRE><P>Two things are interesting to note. First, this follows the normal conventions for python strings. So the first element of the sequence is 0 (which is normal for computer science, but not so normal for biology). When you do a slice the first item is included (i.&#XA0;e.&#XA0;4 in this case) and the last is excluded (12 in this case), which is the way things work in python, but of course not necessarily the way everyone in the world would expect. The main goal is to stay consistent with what python does.</P><P>The second thing to notice is that the slice is performed on the sequence data string, but the new object produced is another <CODE>Seq</CODE> object which retains the alphabet information from the original <CODE>Seq</CODE> object.</P><P>Also like a python string, you can do slices with a start, stop and <EM>stride</EM> (the step size, which defaults to one). For example, we can get the first, second and third codon positions of this DNA sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq[0::3]
Seq('GCTGTAGTAAG', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq[1::3]
Seq('AGGCATGCATC', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq[2::3]
Seq('TAGCTAAGAC', IUPACUnambiguousDNA())
</PRE><P>Another stride trick you might have seen with a python string is the use of a -1 stride to reverse the string. You can do this with a <CODE>Seq</CODE> object too:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq[::-1]
Seq('CGCTAAAAGCTAGGATATATCCGGGTAGCTAG', IUPACUnambiguousDNA())
</PRE><!--TOC section Turning Seq objects into strings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc20">3.4</A>&#XA0;&#XA0;Turning Seq objects into strings</H2><!--SEC END --><P>If you are really do just need a plain string, for example to print out, write to a file, or insert into a database, then this is very easy to get:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq.tostring()
'GATCGATGGGCCTATATAGGATCGAAAATCGC'
</PRE><!--TOC section Nucleotide sequences and (reverse) complements-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">3.5</A>&#XA0;&#XA0;Nucleotide sequences and (reverse) complements</H2><!--SEC END --><P>
<A NAME="sec:seq-reverse-complement"></A></P><P>For nucleotide sequences, you can easily obtain the complement or reverse complement of a Seq object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq.complement()
Seq('CTAGCTACCCGGATATATCCTAGCTTTTAGCG', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq.reverse_complement()
Seq('GCGATTTTCGATCCTATATAGGCCCATCGATC', IUPACUnambiguousDNA())
</PRE><P>In all of these operations, the alphabet property is maintained. This is very useful in case you accidentally end up trying to do something weird like take the (reverse)complement of a protein seuqence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; protein_seq = Seq("EVRNAK", IUPAC.protein)
&gt;&gt;&gt; dna_seq = Seq("ACGT", IUPAC.unambiguous_dna)
&gt;&gt;&gt; protein_seq.complement()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "/usr/local/lib/python2.4/site-packages/Bio/Seq.py", line 108, in complement
    raise ValueError, "Proteins do not have complements!"
ValueError: Proteins do not have complements!
</PRE><!--TOC section Concatenating or adding sequences-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc22">3.6</A>&#XA0;&#XA0;Concatenating or adding sequences</H2><!--SEC END --><P>Naturally, you can in principle add any two Seq objects together - just like you can with python strings to concatenate them. However, you can&#X2019;t add sequences with incompatible alphabets, such as a protein sequence and a DNA sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; protein_seq + dna_seq
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "/usr/local/lib/python2.4/site-packages/Bio/Seq.py", line 42, in __add__
    raise TypeError, ("incompatable alphabets", str(self.alphabet),
TypeError: ('incompatable alphabets', 'IUPACProtein()', 'IUPACUnambiguousDNA()')
</PRE><P>If you <EM>really</EM> wanted to do this, you&#X2019;d have to first give both sequences generic alphabets:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Alphabet import generic_alphabet
&gt;&gt;&gt; protein_seq.alphabet = generic_alphabet
&gt;&gt;&gt; dna_seq.alphabet = generic_alphabet
&gt;&gt;&gt; protein_seq + dna_seq
Seq('EVRNAKACGT', Alphabet())
</PRE><P>Here is an example of adding a generic nucleotide sequence to an unambiguous IUPAC DNA sequence, resulting in an ambiguous nucleotide sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import generic_nucleotide
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; nuc_seq = Seq('GATCGATGC', generic_nucleotide)
&gt;&gt;&gt; dna_seq = Seq('ACGT', IUPAC.unambiguous_dna)
&gt;&gt;&gt; nuc_seq
Seq('GATCGATGC', NucleotideAlphabet())
&gt;&gt;&gt; dna_seq
Seq('ACGT', IUPACUnambiguousDNA())
&gt;&gt;&gt; nuc_seq + dna_seq
Seq('GATCGATGCACGT', NucleotideAlphabet())
</PRE><!--TOC section MutableSeq objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc23">3.7</A>&#XA0;&#XA0;MutableSeq objects</H2><!--SEC END --><P>Just like the normal python string, the <CODE>Seq</CODE> object is &#X201C;read only&#X201D;, or in python terminology, not mutable. Apart from the wanting the <CODE>Seq</CODE> object to act like a string, this is also a useful default since in many biological applications you want to ensure you are not changing your sequence data:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq[5] = "G"
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
AttributeError: 'Seq' instance has no attribute '__setitem__'
</PRE><P>However, you can convert it into a mutable sequence (a <CODE>MutableSeq</CODE> object) and do pretty much anything you want with it:</P><PRE CLASS="verbatim">&gt;&gt;&gt; mutable_seq = my_seq.tomutable()
&gt;&gt;&gt; print mutable_seq
MutableSeq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq[5] = "T"
&gt;&gt;&gt; print mutable_seq
MutableSeq('GATCGTTGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq.remove("T")
&gt;&gt;&gt; print mutable_seq
MutableSeq('GACGTTGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq.reverse()
&gt;&gt;&gt; print mutable_seq
MutableSeq('CGCTAAAAGCTAGGATATATCCGGGTTGCAG', IUPACUnambiguousDNA())
</PRE><!--TOC section Transcribing and Translation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">3.8</A>&#XA0;&#XA0;Transcribing and Translation</H2><!--SEC END --><P>Now that the nature of the sequence object makes some sense, the next
thing to look at is what kind of things we can do with a sequence. The
<CODE>Bio</CODE> directory contains two useful modules to transcribe and
translate a sequence object. These tools work based on the alphabet of
the sequence.</P><P>For instance, let&#X2019;s supposed we want to transcribe a DNA sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_seq = Seq("GATCGATGGGCCTATATAGGATCGAAAATCGC", IUPAC.unambiguous_dna)
</PRE><P>This contains an unambiguous alphabet, so to transcribe we would do the following:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Transcribe
&gt;&gt;&gt; transcriber = Transcribe.unambiguous_transcriber
&gt;&gt;&gt; my_rna_seq = transcriber.transcribe(my_seq)
&gt;&gt;&gt; print my_rna_seq
Seq('GAUCGAUGGGCCUAUAUAGGAUCGAAAAUCGC', IUPACUnambiguousRNA())
</PRE><P>The alphabet of the new RNA Seq object is created for free, so again, dealing with a <CODE>Seq</CODE> object is no more difficult then dealing with a simple string.</P><P>You can also reverse transcribe RNA sequences:</P><PRE CLASS="verbatim">&gt;&gt;&gt; transcriber.back_transcribe(my_rna_seq)
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
</PRE><P>To translate our DNA object we have quite a few choices. First, we can use any number of translation tables depending on what we know about our DNA sequence. The translation tables available in biopython were taken from information at <A HREF="ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt"><TT>ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt</TT></A>. So, you have tons of choices to pick from. For this, let&#X2019;s just focus on two choices: the Standard translation table, and the Translation table for Vertebrate Mitochondrial DNA. These tables are labeled with id numbers 1 and 2, respectively. Now that we know what tables we are looking to get, we&#X2019;re all set to perform a basic translation. First, we need to get our translators that use these tables. Since we are still dealing with our unambiguous DNA object, we want to fetch translators that take this into account:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Translate
&gt;&gt;&gt; standard_translator = Translate.unambiguous_dna_by_id[1]
&gt;&gt;&gt; mito_translator = Translate.unambiguous_dna_by_id[2]
</PRE><P>Once we&#X2019;ve got the proper translators, it&#X2019;s time to go ahead and translate a sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_seq = Seq("GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA", IUPAC.unambiguous_dna)
&gt;&gt;&gt; standard_translator.translate(my_seq)
Seq('AIVMGR*KGAR', IUPACProtein())
&gt;&gt;&gt; mito_translator.translate(my_seq)
Seq('AIVMGRWKGAR', IUPACProtein())
</PRE><P>Notice that the default translation will just go ahead and proceed blindly through a stop codon. If you are aware that you are translating some kind of open reading frame and want to just see everything up until the stop codon, this can be easily done with the <CODE>translate_to_stop</CODE> function:</P><PRE CLASS="verbatim">&gt;&gt;&gt; standard_translator.translate_to_stop(my_seq)
Seq('AIVMGR', IUPACProtein())
</PRE><P>Similar to the transcriber, it is also possible to reverse translate a protein into a DNA sequence:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_protein = Seq("AVMGRWKGGRAAG", IUPAC.protein)
&gt;&gt;&gt; standard_translator.back_translate(my_protein)
Seq('GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGT', IUPACUnambiguousDNA())
</PRE><!--TOC section Working with directly strings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc25">3.9</A>&#XA0;&#XA0;Working with directly strings</H2><!--SEC END --><P>To close this chapter, for those you who <EM>really</EM> don&#X2019;t want to use the sequence objects, there are a few module level functions in <CODE>Bio.Seq</CODE> which will accept plain python strings (or <CODE>Seq</CODE> objects or <CODE>MutableSeq</CODE> objects):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import reverse_complement, transcribe, back_transcribe, translate
&gt;&gt;&gt; my_string = "GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGTTAG"
&gt;&gt;&gt; reverse_complement(my_string)
'CTAACCAGCAGCACGACCACCCTTCCAACGACCCATAACAGC'
&gt;&gt;&gt; transcribe(my_string)
'GCUGUUAUGGGUCGUUGGAAGGGUGGUCGUGCUGCUGGUUAG'
&gt;&gt;&gt; back_transcribe(my_string)
'GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGTTAG'
&gt;&gt;&gt; translate(my_string)
'AVMGRWKGGRAAG*'
</PRE><P>You are however, encouraged to work with the <CODE>Seq</CODE> object by default.</P><!--TOC chapter Sequence Input/Output-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc26">Chapter&#XA0;4</A>&#XA0;&#XA0;Sequence Input/Output</H1><!--SEC END --><P>
<A NAME="chapter:Bio.SeqIO"></A></P><P>In this chapter we&#X2019;ll discuss in more detail the <CODE>Bio.SeqIO</CODE> module, which was briefly introduced in Chapter&#XA0;<A HREF="#chapter:quick-start">2</A>. This is a relatively new interface, added in Biopython 1.43, which aims to provide a simple interface for working with assorted sequence file formats in a uniform way.</P><P>The &#X201C;catch&#X201D; is that you have to work with <CODE>SeqRecord</CODE> ojects - which contain a <CODE>Seq</CODE> object (as described in Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A>) plus annotation like an identifier and description. We&#X2019;ll introduce the basics of <CODE>SeqRecord</CODE> object in this chapter, but see Section&#XA0;<A HREF="#sec:advanced-seq">10.1</A> for more details.</P><!--TOC section Parsing or Reading Sequences-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc27">4.1</A>&#XA0;&#XA0;Parsing or Reading Sequences</H2><!--SEC END --><P>The workhorse function <CODE>Bio.SeqIO.parse()</CODE> is used to read in sequence data as SeqRecord objects. This function expects two arguments:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The first argument is a <I>handle</I> to read the data from. A handle is typically a file opened for reading, but could be the output from a command line program, or data downloaded from the internet (see Section&#XA0;<A HREF="#sec:SeqIO_Online">4.2</A>). See Section&#XA0;<A HREF="#sec:appendix-handles">12.1</A> for more about handles.
</LI><LI CLASS="li-enumerate">The second argument is a lower case string specifying sequence format &#X2013; we don&#X2019;t try and guess the file format for you! See <A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A> for a full listing of supported formats.
</LI></OL><P>This returns an <I>iterator</I> which gives <CODE>SeqRecord</CODE> objects. Iterators are typically used in a for loop.</P><P>Sometimes you&#X2019;ll find yourself dealing with files which contain only a single record. For this situation Biopython 1.45 introduced the function <CODE>Bio.SeqIO.read()</CODE>. Again, this takes a handle and format as arguments. Provided there is one and only one record, this is returned as a <CODE>SeqRecord</CODE> object.</P><!--TOC subsection Reading Sequence Files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">4.1.1</A>&#XA0;&#XA0;Reading Sequence Files</H3><!--SEC END --><P>In general <CODE>Bio.SeqIO.parse()</CODE> is used to read in sequence files as <CODE>SeqRecord</CODE> objects, and is typically used with a for loop like this:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.fasta")
for seq_record in SeqIO.parse(handle, "fasta") :
    print seq_record.id
    print repr(seq_record.seq)
    print len(seq_record.seq)
handle.close()
</PRE><P>The above example is repeated from the introduction in Section&#XA0;<A HREF="#sec:sequence-parsing">2.4</A>, and will load the orchid DNA sequences in the FASTA format file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta">ls_orchid.fasta</A>. If instead you wanted to load a GenBank format file like <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">ls_orchid.gbk</A> then all you need to do is change the filename and the format string:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.gbk")
for seq_record in SeqIO.parse(handle, "genbank") :
    print seq_record.id
    print seq_record.seq
    print len(seq_record.seq)
handle.close()
</PRE><P>Similarly, if you wanted to read in a file in another file format, then assuming <CODE>Bio.SeqIO.parse()</CODE> supports it you would just need to change the format string as appropriate, for example &#X201C;swiss&#X201D; for SwissProt files or &#X201C;embl&#X201D; for EMBL text files. There is a full listing on the wiki page (<A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A>).</P><!--TOC subsection Iterating over the records in a sequence file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">4.1.2</A>&#XA0;&#XA0;Iterating over the records in a sequence file</H3><!--SEC END --><P>In the above examples, we have usually used a for loop to iterate over all the records one by one. You can use the for loop with all sorts of Python objects (including lists, tuples and strings) which support the iteration interface.</P><P>The object returned by <CODE>Bio.SeqIO</CODE> is actually an iterator which returns <CODE>SeqRecord</CODE> objects. You get to see each record in turn, but once and only once. The plus point is that an iterator can save you memory when dealing with large files.</P><P>Instead of using a for loop, can also use the <CODE>.next()</CODE> method of an iterator to step through the entries, like this:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.fasta")
record_iterator = SeqIO.parse(handle, "fasta")

first_record = record_iterator.next()
print first_record.id
print first_record.description

second_record = record_iterator.next()
print second_record.id
print second_record.description

handle.close()
</PRE><P>Note that if you try and use <CODE>.next()</CODE> and there are no more results, you&#X2019;ll either get back the special Python object <CODE>None</CODE> or a <CODE>StopIteration</CODE> exception.</P><P>One special case to consider is when your sequence files have multiple records, but you only want the first one. In this situation the following code is very concise:</P><PRE CLASS="verbatim">from Bio import SeqIO
first_record  = SeqIO.parse(open("ls_orchid.gbk"), "genbank").next()
</PRE><P>A word of warning here &#X2013; using the <CODE>.next()</CODE> method like this will silently ignore any additional records in the file.
If your files have <I>one and only one</I> record, like some of the online examples later in this chapter, or a GenBank file for a single chromosome, then use the new <CODE>Bio.SeqIO.read()</CODE> function instead.
This will check there are no extra unexpected records present.</P><!--TOC subsection Getting a list of the records in a sequence file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">4.1.3</A>&#XA0;&#XA0;Getting a list of the records in a sequence file</H3><!--SEC END --><P>In the previous section we talked about the fact that <CODE>Bio.SeqIO.parse()</CODE> gives you a <CODE>SeqRecord</CODE> iterator, and that you get the records one by one. Very often you need to be able to access the records in any order. The Python <I>list</I> data type is perfect for this, and we can turn the record iterator into a list of <CODE>SeqRecord</CODE> objects using the built-in Python function <CODE>list()</CODE> like so:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.gbk")
records = list(SeqIO.parse(handle, "genbank"))
handle.close()

print "Found %i records" % len(records)

print "The last record"
last_record = records[-1] #using Python's list tricks
print last_record.id
print repr(last_record.seq)
print len(last_record.seq)

print "The first record"
first_record = records[0] #remember, Python counts from zero
print first_record.id
print repr(first_record.seq)
print len(first_record.seq)
</PRE><P>Giving:</P><PRE CLASS="verbatim">Found 94 records
The last record
Z78439.1
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACT...GCC', IUPACAmbiguousDNA())
592
The first record
Z78533.1
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', IUPACAmbiguousDNA())
740
</PRE><P>You can of course still use a for loop with a list of <CODE>SeqRecord</CODE> objects. Using a list is much more flexible than an iterator (for example, you can determine the number of records from the length of the list), but does need more memory because it will hold all the records in memory at once.</P><!--TOC subsection Extracting data-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">4.1.4</A>&#XA0;&#XA0;Extracting data</H3><!--SEC END --><P>Suppose you wanted to extract a list of the species from the <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">ls_orchid.gbk</A> GenBank file. Let&#X2019;s have a close look at the first record in the file and see where the species gets stored:</P><PRE CLASS="verbatim">from Bio import SeqIO
record_iterator = SeqIO.parse(open("ls_orchid.gbk"), "genbank")
first_record = record_iterator.next()
print first_record
</PRE><P>That should give something like this:</P><PRE CLASS="verbatim">ID: Z78533.1
Name: Z78533
Desription: C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA.
/source=Cypripedium irapeanum
/taxonomy=['Eukaryota', 'Viridiplantae', 'Streptophyta', ..., 'Cypripedium']
/keywords=['5.8S ribosomal RNA', '5.8S rRNA gene', 'internal transcribed spacer', 'ITS1', 'ITS2']
/references=[...]
/accessions=['Z78533']
/data_file_division=PLN
/date=30-NOV-2006
/organism=Cypripedium irapeanum
/gi=2765658
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', IUPACAmbiguousDNA())
</PRE><P>The information we want, <EM>Cypripedium irapeanum</EM>, is held in the annotations dictionary under &#X2018;source&#X2019; and &#X2018;organism&#X2019;, which we can access like this:</P><PRE CLASS="verbatim">print first_record.annotations["source"]
</PRE><P>or:</P><PRE CLASS="verbatim">print first_record.annotations["organism"]
</PRE><P>In general, &#X2018;organism&#X2019; is used for the scientific name (in latin, e.g. <I>Arabidopsis thaliana</I>),
while &#X2018;source&#X2019; will often be the common name (e.g. thale cress). In this example, as is often the case,
the two fields are identical. </P><P>Now let&#X2019;s go through all the records, building up a list of the species each orchid sequence is from:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.gbk")
all_species = []
for seq_record in SeqIO.parse(handle, "genbank") :
    all_species.append(seq_record.annotations["organism"])
handle.close()
print all_species
</PRE><P>Another way of writing this code is to use a list comprehension (introduced in Python 2.0) like this:</P><PRE CLASS="verbatim">from Bio import SeqIO
all_species = [seq_record.annotations["organism"] for seq_record in \
               SeqIO.parse(open("ls_orchid.gbk"), "genbank")]
print all_species
</PRE><P>In either case, the result is:</P><PRE CLASS="verbatim">['Cypripedium irapeanum', 'Cypripedium californicum', ..., 'Paphiopedilum barbatum']
</PRE><P>Great. That was pretty easy because GenBank files are annotated in a standardised way. Now, let&#X2019;s suppose you wanted to extract a list of the species from your FASTA file, rather than the GenBank file. The bad news is you will have to write some code to extract the data you want from the record&#X2019;s description line - if the information is in the file in the first place!</P><P>For this example, notice that if you break up the description line at the spaces, then the species is there as field number one (field zero is the record identifier). That means we can do this:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.fasta")
all_species = []
for seq_record in SeqIO.parse(handle, "fasta") :
    all_species.append(seq_record.description.split()[1])
handle.close()
print all_species
</PRE><P>This gives:</P><PRE CLASS="verbatim">['C.irapeanum', 'C.californicum', 'C.fasciculatum', 'C.margaritaceum', ..., 'P.barbatum']
</PRE><P>The concise alternative using list comprehensions (Python 2.0 or later) would be:</P><PRE CLASS="verbatim">from Bio import SeqIO
all_species == [seq_record.description.split()[1] for seq_record in \
                SeqIO.parse(open("ls_orchid.fasta"), "fasta")]
print all_species
</PRE><P>In general, extracting information from the FASTA description line is not very nice.
If you can get your sequences in a well annotated file format like GenBank or EMBL,
then this sort of annotation information is much easier to deal with.</P><!--TOC section Parsing sequences from the net-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc32">4.2</A>&#XA0;&#XA0;Parsing sequences from the net</H2><!--SEC END --><P>
<A NAME="sec:SeqIO_Online"></A>
In the previous section, we looked at parsing sequence data from a file handle.
We hinted that handles are not always from files, and in this section we&#X2019;ll use
handles to internet connections to download sequences.</P><P>Note that just because you <EM>can</EM> download sequence data and parse it into
a <CODE>SeqRecord</CODE> object in one go doesn&#X2019;t mean this is always a good idea.
In general, you should probably download sequences <EM>once</EM> and save them to
a file for reuse.</P><!--TOC subsection Parsing GenBank records from the net-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">4.2.1</A>&#XA0;&#XA0;Parsing GenBank records from the net</H3><!--SEC END --><P>
<A NAME="sec:SeqIO_GenBank_Online"></A>
Section&#XA0;<A HREF="#sec:efetch">7.6</A> talks about the Entrez EFetch interface in more detail,
but for now let&#X2019;s just connect to the NCBI and get a few orchid proteins from
GenBank using their GI numbers.</P><P>First of all, let&#X2019;s fetch just one record. Remember, when you expect the handle
to contain one and only one record, use the <CODE>Bio.SeqIO.read()</CODE> function:</P><PRE CLASS="verbatim">from Bio import Entrez
form Bio import SeqIO
handle = Entrez.efetch(db="protein", rettype="genbank", id="6273291")
seq_record = SeqIO.read(handle, "genbank")
handle.close()
print "%s with %i features" % (seq_record.id, len(seq_record.features))
</PRE><P>Expected output:</P><PRE CLASS="verbatim">gi|6273291|gb|AF191665.1|AF191665 with 3 features
</PRE><P>The NCBI will also let you ask for the file in other formats, for example as a
FASTA file. If you don&#X2019;t care about the annotations and features in a GenBank
file, this is a better choice to download because it&#X2019;s a smaller file:</P><PRE CLASS="verbatim">from Bio import Entrez
form Bio import SeqIO
handle = Entrez.efetch(db="protein", rettype="fasta", id="6273291")
seq_record = SeqIO.read(handle, "fasta")
handle.close()
print "%s with %i features" % (seq_record.id, len(seq_record.features))
</PRE><P>Expected output:</P><PRE CLASS="verbatim">gi|6273291|gb|AF191665.1|AF191665 with 0 features
</PRE><P>Now let&#X2019;s fetch several records. This time the handle contains multiple records,
so we must use the <CODE>Bio.SeqIO.parse()</CODE> function:</P><PRE CLASS="verbatim">from Bio import Entrez
form Bio import SeqIO
handle = Entrez.efetch(db="protein", rettype="genbank", \
                       id="6273291,6273290,6273289")
for seq_record in SeqIO.parse(handle, "genbank") :
    print seq_record.id, seq_record.description[:50] + "..."
    print "Sequence length %i," % len(seq_record),
    print "%i features," % len(seq_record.features),
    print "from: %s" % seq_record.annotations['source']
handle.close()
</PRE><P>That should give the following output:</P><PRE CLASS="verbatim">AF191665.1 Opuntia marenae rpl16 gene; chloroplast gene for c...
Sequence length 902, 3 features, from: chloroplast Opuntia marenae
AF191664.1 Opuntia clavata rpl16 gene; chloroplast gene for c...
Sequence length 899, 3 features, from: chloroplast Grusonia clavata
AF191663.1 Opuntia bradtiana rpl16 gene; chloroplast gene for...
Sequence length 899, 3 features, from: chloroplast Opuntia bradtianaa
</PRE><P>See Chapter&#XA0;<A HREF="#chapter:entrez">7</A> for more about the <CODE>Bio.Entrez</CODE> module, and make sure to read about the NCBI guidelines for using Entrez (Section&#XA0;<A HREF="#sec:entrez-guidelines">7.1</A>).</P><!--TOC subsection Parsing SwissProt sequences from the net-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">4.2.2</A>&#XA0;&#XA0;Parsing SwissProt sequences from the net</H3><!--SEC END --><P>
<A NAME="sec:SeqIO_ExPASy_and_SwissProt"></A>
Now let&#X2019;s use a handle to download a SwissProt file from ExPASy, something covered in more depth in Chapter&#XA0;<A HREF="#chapter:swiss_prot">8</A>.
As mentioned above, the <CODE>Bio.SeqIO.read()</CODE> function is included in Biopython 1.45 or later.</P><PRE CLASS="verbatim">from Bio import ExPASy
from Bio import SeqIO
handle = ExPASy.get_sprot_raw("O23729")
seq_record = SeqIO.read(handle, "swiss")
handle.close()
print seq_record.id
print seq_record.name
print seq_record.description
print repr(seq_record.seq)
print "Length %i" % len(seq_record)
print seq_record.annotations['keywords']
</PRE><P>Assuming your network connection is OK, you should get back:</P><PRE CLASS="verbatim">O23729
CHS3_BROFI
Chalcone synthase 3 (EC 2.3.1.74) (Naringenin-chalcone synthase 3).
Seq('MAPAMEEIRQAQRAEGPAAVLAIGTSTPPNALYQADYPDYYFRITKSEHLTELK...GAE', ProteinAlphabet())
Length 394
['Acyltransferase', 'Flavonoid biosynthesis', 'Transferase']
</PRE><!--TOC section Sequence files as Dictionaries-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc35">4.3</A>&#XA0;&#XA0;Sequence files as Dictionaries</H2><!--SEC END --><P>The next thing that we&#X2019;ll do with our ubiquitous orchid files is to show how to index them and access them like a database using the Python <I>dictionary</I> datatype (like a hash in Perl). This is very useful for large files where you only need to access certain elements of the file, and makes for a nice quick &#X2019;n dirty database.</P><P>You can use the function <CODE>SeqIO.to_dict()</CODE> to make a SeqRecord dictionary (in memory). By default this will use each record&#X2019;s identifier (i.e. the <CODE>.id</CODE> attribute) as the key. Let&#X2019;s try this using our GenBank file:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.gbk")
orchid_dict = SeqIO.to_dict(SeqIO.parse(handle, "genbank"))
handle.close()
</PRE><P>Since this variable <CODE>orchid_dict</CODE> is an ordinary Python dictionary, we can look at all of the keys we have available:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print orchid_dict.keys()
['Z78484.1', 'Z78464.1', 'Z78455.1', 'Z78442.1', 'Z78532.1', 'Z78453.1', ..., 'Z78471.1']
</PRE><P>We can access a single <CODE>SeqRecord</CODE> object via the keys and manipulate the object as normal:</P><PRE CLASS="verbatim">&gt;&gt;&gt; seq_record = orchid_dict["Z78475.1"]
&gt;&gt;&gt; print seq_record.description
P.supardii 5.8S rRNA gene and ITS1 and ITS2 DNA
&gt;&gt;&gt; print repr(seq_record.seq)
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGTTGAGATCACAT...GGT', IUPACAmbiguousDNA())
</PRE><P>So, it is very easy to create an in memory &#X201C;database&#X201D; of our GenBank records. Next we&#X2019;ll try this for the FASTA file instead.</P><!--TOC subsection Specifying the dictionary keys-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">4.3.1</A>&#XA0;&#XA0;Specifying the dictionary keys</H3><!--SEC END --><P>Using the same code as above, but for the FASTA file instead:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.fasta")
orchid_dict = SeqIO.to_dict(SeqIO.parse(handle, "fasta"))
handle.close()
print orchid_dict.keys()
</PRE><P>This time the keys are:</P><PRE CLASS="verbatim">['gi|2765596|emb|Z78471.1|PDZ78471', 'gi|2765646|emb|Z78521.1|CCZ78521', ...
 ..., 'gi|2765613|emb|Z78488.1|PTZ78488', 'gi|2765583|emb|Z78458.1|PHZ78458']
</PRE><P>You should recognise these strings from when we parsed the FASTA file earlier in Section&#XA0;<A HREF="#sec:fasta-parsing">2.4.1</A>. Suppose you would rather have something else as the keys - like the accesion numbers. This brings us nicely to <CODE>SeqIO.to_dict()</CODE>&#X2019;s optional argument <CODE>key_function</CODE>, which lets you define what to use as the dictionary key for your records.</P><P>First you must write your own function to return the key you want (as a string) when given a <CODE>SeqRecord</CODE> object. In general, the details of function will depend on the sort of input records you are dealing with. But for our orchids, we can just split up the record&#X2019;s identifier using the &#X201C;pipe&#X201D; character (the vertical line) and return the fourth entry (field three):</P><PRE CLASS="verbatim">def get_accession(record) :
    """"Given a SeqRecord, return the accession number as a string
  
    e.g. "gi|2765613|emb|Z78488.1|PTZ78488" -&gt; "Z78488.1"
    """
    parts = record.id.split("|")
    assert len(parts) == 5 and parts[0] == "gi" and parts[2] == "emb"
    return parts[3]
</PRE><P>Then we can give this function to the <CODE>SeqIO.to_dict()</CODE> function to use in building the dictionary:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("ls_orchid.fasta")
orchid_dict = SeqIO.to_dict(SeqIO.parse(handle, "fasta"), key_function=get_accession)
handle.close()
print orchid_dict.keys()
</PRE><P>Finally, as desired, the new dictionary keys:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print orchid_dict.keys()
['Z78484.1', 'Z78464.1', 'Z78455.1', 'Z78442.1', 'Z78532.1', 'Z78453.1', ..., 'Z78471.1']
</PRE><P>Not too complicated, I hope!</P><!--TOC subsection Indexing a dictionary using the SEGUID checksum-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc37">4.3.2</A>&#XA0;&#XA0;Indexing a dictionary using the SEGUID checksum</H3><!--SEC END --><P>To give another example of working with dictionaries of SeqRecord objects, we&#X2019;ll use the SEGUID checksum function (added in Biopython 1.44). This is a relatively recent checksum, and collisions should be very rare (i.e. two different sequences with the same checksum), an improvement on the CRC64 checksum.</P><P>Once again, working with the orchids GenBank file:</P><PRE CLASS="verbatim">from Bio import SeqIO
from Bio.SeqUtils.CheckSum import seguid
for record in SeqIO.parse(open("ls_orchid.gbk"), "genbank") :
    print record.id, seguid(record.seq)
</PRE><P>This should give:</P><PRE CLASS="verbatim">Z78533.1 JUEoWn6DPhgZ9nAyowsgtoD9TTo
Z78532.1 MN/s0q9zDoCVEEc+k/IFwCNF2pY
...
Z78439.1 H+JfaShya/4yyAj7IbMqgNkxdxQ
</PRE><P>Now, recall the <CODE>Bio.SeqIO.to_dict()</CODE> function&#X2019;s <CODE>key_function</CODE> argument expects a function which turns a SeqRecord into a string. We can&#X2019;t use the <CODE>seguid()</CODE> function directly because it expects to be given a Seq object (or a string). However, we can use python&#X2019;s <CODE>lambda</CODE> feature to create a &#X201C;one off&#X201D; function to give to <CODE>Bio.SeqIO.to_dict()</CODE> instead:</P><PRE CLASS="verbatim">from Bio import SeqIO
from Bio.SeqUtils.CheckSum import seguid
seguid_dict = SeqIO.to_dict(SeqIO.parse(open("ls_orchid.gbk"), "genbank"),
                            lambda rec : seguid(rec.seq))
record = seguid_dict["MN/s0q9zDoCVEEc+k/IFwCNF2pY"]
print record.id
print record.description
</PRE><P>That should have retrieved the record <TT>Z78532.1</TT>, the second entry in the file.</P><!--TOC section Writing Sequence Files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc38">4.4</A>&#XA0;&#XA0;Writing Sequence Files</H2><!--SEC END --><P>We&#X2019;ve talked about using <CODE>Bio.SeqIO.parse()</CODE> for sequence input (reading files), and now we&#X2019;ll look at <CODE>Bio.SeqIO.write()</CODE> which is for sequence output (writing files). This is a function taking three arguments: some <CODE>SeqRecord</CODE> objects, a handle to write to, and a sequence format.</P><P>Here is an example, where we start by creating a few <CODE>SeqRecord</CODE> objects the hard way (by hand, rather than by loading them from a file):</P><PRE CLASS="verbatim">from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Alphabet import generic_protein

rec1 = SeqRecord(Seq("MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGD" \
                    +"GAGAVIVGSDPDLSVERPLYELVWTGATLLPDSEGAIDGHLREVGLTFHLLKDVPGLISK" \
                    +"NIEKSLKEAFTPLGISDWNSTFWIAHPGGPAILDQVEAKLGLKEEKMRATREVLSEYGNM" \
                    +"SSAC", generic_protein),
                 id="gi|14150838|gb|AAK54648.1|AF376133_1",
                 description="chalcone synthase [Cucumis sativus]")

rec2 = SeqRecord(Seq("YPDYYFRITNREHKAELKEKFQRMCDKSMIKKRYMYLTEEILKENPSMCEYMAPSLDARQ" \
                    +"DMVVVEIPKLGKEAAVKAIKEWGQ", generic_protein),
                 id="gi|13919613|gb|AAK33142.1|",
                 description="chalcone synthase [Fragaria vesca subsp. bracteata]")

rec3 = SeqRecord(Seq("MVTVEEFRRAQCAEGPATVMAIGTATPSNCVDQSTYPDYYFRITNSEHKVELKEKFKRMC" \
                    +"EKSMIKKRYMHLTEEILKENPNICAYMAPSLDARQDIVVVEVPKLGKEAAQKAIKEWGQP" \
                    +"KSKITHLVFCTTSGVDMPGCDYQLTKLLGLRPSVKRFMMYQQGCFAGGTVLRMAKDLAEN" \
                    +"NKGARVLVVCSEITAVTFRGPNDTHLDSLVGQALFGDGAAAVIIGSDPIPEVERPLFELV" \
                    +"SAAQTLLPDSEGAIDGHLREVGLTFHLLKDVPGLISKNIEKSLVEAFQPLGISDWNSLFW" \
                    +"IAHPGGPAILDQVELKLGLKQEKLKATRKVLSNYGNMSSACVLFILDEMRKASAKEGLGT" \
                    +"TGEGLEWGVLFGFGPGLTVETVVLHSVAT", generic_protein),
                 id="gi|13925890|gb|AAK49457.1|",
                 description="chalcone synthase [Nicotiana tabacum]")
               
my_records = [rec1, rec2, rec3]
</PRE><P>Now we have a list of <CODE>SeqRecord</CODE> objects, we&#X2019;ll write them to a FASTA format file:</P><PRE CLASS="verbatim">from Bio import SeqIO
handle = open("my_example.faa", "w")
SeqIO.write(my_records, handle, "fasta")
handle.close()
</PRE><P>And if you open this file in your favourite text editor it should look like this:</P><PRE CLASS="verbatim">&gt;gi|14150838|gb|AAK54648.1|AF376133_1 chalcone synthase [Cucumis sativus]
MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGD
GAGAVIVGSDPDLSVERPLYELVWTGATLLPDSEGAIDGHLREVGLTFHLLKDVPGLISK
NIEKSLKEAFTPLGISDWNSTFWIAHPGGPAILDQVEAKLGLKEEKMRATREVLSEYGNM
SSAC
&gt;gi|13919613|gb|AAK33142.1| chalcone synthase [Fragaria vesca subsp. bracteata]
YPDYYFRITNREHKAELKEKFQRMCDKSMIKKRYMYLTEEILKENPSMCEYMAPSLDARQ
DMVVVEIPKLGKEAAVKAIKEWGQ
&gt;gi|13925890|gb|AAK49457.1| chalcone synthase [Nicotiana tabacum]
MVTVEEFRRAQCAEGPATVMAIGTATPSNCVDQSTYPDYYFRITNSEHKVELKEKFKRMC
EKSMIKKRYMHLTEEILKENPNICAYMAPSLDARQDIVVVEVPKLGKEAAQKAIKEWGQP
KSKITHLVFCTTSGVDMPGCDYQLTKLLGLRPSVKRFMMYQQGCFAGGTVLRMAKDLAEN
NKGARVLVVCSEITAVTFRGPNDTHLDSLVGQALFGDGAAAVIIGSDPIPEVERPLFELV
SAAQTLLPDSEGAIDGHLREVGLTFHLLKDVPGLISKNIEKSLVEAFQPLGISDWNSLFW
IAHPGGPAILDQVELKLGLKQEKLKATRKVLSNYGNMSSACVLFILDEMRKASAKEGLGT
TGEGLEWGVLFGFGPGLTVETVVLHSVAT
</PRE><!--TOC subsection Converting between sequence file formats-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">4.4.1</A>&#XA0;&#XA0;Converting between sequence file formats</H3><!--SEC END --><P>In previous example we used a list of <CODE>SeqRecord</CODE> objects as input to the <CODE>Bio.SeqIO.write()</CODE> function, but it will also accept a <CODE>SeqRecord</CODE> interator like we get from <CODE>Bio.SeqIO.parse()</CODE> &#X2013; this lets us do file conversion very succinctly. For this example we&#X2019;ll read in the GenBank format file <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">ls_orchid.gbk</A> and write it out in FASTA format:</P><PRE CLASS="verbatim">from Bio import SeqIO
in_handle = open("ls_orchid.gbk", "r")
out_handle = open("my_example.fasta", "w")
SeqIO.write(SeqIO.parse(in_handle, "genbank"), out_handle, "fasta")
in_handle.close()
out_handle.close()
</PRE><P>You <I>can</I> in fact do this in one line, by being lazy about closing the file handles. This is arguably bad style, but it is very concise:</P><PRE CLASS="verbatim">from Bio import SeqIO
SeqIO.write(SeqIO.parse(open("ls_orchid.gbk"), "genbank"), open("my_example.faa", "w"), "fasta")
</PRE><!--TOC subsection Converting a file of sequences to their reverse complements-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">4.4.2</A>&#XA0;&#XA0;Converting a file of sequences to their reverse complements</H3><!--SEC END --><P>Suppose you had a file of nucleotide sequences, and you wanted to turn it into a file containing their reverse complement sequences. This time a little bit of work is required to transform the SeqRecords we get from our input file into something suitable for saving to our output file.</P><P>To start with, we&#X2019;ll use <CODE>Bio.SeqIO.parse()</CODE> to load some nucleotide
sequences from a file, then print out their reverse complements using
the <CODE>Seq</CODE> object&#X2019;s built in <CODE>.reverse_complement()</CODE> method (see Section&#XA0;<A HREF="#sec:seq-reverse-complement">3.5</A>):</P><PRE CLASS="verbatim">from Bio import SeqIO
in_handle = open("ls_orchid.gbk")
for record in SeqIO.parse(in_handle, "genbank") :
    print record.id
    print record.seq.reverse_complement().tostring()
in_handle.close()
</PRE><P>Now, if we want to save these reverse complements to a file, we&#X2019;ll need to make <CODE>SeqRecord</CODE> objects.
For this I think its most elegant to write our own function, where we can decide how to name our
new records:</P><PRE CLASS="verbatim">from Bio.SeqRecord import SeqRecord

def make_rc_record(record) :
    """Returns a new SeqRecord with the reverse complement sequence"""
    rc_rec = SeqRecord(seq = record.seq.reverse_complement(), \
                       id = "rc_" + record.id, \
                       name = "rc_" + record.name, \
                       description = "reverse complement")
    return rc_rec
</PRE><P>We can then use this to turn the input records into reverse complement records ready for output. If you don&#X2019;t mind about having all the records in memory at once, then the python <CODE>map()</CODE> function is a very intuitive way of doing this:</P><PRE CLASS="verbatim">from Bio import SeqIO

in_handle = open("ls_orchid.fasta", "r")
records = map(make_rc_record, SeqIO.parse(in_handle, "fasta"))
in_handle.close()

out_handle = open("rev_comp.fasta", "w")
SeqIO.write(records, out_handle, "fasta")
out_handle.close()
</PRE><P>This is an excellent place to demonstrate the power of list comprehensions (added to Python 2.0) which in their simplest are a long-winded equivalent to using <CODE>map()</CODE>, like this:</P><PRE CLASS="verbatim">records = [make_rc_record(rec) for rec in SeqIO.parse(in_handle, "fasta")]
</PRE><P>Now list comprehensions have a nice trick up their sleaves, you can add a conditional statement:</P><PRE CLASS="verbatim">records = [make_rc_record(rec) for rec in SeqIO.parse(in_handle, "fasta") if len(rec)&lt;700]
</PRE><P>That would create an in memory list of reverse complement records where the sequence length was under 700 base pairs. However, if you are using Python 2.4 or later, we can do exactly the same with a generator expression - but with the advantage that this does not create a list of all the records in memory at once:</P><PRE CLASS="verbatim">records = (make_rc_record(rec) for rec in SeqIO.parse(in_handle, "fasta") if len(rec)&lt;700)
</PRE><P>If you like compact code, and don&#X2019;t mind being lax about closing file handles, we can reduce this to one long line:</P><PRE CLASS="verbatim">from Bio import SeqIO
SeqIO.write((make_rc_record(rec) for rec in \
            SeqIO.parse(open("ls_orchid.fasta", "r"), "fasta") if len(rec) &lt; 700), \
            open("rev_comp.fasta", "w"), "fasta")
</PRE><P>Personally, I think the above snippet of code is a little too compact, and I find the following much easier to read:</P><PRE CLASS="verbatim">from Bio import SeqIO
records = (make_rc_record(rec) for rec in \
           SeqIO.parse(open("ls_orchid.fasta", "r"), "fasta") \
           if len(rec) &lt; 700)
SeqIO.write(records, open("rev_comp.fasta", "w"), "fasta")
</PRE><P>or, for Python 2.3 or older,</P><PRE CLASS="verbatim">from Bio import SeqIO
records = [make_rc_record(rec) for rec in \
           SeqIO.parse(open("ls_orchid.fasta", "r"), "fasta") \
           if len(rec) &lt; 700]
SeqIO.write(records, open("rev_comp.fasta", "w"), "fasta")
</PRE><!--TOC chapter Sequence Alignment Input/Output-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc41">Chapter&#XA0;5</A>&#XA0;&#XA0;Sequence Alignment Input/Output</H1><!--SEC END --><P>
<A NAME="chapter:Bio.AlignIO"></A></P><P>In this chapter we&#X2019;ll discuss the <CODE>Bio.AlignIO</CODE> module, which is very similar to the <CODE>Bio.SeqIO</CODE> module from the previous chapter, but deals with <CODE>Alignment</CODE> objects rather than <CODE>SeqRecord</CODE> objects. 
This is new interface in Biopython 1.46, which aims to provide a simple interface for working with assorted sequence alignment file formats in a uniform way.</P><P>Note that both <CODE>Bio.SeqIO</CODE> and <CODE>Bio.AlignIO</CODE> can read and write sequence alignment files. The appropriate choice will depend largely on what you want to do with the data.</P><!--TOC section Parsing or Reading Sequence Alignments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc42">5.1</A>&#XA0;&#XA0;Parsing or Reading Sequence Alignments</H2><!--SEC END --><P>We have two functions for reading in sequence alignments, <CODE>Bio.AlignIO.read()</CODE> and <CODE>Bio.AlignIO.parse()</CODE> which following the convention introduced in <CODE>Bio.SeqIO</CODE> are for files containing one or multiple alignments respectively.</P><P>Using <CODE>Bio.AlignIO.parse()</CODE> will return an <I>iterator</I> which gives <CODE>Alignment</CODE> objects. Iterators are typically used in a for loop. Examples of situations where you will have multiple different alignments include resampled alignments from the PHYLIP tool <CODE>seqboot</CODE>, or multiple pairwise alignments from the EMBOSS tools <CODE>water</CODE> or <CODE>needle</CODE>, or Bill Pearson&#X2019;s FASTA tools.</P><P>However, in many situations you will be dealing with files which contain only a single alignment. In this case, you should use the <CODE>Bio.AlignIO.read()</CODE> function which return a single <CODE>Alignment</CODE> object.</P><P>Both functions expect two mandatory arguments:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The first argument is a <I>handle</I> to read the data from, typically an open file (see Section&#XA0;<A HREF="#sec:appendix-handles">12.1</A>).
</LI><LI CLASS="li-enumerate">The second argument is a lower case string specifying sequence coformat. As in <CODE>Bio.SeqIO</CODE> we don&#X2019;t try and guess the file format for you! See <A HREF="http://biopython.org/wiki/AlignIO"><TT>http://biopython.org/wiki/AlignIO</TT></A> for a full listing of supported formats.
</LI></OL><P>There is also an optional <CODE>seq_count</CODE> argument which is discussed in Section&#XA0;<A HREF="#sec:AlignIO-count-argument">5.1.3</A> below for dealing with ambigous file formats which may contain more than one alignment.</P><!--TOC subsection Single Alignments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">5.1.1</A>&#XA0;&#XA0;Single Alignments</H3><!--SEC END --><P>
As an example, consider the following annotation rich protein alignment in the PFAM or Stockholm file format:</P><PRE CLASS="verbatim"># STOCKHOLM 1.0
#=GS COATB_BPIKE/30-81  AC P03620.1
#=GS COATB_BPIKE/30-81  DR PDB; 1ifl ; 1-52;
#=GS Q9T0Q8_BPIKE/1-52  AC Q9T0Q8.1
#=GS COATB_BPI22/32-83  AC P15416.1
#=GS COATB_BPM13/24-72  AC P69541.1
#=GS COATB_BPM13/24-72  DR PDB; 2cpb ; 1-49;
#=GS COATB_BPM13/24-72  DR PDB; 2cps ; 1-49;
#=GS COATB_BPZJ2/1-49   AC P03618.1
#=GS Q9T0Q9_BPFD/1-49   AC Q9T0Q9.1
#=GS Q9T0Q9_BPFD/1-49   DR PDB; 1nh4 A; 1-49;
#=GS COATB_BPIF1/22-73  AC P03619.2
#=GS COATB_BPIF1/22-73  DR PDB; 1ifk ; 1-50;
COATB_BPIKE/30-81             AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA
#=GR COATB_BPIKE/30-81  SS    -HHHHHHHHHHHHHH--HHHHHHHH--HHHHHHHHHHHHHHHHHHHHH----
Q9T0Q8_BPIKE/1-52             AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA
COATB_BPI22/32-83             DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA
COATB_BPM13/24-72             AEGDDP...AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
#=GR COATB_BPM13/24-72  SS    ---S-T...CHCHHHHCCCCTCCCTTCHHHHHHHHHHHHHHHHHHHHCTT--
COATB_BPZJ2/1-49              AEGDDP...AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA
Q9T0Q9_BPFD/1-49              AEGDDP...AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
#=GR Q9T0Q9_BPFD/1-49   SS    ------...-HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH--
COATB_BPIF1/22-73             FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA
#=GR COATB_BPIF1/22-73  SS    XX-HHHH--HHHHHH--HHHHHHH--HHHHHHHHHHHHHHHHHHHHHHH---
#=GC SS_cons                  XHHHHHHHHHHHHHHHCHHHHHHHHCHHHHHHHHHHHHHHHHHHHHHHHC--
#=GC seq_cons                 AEssss...AptAhDSLpspAT-hIu.sWshVsslVsAsluIKLFKKFsSKA
//
</PRE><P>This is the seed alignment for the Phage_Coat_Gp8 (PF05371) PFAM entry, downloaded as a compressed archive from <A HREF="http://pfam.sanger.ac.uk/family/alignment/download/gzipped?acc=PF05371&alnType=seed"><TT>http://pfam.sanger.ac.uk/family/alignment/download/gzipped?acc=PF05371&amp;alnType=seed</TT></A>. We can load this file as follows (assuming it has been saved to disk as &#X201C;PF05371_seed.sth&#X201D; in the current working directory):</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read(open("PF05371_seed.sth"), "stockholm")
print alignment
</PRE><P>This code will print out a summary of the alignment:</P><PRE CLASS="verbatim">SingleLetterAlphabet() alignment with 7 rows and 52 columns
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRL...SKA COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKL...SRA Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRL...SKA COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKL...SKA Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKL...SRA COATB_BPIF1/22-73
</PRE><P>You&#X2019;ll notice in the above output the sequences have been truncated. We could instead write our own code to format this as we please by iterating over the rows as <CODE>SeqRecord</CODE> objects:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read(open("PF05371_seed.sth"), "stockholm")
print "Alignment length %i" % alignment.get_alignment_length()
for record in alignment :
    print "%s - %s" % (record.seq, record.id)
</PRE><P>This will give the following output:</P><PRE CLASS="verbatim">Alignment length 52
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA - COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA - Q9T0Q8_BPIKE/1-52
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA - COATB_BPI22/32-83
AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - COATB_BPM13/24-72
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA - COATB_BPZJ2/1-49
AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA - Q9T0Q9_BPFD/1-49
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA - COATB_BPIF1/22-73
</PRE><P>Did you notice in the raw file above that several of the sequences include database cross-references to the PDB and the associated known secondary strucutre? Try this:</P><PRE CLASS="verbatim">for record in alignment :
    if record.dbxrefs :
        print record.id, record.dbxrefs
</PRE><P>giving:</P><PRE CLASS="verbatim">COATB_BPIKE/30-81 ['PDB; 1ifl ; 1-52;']
COATB_BPM13/24-72 ['PDB; 2cpb ; 1-49;', 'PDB; 2cps ; 1-49;']
Q9T0Q9_BPFD/1-49 ['PDB; 1nh4 A; 1-49;']
COATB_BPIF1/22-73 ['PDB; 1ifk ; 1-50;']
</PRE><P>To have a look at all the sequence annotation, try this:</P><PRE CLASS="verbatim">for record in alignment :
    print record
</PRE><P>Sanger provide a nice web interface at <A HREF="http://pfam.sanger.ac.uk/family?acc=PF05371"><TT>http://pfam.sanger.ac.uk/family?acc=PF05371</TT></A> which will actually let you download this alignment in several other formats. This is what the file looks like in the FASTA file format:</P><PRE CLASS="verbatim">&gt;COATB_BPIKE/30-81
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA
&gt;Q9T0Q8_BPIKE/1-52
AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVSRA
&gt;COATB_BPI22/32-83
DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSSKA
&gt;COATB_BPM13/24-72
AEGDDP...AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
&gt;COATB_BPZJ2/1-49
AEGDDP...AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFASKA
&gt;Q9T0Q9_BPFD/1-49
AEGDDP...AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTSKA
&gt;COATB_BPIF1/22-73
FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVSRA
</PRE><P>Assuming you download and save this as file &#X201C;PF05371_seed.faa&#X201D; then you can load it with almost exactly the same code:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read(open("PF05371_seed.faa"), "fasta")
print alignment
</PRE><P>All that has changed in this code is the filename and the format string. You&#X2019;ll get the same output as before, the sequences and record identifiers are the same.
However, as you should expect, if you check each <CODE>SeqRecord</CODE> there is no annotation nor database cross-references because these are not included in the FASTA file format.</P><P>Note that rather than using the Sanger website, you could have used <CODE>Bio.AlignIO</CODE> to convert the original Stockholm format file into a FASTA file yourself (see below).</P><P>With any supported file format, you can load an alignment in exactly the same way just by changing the format string. For example, use &#X201C;phylip&#X201D; for PHYLIP files, &#X201C;nexus&#X201D; for NEXUS files or &#X201C;emboss&#X201D; for the alignments output by the EMBOSS tools. There is a full listing on the wiki page (<A HREF="http://biopython.org/wiki/AlignIO"><TT>http://biopython.org/wiki/AlignIO</TT></A>).</P><!--TOC subsection Multiple Alignments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc44">5.1.2</A>&#XA0;&#XA0;Multiple Alignments</H3><!--SEC END --><P>The previous section focused on reading files containing a single alignment. In general however, files can contain more than one alignment, and to read these files we must use the <CODE>Bio.AlignIO.parse()</CODE> function.</P><P>Suppose you have a small alignment in PHYLIP format:</P><PRE CLASS="verbatim">    5    6
Alpha     AACAAC
Beta      AACCCC
Gamma     ACCAAC
Delta     CCACCA
Epsilon   CCAAAC
</PRE><P>If you wanted to bootstrap a phylogenetic tree using the PHYLIP tools, one of the steps would be to create a set of many resampled alignments using the tool <CODE>bootseq</CODE>. This would give output something like this, which has been abbreviated for conciseness:</P><PRE CLASS="verbatim">    5     6
Alpha     AAACCA
Beta      AAACCC
Gamma     ACCCCA
Delta     CCCAAC
Epsilon   CCCAAA
    5     6
Alpha     AAACAA
Beta      AAACCC
Gamma     ACCCAA
Delta     CCCACC
Epsilon   CCCAAA
    5     6
Alpha     AAAAAC
Beta      AAACCC
Gamma     AACAAC
Delta     CCCCCA
Epsilon   CCCAAC
...
    5     6
Alpha     AAAACC
Beta      ACCCCC
Gamma     AAAACC
Delta     CCCCAA
Epsilon   CAAACC
</PRE><P>If you wanted to read this in using <CODE>Bio.AlignIO</CODE> you could use:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignments = AlignIO.parse(open("resampled.phy"), "phylip")
for alignment in alignments :
    print alignment
    print
</PRE><P>This would give the following output, again abbreviated for display:</P><PRE CLASS="verbatim">SingleLetterAlphabet() alignment with 5 rows and 6 columns
AAACCA Alpha
AAACCC Beta
ACCCCA Gamma
CCCAAC Delta
CCCAAA Epsilon

SingleLetterAlphabet() alignment with 5 rows and 6 columns
AAACAA Alpha
AAACCC Beta
ACCCAA Gamma
CCCACC Delta
CCCAAA Epsilon

SingleLetterAlphabet() alignment with 5 rows and 6 columns
AAAAAC Alpha
AAACCC Beta
AACAAC Gamma
CCCCCA Delta
CCCAAC Epsilon

...

SingleLetterAlphabet() alignment with 5 rows and 6 columns
AAAACC Alpha
ACCCCC Beta
AAAACC Gamma
CCCCAA Delta
CAAACC Epsilon
</PRE><P>As with the function <CODE>Bio.SeqIO.parse()</CODE>, using <CODE>Bio.AlignIO.parse()</CODE> returns an iterator.
If you want to keep all the alignments in memory at once, which will allow you to access them in any order, then turn the iterator into a list:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignments = list(AlignIO.parse(open("resampled.phy"), "phylip"))
last_align = alignments[-1]
first_align = alignments[0]
</PRE><!--TOC subsection Ambiguous Alignments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc45">5.1.3</A>&#XA0;&#XA0;Ambiguous Alignments</H3><!--SEC END --><P>
<A NAME="sec:AlignIO-count-argument"></A>
Many alignment file formats can explicitly store more than one alignment, and the division between each alignment is clear. However, when a general sequence file format has been used there is no such block structure. The most common such situation is when alignments have been saved in the FASTA file format. For example consider the following:</P><PRE CLASS="verbatim">&gt;Alpha
ACTACGACTAGCTCAG--G
&gt;Beta
ACTACCGCTAGCTCAGAAG
&gt;Gamma
ACTACGGCTAGCACAGAAG
&gt;Alpha
ACTACGACTAGCTCAGG--
&gt;Beta
ACTACCGCTAGCTCAGAAG
&gt;Gamma
ACTACGGCTAGCACAGAAG
</PRE><P>This could be a single alignment containing six sequences (with repeated identifiers). Or, judging from the identifiers, this is probably two different alignments each with three sequences, which happen to all have the same length.</P><P>What about this next example?</P><PRE CLASS="verbatim">&gt;Alpha
ACTACGACTAGCTCAG--G
&gt;Beta
ACTACCGCTAGCTCAGAAG
&gt;Alpha
ACTACGACTAGCTCAGG--
&gt;Gamma
ACTACGGCTAGCACAGAAG
&gt;Alpha
ACTACGACTAGCTCAGG--
&gt;Delta
ACTACGGCTAGCACAGAAG
</PRE><P>Again, this could be a single alignment with six sequences. However this time based on the identifiers we might guess this is three pairwise alignments which by chance have all got the same lengths.</P><P>This final example is similar:</P><PRE CLASS="verbatim">&gt;Alpha
ACTACGACTAGCTCAG--G
&gt;XXX
ACTACCGCTAGCTCAGAAG
&gt;Alpha
ACTACGACTAGCTCAGG
&gt;YYY
ACTACGGCAAGCACAGG
&gt;Alpha
--ACTACGAC--TAGCTCAGG
&gt;ZZZ
GGACTACGACAATAGCTCAGG
</PRE><P>In this third example, because of the differing lengths, this cannot be treated as a single alignment containing all six records. However, it could be three pairwise alignments.</P><P>Clearly trying to store more than one alignment in a FASTA file is not ideal. However, if you are forced to deal with these as input files <CODE>Bio.AlignIO</CODE> can cope with the most common situation where all the alignments have the same number of records.
One example of this is a collection of pairwise alignments, which can be produced by the EMBOSS tools <CODE>needle</CODE> and <CODE>water</CODE> &#X2013; although in this situation, <CODE>Bio.AlignIO</CODE> should be able to understand their native output using &#X201C;emboss&#X201D; as the format string.</P><P>To interpret these FASTA examples as several separate alignments, we can use <CODE>Bio.AlignIO.parse()</CODE> with the optional <CODE>seq_count</CODE> argument which specifies how many sequences are expected in each alignment (in these examples, 3, 2 and 2 respectively).
For example, using the third example as the input data:</P><PRE CLASS="verbatim">for alignment in AlignIO.parse(handle, "fasta", seq_count=2) :
    print "Alignment length %i" % alignment.get_alignment_length()
    for record in alignment :
        print "%s - %s" % (record.seq, record.id)
    print
</PRE><P>giving:</P><PRE CLASS="verbatim">Alignment length 19
ACTACGACTAGCTCAG--G - Alpha
ACTACCGCTAGCTCAGAAG - XXX

Alignment length 17
ACTACGACTAGCTCAGG - Alpha
ACTACGGCAAGCACAGG - YYY

Alignment length 21
--ACTACGAC--TAGCTCAGG - Alpha
GGACTACGACAATAGCTCAGG - ZZZ
</PRE><P>Using <CODE>Bio.AlignIO.read()</CODE> or <CODE>Bio.AlignIO.parse()</CODE> without the <CODE>seq_count</CODE> argument would give a single alignment containing all six records for the first two examples. For the third example, an exception would be raised because the lengths differ preventing them being turned into a single alignment.</P><P>If the file format itself has a block structure allowing <CODE>Bio.AlignIO</CODE> to determine the number of sequences in each alignment directly, then the <CODE>seq_count</CODE> argument is not needed. If it is supplied, and doesn&#X2019;t agree with the file contents, an error is raised.</P><P>Note that this optional <CODE>seq_count</CODE> argument assumes each alignment in the file has the same number of sequences. Hypothetically you may come across stranger situations, for example a FASTA file containing several alignments each with a different number of sequences &#X2013; although I would love to hear of a real world example of this. Assuming you cannot get the data in a nicer file format, there is no straight forward way to deal with this using <CODE>Bio.AlignIO</CODE>. In this case, you could consider reading in the sequences themselves using <CODE>Bio.SeqIO</CODE> and batching them together to create the alignments as appropriate.</P><!--TOC section Writing Alignments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc46">5.2</A>&#XA0;&#XA0;Writing Alignments</H2><!--SEC END --><P>We&#X2019;ve talked about using <CODE>Bio.AlignIO.read()</CODE> and <CODE>Bio.AlignIO.parse()</CODE> for alignment input (reading files), and now we&#X2019;ll look at <CODE>Bio.AlignIO.write()</CODE> which is for alignment output (writing files). This is a function taking three arguments: some <CODE>Alignment</CODE> objects, a handle to write to, and a sequence format.</P><P>Here is an example, where we start by creating a few <CODE>Alignment</CODE> objects the hard way (by hand, rather than by loading them from a file):</P><PRE CLASS="verbatim">from Bio.Align.Generic import Alignment
from Bio.Alphabet import IUPAC, Gapped
alphabet = Gapped(IUPAC.unambiguous_dna)

align1 = Alignment(alphabet)
align1.add_sequence("Alpha", "ACTGCTAGCTAG")
align1.add_sequence("Beta",  "ACT-CTAGCTAG")
align1.add_sequence("Gamma", "ACTGCTAGDTAG")

align2 = Alignment(alphabet)
align2.add_sequence("Delta",  "GTCAGC-AG")
align2.add_sequence("Epislon","GACAGCTAG")
align2.add_sequence("Zeta",   "GTCAGCTAG")

align3 = Alignment(alphabet)
align3.add_sequence("Eta",   "ACTAGTACAGCTG")
align3.add_sequence("Theta", "ACTAGTACAGCT-")
align3.add_sequence("Iota",  "-CTACTACAGGTG")

my_alignments = [align1, align2, align3]
</PRE><P>Now we have a list of <CODE>Alignment</CODE> objects, we&#X2019;ll write them to a PHYLIP format file:</P><PRE CLASS="verbatim">from Bio import AlignIO
handle = open("my_example.phy", "w")
SeqIO.write(my_alignments, handle, "phylip")
handle.close()
</PRE><P>And if you open this file in your favourite text editor it should look like this:</P><PRE CLASS="verbatim"> 3 12
Alpha      ACTGCTAGCT AG
Beta       ACT-CTAGCT AG
Gamma      ACTGCTAGDT AG
 3 9
Delta      GTCAGC-AG
Epislon    GACAGCTAG
Zeta       GTCAGCTAG
 3 13
Eta        ACTAGTACAG CTG
Theta      ACTAGTACAG CT-
Iota       -CTACTACAG GTG
</PRE><P>Its more common to want to load an existing alignment, and save that, perhaps after some simple manipulation like removing certain rows or columns.</P><!--TOC subsection Converting between sequence alignment file formats-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">5.2.1</A>&#XA0;&#XA0;Converting between sequence alignment file formats</H3><!--SEC END --><P>
<A NAME="sec:converting-alignments"></A></P><P>Converting between sequence alignment file formats with <CODE>Bio.AlignIO</CODE> works in the same way as converting between sequence file formats with <CODE>Bio.SeqIO</CODE> &#X2013; we load generally the alignment(s) using <CODE>Bio.AlignIO.parse()</CODE> and then save them using the <CODE>Bio.AlignIO.write()</CODE>.</P><P>For this example, we&#X2019;ll load the PFAM/Stockholm format file used earlier and save it as a Clustal W format file:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignments = AlignIO.parse(open("PF05371_seed.sth"), "stockholm")
handle = open("PF05371_seed.aln","w")
AlignIO.write(alignments, handle, "clustal")
handle.close()
</PRE><P>The <CODE>Bio.AlignIO.write()</CODE> function expects to be given multiple alignment objects. In the example above we gave it the alignment iterator returned by <CODE>Bio.AlignIO.parse()</CODE>.</P><P>In this case, we know there is only one alignment in the file so we could instead have used <CODE>Bio.AlignIO.read()</CODE> but notice we have to pass this alignment to <CODE>Bio.AlignIO.write()</CODE> as a single element list:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read(open("PF05371_seed.sth"), "stockholm")
handle = open("PF05371_seed.aln","w")
AlignIO.write([alignment], handle, "clustal")
handle.close()
</PRE><P>Either way, you should end up with the same new Clustal W format file &#X201C;PF05371_seed.aln"&#X201D; with the following content:</P><PRE CLASS="verbatim">CLUSTAL X (1.81) multiple sequence alignment


COATB_BPIKE/30-81                   AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSS
Q9T0Q8_BPIKE/1-52                   AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIKLFKKFVS
COATB_BPI22/32-83                   DGTSTATSYATEAMNSLKTQATDLIDQTWPVVTSVAVAGLAIRLFKKFSS
COATB_BPM13/24-72                   AEGDDP---AKAAFNSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTS
COATB_BPZJ2/1-49                    AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFAS
Q9T0Q9_BPFD/1-49                    AEGDDP---AKAAFDSLQASATEYIGYAWAMVVVIVGATIGIKLFKKFTS
COATB_BPIF1/22-73                   FAADDATSQAKAAFDSLTAQATEMSGYAWALVVLVVGATVGIKLFKKFVS

COATB_BPIKE/30-81                   KA
Q9T0Q8_BPIKE/1-52                   RA
COATB_BPI22/32-83                   KA
COATB_BPM13/24-72                   KA
COATB_BPZJ2/1-49                    KA
Q9T0Q9_BPFD/1-49                    KA
COATB_BPIF1/22-73                   RA
</PRE><P>Alternatively, you could make a PHYLIP format file which we&#X2019;ll name &#X201C;PF05371_seed.phy&#X201D;:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read(open("PF05371_seed.sth"), "stockholm")
handle = open("PF05371_seed.phy","w")
AlignIO.write([alignment], handle, "phylip")
handle.close()
</PRE><P>This time the output looks like this:</P><PRE CLASS="verbatim"> 7 52
COATB_BPIK AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIRLFKKFSS
Q9T0Q8_BPI AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIKLFKKFVS
COATB_BPI2 DGTSTATSYA TEAMNSLKTQ ATDLIDQTWP VVTSVAVAGL AIRLFKKFSS
COATB_BPM1 AEGDDP---A KAAFNSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
COATB_BPZJ AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFAS
Q9T0Q9_BPF AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
COATB_BPIF FAADDATSQA KAAFDSLTAQ ATEMSGYAWA LVVLVVGATV GIKLFKKFVS

           KA
           RA
           KA
           KA
           KA
           KA
           RA
</PRE><P>One of the big handicaps of the PHYLIP alignment file format is that the sequence identifiers are strictly truncated at ten characters. In this example, as you can see the resulting names are still unique - but they are not very readable. In this particular case, there is no clear way to compress the identifers, but for the sake of argument you may want to assign your own names or numbering system. This following bit of code manipulates the record identifiers before saving the output:</P><PRE CLASS="verbatim">from Bio import AlignIO
alignment = AlignIO.read(open("PF05371_seed.sth"), "stockholm")
name_mapping = {}
for i, record in enumerate(alignment) :
    name_mapping[i] = record.id
    record.id = "seq%i" % i
print name_mapping

handle = open("PF05371_seed.phy","w")
AlignIO.write([alignment], handle, "phylip")
handle.close()
</PRE><P>This code using a python dictionary to record a simple mapping from the new sequence system to the original identifier:
</P><PRE CLASS="verbatim">{0: 'COATB_BPIKE/30-81', 1: 'Q9T0Q8_BPIKE/1-52', 2: 'COATB_BPI22/32-83', ...}
</PRE><P>Here is the new PHYLIP format output:
</P><PRE CLASS="verbatim"> 7 52
seq0       AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIRLFKKFSS
seq1       AEPNAATNYA TEAMDSLKTQ AIDLISQTWP VVTTVVVAGL VIKLFKKFVS
seq2       DGTSTATSYA TEAMNSLKTQ ATDLIDQTWP VVTSVAVAGL AIRLFKKFSS
seq3       AEGDDP---A KAAFNSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
seq4       AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFAS
seq5       AEGDDP---A KAAFDSLQAS ATEYIGYAWA MVVVIVGATI GIKLFKKFTS
seq6       FAADDATSQA KAAFDSLTAQ ATEMSGYAWA LVVLVVGATV GIKLFKKFVS

           KA
           RA
           KA
           KA
           KA
           KA
           RA
</PRE><P>In general, because of the identifier limitation, working with PHYLIP file formats shouldn&#X2019;t be your first choice. Using the PFAM/Stockholm format on the other hand allows you to record a lot of additional annotation too.</P><!--TOC chapter BLAST-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc48">Chapter&#XA0;6</A>&#XA0;&#XA0;BLAST</H1><!--SEC END --><P>
<A NAME="chapter:blast"></A>
Hey, everybody loves BLAST right? I mean, geez, how can get it get any easier to do comparisons between one of your sequences and every other sequence in the known world? But, of course, this section isn&#X2019;t about how cool BLAST is, since we already know that. It is about the problem with BLAST &#X2013; it can be really difficult to deal with the volume of data generated by large runs, and to automate BLAST runs in general.</P><P>Fortunately, the Biopython folks know this only too well, so they&#X2019;ve developed lots of tools for dealing with BLAST and making things much easier. This section details how to use these tools and do useful things with them.</P><P>Dealing with BLAST can be split up into two steps, both of which can be done from within Biopython.
Firstly, running BLAST for your query sequence(s), and getting some output.
Secondly, parsing the BLAST output in python for further analysis.
We&#X2019;ll start by talking about running the BLAST command line tools locally, and then discuss running BLAST via the web.</P><!--TOC section Running BLAST locally-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">6.1</A>&#XA0;&#XA0;Running BLAST locally</H2><!--SEC END --><P>
<A NAME="sec:running-local-blast"></A></P><P>Running BLAST locally (as opposed to over the internet, see
Section&#XA0;<A HREF="#sec:running-www-blast">6.2</A>) has two advantages:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Local BLAST may be faster than BLAST over the internet;
</LI><LI CLASS="li-itemize">Local BLAST allows you to make your own database to search for sequences against.
</LI></UL><P>
Dealing with proprietary or unpublished sequence data can be another reason to run BLAST locally. You may not be allowed to redistribute the sequences, so submitting them to the NCBI as a BLAST query would not be an option.</P><P>Biopython provides lots of nice code to enable you to call local BLAST executables from your scripts, and have full access to the many command line options that these executables provide. You can obtain local BLAST precompiled for a number of platforms at <A HREF="ftp://ftp.ncbi.nlm.nih.gov/blast/executables/"><TT>ftp://ftp.ncbi.nlm.nih.gov/blast/executables/</TT></A>, or can compile it yourself in the NCBI toolbox (<A HREF="ftp://ftp.ncbi.nlm.nih.gov/toolbox/"><TT>ftp://ftp.ncbi.nlm.nih.gov/toolbox/</TT></A>).</P><P>The code for dealing with local BLAST is found in <CODE>Bio.Blast.NCBIStandalone</CODE>, specifically in the functions <CODE>blastall</CODE>, <CODE>blastpgp</CODE> and <CODE>rpsblast</CODE>, which correspond with the BLAST executables that their names imply.</P><P>Let&#X2019;s use these functions to run a <CODE>blastall</CODE> against a local database and return the results. First, we want to set up the paths to everything that we&#X2019;ll need to do the BLAST. What we need to know is the path to the database (which should have been prepared using <CODE>formatdb</CODE>, see <A HREF="ftp://ftp.ncbi.nlm.nih.gov/blast/documents/formatdb.html"><TT>ftp://ftp.ncbi.nlm.nih.gov/blast/documents/formatdb.html</TT></A>) to search against, the path to the file we want to search, and the path to the <CODE>blastall</CODE> executable.</P><P>On Linux or Mac OS X your paths might look like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_blast_db = "/home/mdehoon/Data/Genomes/Databases/bsubtilis"
# I used formatdb to create a BLAST database named bsubtilis
# (for Bacillus subtilis) consisting of the following three files:
# /home/mdehoon/Data/Genomes/Databases/bsubtilis.nhr
# /home/mdehoon/Data/Genomes/Databases/bsubtilis.nin
# /home/mdehoon/Data/Genomes/Databases/bsubtilis.nsq

&gt;&gt;&gt; my_blast_file = "m_cold.fasta"
# A FASTA file with the sequence I want to BLAST

&gt;&gt;&gt; my_blast_exe = "/usr/local/blast/bin/blastall"
# The name of my BLAST executable
</PRE><P>while on Windows you might have something like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_blast_db = r"C:\Blast\Data\bsubtilis"
# Assuming you used formatdb to create a BLAST database named bsubtilis
# (for Bacillus subtilis) consisting of the following three files:
# C:\Blast\Data\bsubtilis\bsubtilis.nhr
# C:\Blast\Data\bsubtilis\bsubtilis.nin
# C:\Blast\Data\bsubtilis\bsubtilis.nsq
&gt;&gt;&gt; my_blast_file = "m_cold.fasta"
&gt;&gt;&gt; my_blast_exe =r"C:\Blast\bin\blastall.exe"
</PRE><P>The FASTA file used in this example is available
<A HREF="examples/m_cold.fasta">here</A> as well as
<A HREF="http://biopython.org/DIST/docs/tutorial/examples/m_cold.fasta">online</A>.</P><P>Now that we&#X2019;ve got that all set, we are ready to run the BLAST and collect the results. We can do this with two lines:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; result_handle, error_handle = NCBIStandalone.blastall(my_blast_exe, "blastn",
                                                    my_blast_db, my_blast_file)
</PRE><P>Note that the Biopython interfaces to local blast programs returns two values. The first is a handle to the blast output, which is ready to either be saved or passed to a parser. The second is the possible error output generated by the blast command. See Section&#XA0;<A HREF="#sec:appendix-handles">12.1</A> for more about handles.</P><P>The error info can be hard to deal with, because if you try to do a <CODE>error_handle.read()</CODE> and there was no error info returned, then the <CODE>read()</CODE> call will block and not return, locking your script. In my opinion, the best way to deal with the error is only to print it out if you are not getting <CODE>result_handle</CODE> results to be parsed, but otherwise to leave it alone.</P><P>This command will generate BLAST output in XML format, as that is the format expected by the XML parser, described in Section&#XA0;<A HREF="#sec:parsing-blast">6.4</A>. For plain text output, use the <CODE>align_view='0'</CODE> keyword. To parse text output instead of XML output, see the Section&#XA0;<A HREF="#sec:parsing-blast-deprecated">6.6</A> below. However, parsing text output is not recommended, as the BLAST plain text output changes frequently, breaking our parsers.</P><P>If you are interested in saving your results to a file before parsing them,
see Section&#XA0;<A HREF="#sec:saving-blast-output">6.3</A>. To find out how to parse the BLAST
results, go to Section&#XA0;<A HREF="#sec:parsing-blast">6.4</A></P><!--TOC section Running BLAST over the Internet-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc50">6.2</A>&#XA0;&#XA0;Running BLAST over the Internet</H2><!--SEC END --><P>
<A NAME="sec:running-www-blast"></A></P><P>The first step in automating BLASTing is to make everything accessible
from Python scripts. So, Biopython contains code that allows you to
run the WWW version of BLAST (<A HREF="http://www.ncbi.nlm.nih.gov/BLAST/"><TT>http://www.ncbi.nlm.nih.gov/BLAST/</TT></A>)
directly from your Python scripts. This is very nice, especially since
otherwise BLAST can be a real pain to deal with from scripts, especially
with the whole BLAST queue thing and the separate results page.</P><P>The code to deal with the WWW version of BLAST is found in the
<CODE>Bio.Blast.NCBIWWW</CODE> module, and the <CODE>qblast</CODE> function. Let&#X2019;s
say we want to BLAST info we have in a FASTA formatted file against
the database. First, we need to get the info in the FASTA file.</P><P>The easiest way to do this is to use the <CODE>Bio.SeqIO</CODE> module (see
Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>). In this example we&#X2019;ll use the
<CODE>Bio.SeqIO.read</CODE> function to turn a FASTA file containing a single
entry into a SeqRecord object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read(open("m_cold.fasta"), format="fasta")
</PRE><P>Now we can take the sequence as a plain string from the SeqRecord
and run BLAST on it. The code to do the simplest possible BLAST
(a simple blastn of the FASTA file against all of the non-redundant
databases) is:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nr", record.seq.tostring())
</PRE><P>The first three arguments to our <CODE>NCBIWWW.qblast</CODE> function are non-optional:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The first argument is the blast program to use for the search, as a
lower case string. The options and descriptions of the programs are
available at <A HREF="http://www.ncbi.nlm.nih.gov/BLAST/blast_program.html"><TT>http://www.ncbi.nlm.nih.gov/BLAST/blast_program.html</TT></A>.
Currently <CODE>qblast</CODE> only works with blastn, blastp, blastx, tblast
and tblastx.
</LI><LI CLASS="li-itemize">The second argument specifies the databases to search against. Again,
the options for this are available on the NCBI web pages at
<A HREF="http://www.ncbi.nlm.nih.gov/BLAST/blast_databases.html"><TT>http://www.ncbi.nlm.nih.gov/BLAST/blast_databases.html</TT></A>.
</LI><LI CLASS="li-itemize">The third argument is a string containing your query sequence. This
can either be the sequence itself (as above), the sequence in fasta format,
or an identifier like a GI number.
</LI></UL><P>The <CODE>qblast</CODE> function also take a number of other option arguments
which are basically analogous to the different parameters you can set
on the BLAST web page. We&#X2019;ll just highlight a few of them here:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The <CODE>qblast</CODE> function can return the BLAST results in various
formats, which you can choose with the optional <CODE>format_type</CODE> keyword:
<CODE>"HTML"</CODE>, <CODE>"Text"</CODE>, <CODE>"ASN.1"</CODE>, or <CODE>"XML"</CODE>.
The default is <CODE>"XML"</CODE>, as that is the format expected by the parser,
described in section&#XA0;<A HREF="#sec:parsing-blast">6.4</A> below.
</LI><LI CLASS="li-itemize">The argument <CODE>expect</CODE> sets the expectation or e-value threshold.
</LI></UL><P>For more about the optional BLAST arguments, we refer you to the NCBI&#X2019;s own
documentation, or that built into Biopython:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; help(NCBIWWW.qblast)
</PRE><P>After you have set the search options, you are all ready to BLAST.
Biopython takes care of worrying about when the results are available,
and will pause until it can get the results and return them.</P><!--TOC section Saving BLAST output-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">6.3</A>&#XA0;&#XA0;Saving BLAST output</H2><!--SEC END --><P>
<A NAME="sec:saving-blast-output"></A></P><P>Before parsing the results, it is often useful to save them into a
file so that you can use them later without having to go back and
re-blast everything. I find this especially useful when debugging my
code that extracts info from the BLAST files, but it could also be
useful just for making backups of things you&#X2019;ve done.</P><P>If you don&#X2019;t want to save the BLAST output, you can skip to
section&#XA0;<A HREF="#sec:parsing-blast">6.4</A>. If you do, read on.</P><P>We need to be a bit careful since we can use <CODE>result_handle.read()</CODE> to
read the BLAST output only once &#X2013; calling <CODE>result_handle.read()</CODE> again
returns an empty string. First, we use <CODE>read()</CODE> and store all of
the information from the handle into a string:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_results = result_handle.read()
</PRE><P>Next, we save this string in a file:</P><PRE CLASS="verbatim">&gt;&gt;&gt; save_file = open("my_blast.xml", "w")
&gt;&gt;&gt; save_file.write(blast_results)
&gt;&gt;&gt; save_file.close()
</PRE><P>After doing this, the results are in the file <CODE>my_blast.xml</CODE> and the
variable <CODE>blast_results</CODE> contains the BLAST results in a string
form. However, the <CODE>parse</CODE> function of the BLAST parser (described
in&#XA0;<A HREF="#sec:parsing-blast">6.4</A>) takes a file-handle-like object, not a
plain string. To get a handle, there are two things you can do:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Use the Python standard library module <CODE>cStringIO</CODE>. The
following code will turn the plain string into a handle, which we can
feed directly into the BLAST parser:
<PRE CLASS="verbatim">&gt;&gt;&gt; import cStringIO
&gt;&gt;&gt; result_handle = cStringIO.StringIO(blast_results)
</PRE></LI><LI CLASS="li-itemize">Open the saved file for reading. Duh.
<PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_blast.xml")
</PRE></LI></UL><P>Now that we&#X2019;ve got the BLAST results, we are ready to do
something with them, so this leads us right into the parsing section.</P><!--TOC section Parsing BLAST output-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc52">6.4</A>&#XA0;&#XA0;Parsing BLAST output</H2><!--SEC END --><P>
<A NAME="sec:parsing-blast"></A></P><P>As mentioned above, BLAST can generate output in various formats,
such as XML, HTML, and plain text. Originally, Biopython had a parser for
BLAST plain text and HTML output, as these were the only output formats supported
by BLAST. Unfortunately, the BLAST output in these formats kept changing,
each time breaking the Biopython parsers. As keeping up with changes in BLAST
became a hopeless endeavor, especially with users running different BLAST
versions, we now recommend to parse the output in XML format, which can be
generated by recent versions of BLAST. Not only is the XML output more stable
than the plain text and HTML output, it is also much easier to parse
automatically, making Biopython a whole lot more stable.</P><P>Though deprecated, the parsers for BLAST output in plain text or HTML output
are still available in Biopython
(see Section&#XA0;<A HREF="#sec:parsing-blast-deprecated">6.6</A>).
Use them at your own risk: they may or may not work, depending on which BLAST
version you&#X2019;re using.</P><P>You can get BLAST output in XML format in various ways. For the parser, it
doesn&#X2019;t matter how the output was generated, as long as it is in the XML format.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
You can use Biopython to run BLAST locally, as described in
section&#XA0;<A HREF="#sec:running-local-blast">6.1</A>.
</LI><LI CLASS="li-itemize">You can use Biopython to run BLAST over the internet, as described in
section&#XA0;<A HREF="#sec:running-www-blast">6.2</A>.
</LI><LI CLASS="li-itemize">You can do the BLAST seach yourself on the NCBI site through your
web browser, and then save the results. You need to choose XML as the format
in which to receive the results, and save the final BLAST page you get
(you know, the one with all of the interesting results!) to a file.
</LI><LI CLASS="li-itemize">You can also run BLAST locally without using Biopython, and save
the output in a file. Again, you need to choose XML as the format in which
to receive the results.
</LI></UL><P>
The important point is that you do not have to use Biopython
scripts to fetch the data in order to be able to parse it.</P><P>Doing things in one of these ways, you then need to get a handle
to the results. In Python, a handle is just a nice general way of
describing input to any info source so that the info can be retrieved
using <CODE>read()</CODE> and <CODE>readline()</CODE> functions. This is the type
of input the BLAST parser (and most other Biopython parsers) take.</P><P>If you followed the code above for interacting with BLAST through a
script, then you already have <CODE>result_handle</CODE>, the handle to the
BLAST results. For example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read(open("m_cold.fasta"), format="fasta")
&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nr", record.seq.tostring())
</PRE><P>If instead you ran BLAST some other way, and have the
BLAST output (in XML format) in the file <CODE>my_blast.xml</CODE>, all you
need to do is to open the file for reading:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_blast.xml")
</PRE><P>Now that we&#X2019;ve got a handle, we are ready to parse the output. The
code to parse it is really quite small:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIXML
&gt;&gt;&gt; blast_records = NCBIXML.parse(result_handle)
</PRE><P>To understand what <CODE>NCBIXML.parse</CODE> returns, there are two things
that you need to keep in mind:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The BLAST output may contain the output of more than
one BLAST search. This will for example be the case if you ran BLAST locally
on a Fasta file containing more than one sequence. For each sequence, the
BLAST parser will return one BLAST record.
</LI><LI CLASS="li-itemize">The BLAST output may therefore be huge.
</LI></UL><P>To be able to handle these situations, <CODE>NCBIXML.parse</CODE> returns an
iterator (just like <CODE>Bio.SeqIO.parse</CODE>). In plain English, an iterator
allows you to step through the BLAST output, retrieving BLAST records one
by one for each BLAST search:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
# No further records
</PRE><P>Or, you can use a <CODE>for</CODE>-loop:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for blast_record in blast_records:
...     # Do something with blast_record
</PRE><P>Note though that you can step through the BLAST records only once.
Usually, from each BLAST record you would save the information that
you are interested in. If you want to save all returned BLAST records,
you can convert the iterator into a list:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_records = list(blast_records)
</PRE><P>Now you can access each BLAST record in the list with an index as usual.
If your BLAST file is huge though, you may run into problems trying to
save them all in a list.</P><P>Usually, you&#X2019;ll be running one BLAST search at a time. Then, all you need
to do is to pick up the first (and only) BLAST record in <CODE>blast_records</CODE>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_record = blast_records.next()
</PRE><P>I guess by now you&#X2019;re wondering what is in a BLAST record.</P><!--TOC section The BLAST record class-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc53">6.5</A>&#XA0;&#XA0;The BLAST record class</H2><!--SEC END --><P>A BLAST Record contains everything you might ever want to extract from the
BLAST output. Right now we&#X2019;ll just show
an example of how to get some info out of the BLAST report, but if you
want something in particular that is not described here, look at the
info on the record class in detail, and take a gander into the code or
automatically generated documentation &#X2013; the docstrings have lots of
good info about what is stored in each piece of information.</P><P>To continue with our example, let&#X2019;s just print out some summary info
about all hits in our blast report greater than a particular
threshold. The following code does this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; E_VALUE_THRESH = 0.04

&gt;&gt;&gt; for alignment in blast_record.alignments:
...     for hsp in alignment.hsps:
...         if hsp.expect &lt; E_VALUE_THRESH:
...             print '****Alignment****'
...             print 'sequence:', alignment.title
...             print 'length:', alignment.length
...             print 'e value:', hsp.expect
...             print hsp.query[0:75] + '...'
...             print hsp.match[0:75] + '...'
...             print hsp.sbjct[0:75] + '...'
</PRE><P>This will print out summary reports like the following:</P><PRE CLASS="verbatim">****Alignment****
sequence: &gt;gb|AF283004.1|AF283004 Arabidopsis thaliana cold acclimation protein WCOR413-like protein
alpha form mRNA, complete cds
length: 783
e value: 0.034
tacttgttgatattggatcgaacaaactggagaaccaacatgctcacgtcacttttagtcccttacatattcctc...
||||||||| | ||||||||||| || ||||  || || |||||||| |||||| |  | |||||||| ||| ||...
tacttgttggtgttggatcgaaccaattggaagacgaatatgctcacatcacttctcattccttacatcttcttc...
</PRE><P>Basically, you can do anything you want to with the info in the BLAST
report once you have parsed it. This will, of course, depend on what
you want to use it for, but hopefully this helps you get started on
doing what you need to do!</P><P>An important consideration for extracting information from a BLAST report is the type of objects that the information is stored in. In Biopython, the parsers return <CODE>Record</CODE> objects, either <CODE>Blast</CODE> or <CODE>PSIBlast</CODE> depending on what you are parsing. These objects are defined in <CODE>Bio.Blast.Record</CODE> and are quite complete.</P><P>Here are my attempts at UML class diagrams for the <CODE>Blast</CODE> and <CODE>PSIBlast</CODE> record classes. If you are good at UML and see mistakes/improvements that can be made, please let me know. The Blast class diagram is shown in Figure&#XA0;<A HREF="#fig:blastrecord">6.5</A>.</P><P>
<A NAME="fig:blastrecord"></A>
<IMG SRC="images/BlastRecord.png" width=650, height=750>
</P><P>The PSIBlast record object is similar, but has support for the rounds that are used in the iteration steps of PSIBlast. The class diagram for PSIBlast is shown in Figure&#XA0;<A HREF="#fig:psiblastrecord">6.5</A>.</P><P>
<A NAME="fig:psiblastrecord"></A>
<IMG SRC="images/PSIBlastRecord.png" width=650, height=750>
</P><!--TOC section Deprecated BLAST parsers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc54">6.6</A>&#XA0;&#XA0;Deprecated BLAST parsers</H2><!--SEC END --><P>
<A NAME="sec:parsing-blast-deprecated"></A></P><P>Older versions of Biopython had parsers for BLAST output in plain text or HTML
format. Over the years, we discovered that it is very hard to maintain these
parsers in working order. Basically, any small change to the BLAST output in
newly released BLAST versions tends to cause the plain text and HTML parsers
to break. We therefore recommend parsing BLAST output in XML format, as
described in section&#XA0;<A HREF="#sec:parsing-blast">6.4</A>.
Whereas the plain text and HTML parsers are still available in
Biopython, use them at your own risk. They may or may not work, depending on
which BLAST versions you&#X2019;re using.</P><!--TOC subsection Parsing plain-text BLAST output-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">6.6.1</A>&#XA0;&#XA0;Parsing plain-text BLAST output</H3><!--SEC END --><P>The plain text BLAST parser is located in <CODE>Bio.Blast.NCBIStandalone</CODE>.</P><P>As with the XML parser, we need to have a handle object that we can pass to the parser. The handle must implement the <CODE>readline()</CODE> method and do this properly. The common ways to get such a handle are to either use the provided <CODE>blastall</CODE> or <CODE>blastpgp</CODE> functions to run the local blast, or to run a local blast via the command line, and then do something like the following:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_file_of_blast_output.txt")
</PRE><P>Well, now that we&#X2019;ve got a handle (which we&#X2019;ll call <CODE>result_handle</CODE>),
we are ready to parse it. This can be done with the following code:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; blast_parser = NCBIStandalone.BlastParser()
&gt;&gt;&gt; blast_record = blast_parser.parse(result_handle)
</PRE><P>This will parse the BLAST report into a Blast Record class (either a Blast or a PSIBlast record, depending on what you are parsing) so that you can extract the information from it. In our case, let&#X2019;s just use print out a quick summary of all of the alignments greater than some threshold value.</P><PRE CLASS="verbatim">&gt;&gt;&gt; E_VALUE_THRESH = 0.04
&gt;&gt;&gt; for alignment in b_record.alignments:
...     for hsp in alignment.hsps:
...         if hsp.expect &lt; E_VALUE_THRESH:
...             print '****Alignment****'
...             print 'sequence:', alignment.title
...             print 'length:', alignment.length
...             print 'e value:', hsp.expect
...             print hsp.query[0:75] + '...'
...             print hsp.match[0:75] + '...'
...             print hsp.sbjct[0:75] + '...'
</PRE><P>If you also read the section&#XA0;<A HREF="#sec:parsing-blast">6.4</A> on parsing BLAST XML output, you&#X2019;ll notice that the above code is identical to what is found in that section. Once you parse something into a record class you can deal with it independent of the format of the original BLAST info you were parsing. Pretty snazzy!</P><P>Sure, parsing one record is great, but I&#X2019;ve got a BLAST file with tons of records &#X2013; how can I parse them all? Well, fear not, the answer lies in the very next section.</P><!--TOC subsection Parsing a file full of BLAST runs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc56">6.6.2</A>&#XA0;&#XA0;Parsing a file full of BLAST runs</H3><!--SEC END --><P>Of course, local blast is cool because you can run a whole bunch of sequences against a database and get back a nice report on all of it. So, Biopython definitely has facilities to make it easy to parse humongous files without memory problems.</P><P>We can do this using the blast iterator. To set up an iterator, we first set up a parser, to parse our blast reports in Blast Record objects:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; blast_parser = NCBIStandalone.BlastParser()
</PRE><P>Then we will assume we have a handle to a bunch of blast records, which we&#X2019;ll call <CODE>result_handle</CODE>. Getting a handle is described in full detail above in the blast parsing sections.</P><P>Now that we&#X2019;ve got a parser and a handle, we are ready to set up the iterator with the following command:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_iterator = NCBIStandalone.Iterator(blast_handle, blast_parser)
</PRE><P>The second option, the parser, is optional. If we don&#X2019;t supply a parser, then the iterator will just return the raw BLAST reports one at a time.</P><P>Now that we&#X2019;ve got an iterator, we start retrieving blast records (generated by our parser) using <CODE>next()</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_record = blast_iterator.next()
</PRE><P>Each call to next will return a new record that we can deal with. Now we can iterate through this records and generate our old favorite, a nice little blast report:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for b_record in b_iterator :
...     E_VALUE_THRESH = 0.04
...     for alignment in b_record.alignments:
...         for hsp in alignment.hsps:
...             if hsp.expect &lt; E_VALUE_THRESH:
...                 print '****Alignment****'
...                 print 'sequence:', alignment.title
...                 print 'length:', alignment.length
...                 print 'e value:', hsp.expect
...                 if len(hsp.query) &gt; 75:
...                     dots = '...'
...                 else:
...                     dots = ''
...                 print hsp.query[0:75] + dots
...                 print hsp.match[0:75] + dots
...                 print hsp.sbjct[0:75] + dots
</PRE><P>The iterator allows you to deal with huge blast records without any memory problems, since things are read in one at a time. I have parsed tremendously huge files without any problems using this.</P><!--TOC subsection Finding a bad record somewhere in a huge file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc57">6.6.3</A>&#XA0;&#XA0;Finding a bad record somewhere in a huge file</H3><!--SEC END --><P>One really ugly problem that happens to me is that I&#X2019;ll be parsing a huge blast file for a while, and the parser will bomb out with a ValueError. This is a serious problem, since you can&#X2019;t tell if the ValueError is due to a parser problem, or a problem with the BLAST. To make it even worse, you have no idea where the parse failed, so you can&#X2019;t just ignore the error, since this could be ignoring an important data point.</P><P>We used to have to make a little script to get around this problem, but the <CODE>Bio.Blast</CODE> module now includes a <CODE>BlastErrorParser</CODE> which really helps make this easier. The <CODE>BlastErrorParser</CODE> works very similar to the regular <CODE>BlastParser</CODE>, but it adds an extra layer of work by catching ValueErrors that are generated by the parser, and attempting to diagnose the errors.</P><P>Let&#X2019;s take a look at using this parser &#X2013; first we define the file we are going to parse and the file to write the problem reports to:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import os
&gt;&gt;&gt; blast_file = os.path.join(os.getcwd(), "blast_out", "big_blast.out")
&gt;&gt;&gt; error_file = os.path.join(os.getcwd(), "blast_out", "big_blast.problems")
</PRE><P>Now we want to get a <CODE>BlastErrorParser</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; error_handle = open(error_file, "w")
&gt;&gt;&gt; blast_error_parser = NCBIStandalone.BlastErrorParser(error_handle)
</PRE><P>Notice that the parser take an optional argument of a handle. If a handle is passed, then the parser will write any blast records which generate a ValueError to this handle. Otherwise, these records will not be recorded.</P><P>Now we can use the <CODE>BlastErrorParser</CODE> just like a regular blast parser. Specifically, we might want to make an iterator that goes through our blast records one at a time and parses them with the error parser:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open(blast_file)
&gt;&gt;&gt; iterator = NCBIStandalone.Iterator(result_handle, blast_error_parser)
</PRE><P>We can read these records one a time, but now we can catch and deal with errors that are due to problems with Blast (and not with the parser itself):</P><PRE CLASS="verbatim">&gt;&gt;&gt; try:
...     next_record = iterator.next()
... except NCBIStandalone.LowQualityBlastError, info:
...     print "LowQualityBlastError detected in id %s" % info[1]
</PRE><P>The <CODE>.next()</CODE> method is normally called indirectly via a <CODE>for</CODE>-loop.
Right now the <CODE>BlastErrorParser</CODE> can generate the following errors:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>ValueError</CODE> &#X2013; This is the same error generated by the regular BlastParser, and is due to the parser not being able to parse a specific file. This is normally either due to a bug in the parser, or some kind of discrepancy between the version of BLAST you are using and the versions the parser is able to handle.</LI><LI CLASS="li-itemize"><CODE>LowQualityBlastError</CODE> &#X2013; When BLASTing a sequence that is of really bad quality (for example, a short sequence that is basically a stretch of one nucleotide), it seems that Blast ends up masking out the entire sequence and ending up with nothing to parse. In this case it will produce a truncated report that causes the parser to generate a ValueError. <CODE>LowQualityBlastError</CODE> is reported in these cases. This error returns an info item with the following information:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>item[0]</CODE> &#X2013; The error message
</LI><LI CLASS="li-itemize"><CODE>item[1]</CODE> &#X2013; The id of the input record that caused the error. This is really useful if you want to record all of the records that are causing problems.
</LI></UL>
</LI></UL><P>As mentioned, with each error generated, the BlastErrorParser will write the offending record to the specified <CODE>error_handle</CODE>. You can then go ahead and look and these and deal with them as you see fit. Either you will be able to debug the parser with a single blast report, or will find out problems in your blast runs. Either way, it will definitely be a useful experience!</P><P>Hopefully the <CODE>BlastErrorParser</CODE> will make it much easier to debug and deal with large Blast files.</P><!--TOC section Dealing with PSIBlast-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc58">6.7</A>&#XA0;&#XA0;Dealing with PSIBlast</H2><!--SEC END --><P>We should write some stuff to make it easier to deal directly with PSIBlast from scripts (i.&#XA0;e.&#XA0;output the align file in the proper format from an alignment). I need to look at PSIBlast more and come up with some good ways of going this...</P><!--TOC chapter Accessing NCBI&#X2019;s Entrez databases-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc59">Chapter&#XA0;7</A>&#XA0;&#XA0;Accessing NCBI&#X2019;s Entrez databases</H1><!--SEC END --><P>
<A NAME="chapter:entrez"></A></P><P>Entrez (<A HREF="http://www.ncbi.nlm.nih.gov/Entrez"><TT>http://www.ncbi.nlm.nih.gov/Entrez</TT></A>) is a data retrieval system that provides users access to NCBI&#X2019;s databases such as PubMed, GenBank, GEO, and many others. You can access Entrez from a web browser to manually enter queries, or you can use Biopython&#X2019;s <CODE>Bio.Entrez</CODE> module for programmatic access to Entrez. The latter allows you for example to search PubMed or download GenBank records from within a Python script.</P><P>The <CODE>Bio.Entrez</CODE> module makes use of the Entrez Programming Utilities, consisting of eight tools that are described in detail on NCBI&#X2019;s page at <A HREF="http://www.ncbi.nlm.nih.gov/entrez/utils/"><TT>http://www.ncbi.nlm.nih.gov/entrez/utils/</TT></A>. Each of these tools corresponds to one Python function in the <CODE>Bio.Entrez</CODE> module, as described in the sections below. This module makes sure that the correct URL is used for the queries, and that not more than one request is made every three seconds, as required by NCBI.</P><P>The output returned by the Entrez Programming Utilities is typically in XML format. To parse such output, you have several options:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Use <CODE>Bio.Entrez</CODE>&#X2019;s parser to parse the XML output into a Python object;
</LI><LI CLASS="li-enumerate">Use the DOM (Document Object Model) parser in Python&#X2019;s standard library;
</LI><LI CLASS="li-enumerate">Use the SAX (Simple API for XML) parser in Python&#X2019;s standard library;
</LI><LI CLASS="li-enumerate">Read the XML output as raw text, and parse it by string searching and manipulation.
</LI></OL><P>
For the DOM and SAX parsers, see the Python documentation. The parser in <CODE>Bio.Entrez</CODE> is discussed below.</P><P>For sequence databases, the Entrez Programming Utilities can also generate output in other formats (such as the Fasta and GenBank file format). This can then be parsed into a SeqRecord using <CODE>Bio.SeqIO</CODE> (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>, and the example below).</P><!--TOC section Entrez Guidelines-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc60">7.1</A>&#XA0;&#XA0;Entrez Guidelines</H2><!--SEC END --><P>
<A NAME="sec:entrez-guidelines"></A>
Before using Biopython to access the NCBI&#X2019;s online resources (via <CODE>Bio.Entrez</CODE> or some of the other modules), please read the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/eutils_help.html#UserSystemRequirements">NCBI&#X2019;s Entrez User Requirements</A>. If the NCBI finds you are abusing their systems, they can and will ban your access! </P><P>To paraphrase:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
For any series of more than 100 requests, do this at weekends or outside USA peak times. This is up to you to obey.
</LI><LI CLASS="li-itemize">Use the <A HREF="http://eutils.ncbi.nlm.nih.gov"><TT>http://eutils.ncbi.nlm.nih.gov</TT></A> address, not the standard NCBI Web address. Biopython uses this web address.
</LI><LI CLASS="li-itemize">Make no more than one request every 3 seconds. This is automatically enforced by Biopython.
</LI><LI CLASS="li-itemize">Use the optional email parameter so the NCBI can contact you if there is a problem. In the examples below, we have used <TT>email="A.N.Other@example.com"</TT> for illustrative purposes. The <TT>example.com</TT> address is a reserved domain name specifically for documentation (RFC 2606). Please DO NOT use a random email &#X2013; it&#X2019;s better not to give an email at all.
</LI><LI CLASS="li-itemize">If you are using Biopython within some larger software suite, use the tool parameter to specify this. The tool parameter will default to Biopython.
</LI></UL><P>For large queries, the NCBI also recommend using their session history feature (the WebEnv session cookie string). This is only slightly more complicated.</P><P>In conclusion, be sensible with your usage levels. If you plan to download lots of data, consider other options. For example, if you want easy access to all the human genes, consider fetching each chromosome by FTP as a GenBank file, and importing these into your own BioSQL database (see Section&#XA0;<A HREF="#sec:BioSQL">9.5</A>).</P><!--TOC section EInfo: Obtaining information about the Entrez databases-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc61">7.2</A>&#XA0;&#XA0;EInfo: Obtaining information about the Entrez databases</H2><!--SEC END --><P>EInfo provides field index term counts, last update, and available links for each of NCBI&#X2019;s databases. In addition, you can use EInfo to obtain a list of all database names accessible through the Entrez utilities:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.einfo(email="A.N.Other@example.com")
&gt;&gt;&gt; result = handle.read()
</PRE><P>The variable <CODE>result</CODE> now contains a list of databases in XML format:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print result
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE eInfoResult PUBLIC "-//NLM//DTD eInfoResult, 11 May 2002//EN"
 "http://www.ncbi.nlm.nih.gov/entrez/query/DTD/eInfo_020511.dtd"&gt;
&lt;eInfoResult&gt;
&lt;DbList&gt;
        &lt;DbName&gt;pubmed&lt;/DbName&gt;
        &lt;DbName&gt;protein&lt;/DbName&gt;
        &lt;DbName&gt;nucleotide&lt;/DbName&gt;
        &lt;DbName&gt;nuccore&lt;/DbName&gt;
        &lt;DbName&gt;nucgss&lt;/DbName&gt;
        &lt;DbName&gt;nucest&lt;/DbName&gt;
        &lt;DbName&gt;structure&lt;/DbName&gt;
        &lt;DbName&gt;genome&lt;/DbName&gt;
        &lt;DbName&gt;books&lt;/DbName&gt;
        &lt;DbName&gt;cancerchromosomes&lt;/DbName&gt;
        &lt;DbName&gt;cdd&lt;/DbName&gt;
        &lt;DbName&gt;gap&lt;/DbName&gt;
        &lt;DbName&gt;domains&lt;/DbName&gt;
        &lt;DbName&gt;gene&lt;/DbName&gt;
        &lt;DbName&gt;genomeprj&lt;/DbName&gt;
        &lt;DbName&gt;gensat&lt;/DbName&gt;
        &lt;DbName&gt;geo&lt;/DbName&gt;
        &lt;DbName&gt;gds&lt;/DbName&gt;
        &lt;DbName&gt;homologene&lt;/DbName&gt;
        &lt;DbName&gt;journals&lt;/DbName&gt;
        &lt;DbName&gt;mesh&lt;/DbName&gt;
        &lt;DbName&gt;ncbisearch&lt;/DbName&gt;
        &lt;DbName&gt;nlmcatalog&lt;/DbName&gt;
        &lt;DbName&gt;omia&lt;/DbName&gt;
        &lt;DbName&gt;omim&lt;/DbName&gt;
        &lt;DbName&gt;pmc&lt;/DbName&gt;
        &lt;DbName&gt;popset&lt;/DbName&gt;
        &lt;DbName&gt;probe&lt;/DbName&gt;
        &lt;DbName&gt;proteinclusters&lt;/DbName&gt;
        &lt;DbName&gt;pcassay&lt;/DbName&gt;
        &lt;DbName&gt;pccompound&lt;/DbName&gt;
        &lt;DbName&gt;pcsubstance&lt;/DbName&gt;
        &lt;DbName&gt;snp&lt;/DbName&gt;
        &lt;DbName&gt;taxonomy&lt;/DbName&gt;
        &lt;DbName&gt;toolkit&lt;/DbName&gt;
        &lt;DbName&gt;unigene&lt;/DbName&gt;
        &lt;DbName&gt;unists&lt;/DbName&gt;
&lt;/DbList&gt;
&lt;/eInfoResult&gt;
</PRE><P>Since this is a fairly simple XML file, we could extract the information it contains simply by string searching. Using <CODE>Bio.Entrez</CODE>&#X2019;s parser instead, we can directly parse this XML file into a Python object:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.einfo(email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
</PRE><P>Now <CODE>record</CODE> is a dictionary with exactly one key:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; record.keys()
[u'DbList']
</PRE><P>The values stored in this key is the list of database names shown in the XML above:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; record["DbList"]
['pubmed', 'protein', 'nucleotide', 'nuccore', 'nucgss', 'nucest',
 'structure', 'genome', 'books', 'cancerchromosomes', 'cdd', 'gap',
 'domains', 'gene', 'genomeprj', 'gensat', 'geo', 'gds', 'homologene',
 'journals', 'mesh', 'ncbisearch', 'nlmcatalog', 'omia', 'omim', 'pmc',
 'popset', 'probe', 'proteinclusters', 'pcassay', 'pccompound',
 'pcsubstance', 'snp', 'taxonomy', 'toolkit', 'unigene', 'unists']
</PRE><P>For each of these databases, we can use EInfo again to obtain more information:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.einfo(db="pubmed", email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["DbInfo"]["Description"]
'PubMed bibliographic record'
&gt;&gt;&gt; record["DbInfo"]["Count"]
'17989604'
&gt;&gt;&gt; record["DbInfo"]["LastUpdate"]
'2008/05/24 06:45'
</PRE><P>Try <CODE>record["DbInfo"].keys()</CODE> for other information stored in this record.</P><!--TOC section ESearch: Searching the Entrez databases-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc62">7.3</A>&#XA0;&#XA0;ESearch: Searching the Entrez databases</H2><!--SEC END --><P>
<A NAME="sec:entrez-esearch"></A>
To search any of these databases, we use <CODE>Bio.Entrez.esearch()</CODE>. For example, let&#X2019;s search in PubMed for publications related to Biopython:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.esearch(db="pubmed", term="biopython", email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["IdList"]
['16403221', '16377612', '14871861', '14630660', '12230038']
</PRE><P>In this output, you see five PubMed IDs (16403221, 16377612, 14871861, 14630660, 12230038), which can be retrieved by EFetch (see section <A HREF="#sec:efetch">7.6</A>).</P><P>You can also use ESearch to search GenBank. Here we&#X2019;ll do a quick search for the <EM>rpl16</EM> gene in <EM>Opuntia</EM>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.esearch(db="nucleotide",term="Opuntia and rpl16",
                            email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["Count"]
'9'
&gt;&gt;&gt; record["IdList"]
['57240072', '57240071', '6273287', '6273291', '6273290',
 '6273289', '6273286', '6273285', '6273284']
</PRE><P>Each of the IDs (57240072, 57240071, 6273287...) is a GenBank identifier. See section&#XA0;<A HREF="#sec:efetch">7.6</A> for information on how to actually download these GenBank records.</P><P>As a final example, let&#X2019;s get a list of computational journal titles:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.esearch(db="journals", term="computational",
                            email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["Count"]
'16'
&gt;&gt;&gt; record["IdList"]
['30367', '33843', '33823', '32989', '33190', '33009', '31986',
 '34502', '8799', '22857', '32675', '20258', '33859', '32534',
 '32357', '32249']
</PRE><P>Again, we could use EFetch to obtain more information for each of these journal IDs.</P><P>ESearch has many useful options &#X2014; see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/esearch_help.html">ESearch help page</A> for more information.</P><!--TOC section EPost-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc63">7.4</A>&#XA0;&#XA0;EPost</H2><!--SEC END --><P>
EPost posts a list of UIs for use in subsequent search strategies; see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/epost_help.html">EPost help page</A> for more information. It is available from Biopython through <CODE>Bio.Entrez.epost()</CODE>.</P><!--TOC section ESummary: Retrieving summaries from primary IDs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc64">7.5</A>&#XA0;&#XA0;ESummary: Retrieving summaries from primary IDs</H2><!--SEC END --><P>
ESummary retrieves document summaries from a list of primary IDs (see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/esummary_help.html">ESummary help page</A> for more information). In Biopython, ESummary is available as <CODE>Bio.Entrez.esummary()</CODE>. Using the search result above, we can for example find out more about the journal with ID 30367:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.esummary(db="journals", id="30367", email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record[0]["Id"]
'30367'
&gt;&gt;&gt; record[0]["Title"]
'Computational biology and chemistry'
&gt;&gt;&gt; record[0]["Publisher"]
'Pergamon,'
</PRE><!--TOC section EFetch: Downloading full records from Entrez-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc65">7.6</A>&#XA0;&#XA0;EFetch: Downloading full records from Entrez</H2><!--SEC END --><P>
<A NAME="sec:efetch"></A></P><P>EFetch is what you use when you want to retrieve a full record from Entrez.
For the <EM>Opuntia</EM> example above, we can download GenBank record 57240072 using <CODE>Bio.Entrez.efetch</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.efetch(db="nucleotide", id="57240072", rettype="genbank", 
                           email="A.N.Other@example.com")
&gt;&gt;&gt; print handle.read()
LOCUS       AY851612                 892 bp    DNA     linear   PLN 10-APR-2007
DEFINITION  Opuntia subulata rpl16 gene, intron; chloroplast.
ACCESSION   AY851612
VERSION     AY851612.1  GI:57240072
KEYWORDS    .
SOURCE      chloroplast Austrocylindropuntia subulata
  ORGANISM  Austrocylindropuntia subulata
            Eukaryota; Viridiplantae; Streptophyta; Embryophyta; Tracheophyta;
            Spermatophyta; Magnoliophyta; eudicotyledons; core eudicotyledons;
            Caryophyllales; Cactaceae; Opuntioideae; Austrocylindropuntia.
REFERENCE   1  (bases 1 to 892)
  AUTHORS   Butterworth,C.A. and Wallace,R.S.
  TITLE     Molecular Phylogenetics of the Leafy Cactus Genus Pereskia
            (Cactaceae)
  JOURNAL   Syst. Bot. 30 (4), 800-808 (2005)
REFERENCE   2  (bases 1 to 892)
  AUTHORS   Butterworth,C.A. and Wallace,R.S.
  TITLE     Direct Submission
  JOURNAL   Submitted (10-DEC-2004) Desert Botanical Garden, 1201 North Galvin
            Parkway, Phoenix, AZ 85008, USA
FEATURES             Location/Qualifiers
     source          1..892
                     /organism="Austrocylindropuntia subulata"
                     /organelle="plastid:chloroplast"
                     /mol_type="genomic DNA"
                     /db_xref="taxon:106982"
     gene            &lt;1..&gt;892
                     /gene="rpl16"
     intron          &lt;1..&gt;892
                     /gene="rpl16"
ORIGIN      
        1 cattaaagaa gggggatgcg gataaatgga aaggcgaaag aaagaaaaaa atgaatctaa
       61 atgatatacg attccactat gtaaggtctt tgaatcatat cataaaagac aatgtaataa
      121 agcatgaata cagattcaca cataattatc tgatatgaat ctattcatag aaaaaagaaa
      181 aaagtaagag cctccggcca ataaagacta agagggttgg ctcaagaaca aagttcatta
      241 agagctccat tgtagaattc agacctaatc attaatcaag aagcgatggg aacgatgtaa
      301 tccatgaata cagaagattc aattgaaaaa gatcctaatg atcattggga aggatggcgg
      361 aacgaaccag agaccaattc atctattctg aaaagtgata aactaatcct ataaaactaa
      421 aatagatatt gaaagagtaa atattcgccc gcgaaaattc cttttttatt aaattgctca
      481 tattttattt tagcaatgca atctaataaa atatatctat acaaaaaaat atagacaaac
      541 tatatatata taatatattt caaatttcct tatataccca aatataaaaa tatctaataa
      601 attagatgaa tatcaaagaa tctattgatt tagtgtatta ttaaatgtat atcttaattc
      661 aatattatta ttctattcat ttttattcat tttcaaattt ataatatatt aatctatata
      721 ttaatttata attctattct aattcgaatt caatttttaa atattcatat tcaattaaaa
      781 ttgaaatttt ttcattcgcg aggagccgga tgagaagaaa ctctcatgtc cggttctgta
      841 gtagagatgg aattaagaaa aaaccatcaa ctataacccc aagagaacca ga
//
</PRE><P>The argument <CODE>rettype="genbank"</CODE> lets us download this record in the GenBank format. Alternatively, you could for example use <CODE>rettype="fasta"</CODE> to get the Fasta-format; see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/efetchseq_help.html">EFetch Help page</A> for other options. The available formats depend on which database you are downloading from.</P><P>If you fetch the record in one of the formats accepted by <CODE>Bio.SeqIO</CODE> (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>), you can directly parse it into a <CODE>SeqRecord</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez, SeqIO
&gt;&gt;&gt; handle = Entrez.efetch(db="nucleotide", id="57240072",rettype="genbank",
                           email="A.N.Other@example.com")
&gt;&gt;&gt; record = SeqIO.read(handle, "genbank")
&gt;&gt;&gt; print record
ID: AY851612.1
Name: AY851612
Desription: Opuntia subulata rpl16 gene, intron; chloroplast.
/sequence_version=1
/source=chloroplast Austrocylindropuntia subulata
....
</PRE><P>By default you get the output in XML format, which you can parse using the <CODE>Bio.Entrez.read()</CODE> function:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.efetch(db="nucleotide", id="57240072",
                           email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record[0]["GBSeq_definition"]
'Opuntia subulata rpl16 gene, intron; chloroplast'
&gt;&gt;&gt; record[0]["GBSeq_source"]
'chloroplast Austrocylindropuntia subulata'
....
</PRE><!--TOC section ELink-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc66">7.7</A>&#XA0;&#XA0;ELink</H2><!--SEC END --><P>
For help on ELink, see the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/elink_help.html">ELink help page</A>. ELink is available from Biopython through <CODE>Bio.Entrez.elink()</CODE>.</P><!--TOC section EGQuery: Obtaining counts for search terms-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc67">7.8</A>&#XA0;&#XA0;EGQuery: Obtaining counts for search terms</H2><!--SEC END --><P>
EGQuery provides counts for a search term in each of the Entrez databases. This is particularly useful to find out how many items a search will return before actually performing the search with ESearch (see the example in <A HREF="#subsec:entrez_example_genbank">7.10.1</A> below).</P><P>In this example, we use <CODE>Bio.Entrez.egquery()</CODE> to obtain the counts for &#X201C;Biopython&#X201D;:</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.egquery(term="biopython",
                            email="A.N.Other@example.com") 
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["eGQueryResult"][0]["DbName"]
'pubmed'
&gt;&gt;&gt; record["eGQueryResult"][0]["Count"]
'5'
</PRE><P>See the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/egquery_help.html">EGQuery help page</A> for more information.</P><!--TOC section ESpell: Obtaining spelling suggestions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc68">7.9</A>&#XA0;&#XA0;ESpell: Obtaining spelling suggestions</H2><!--SEC END --><P>
ESpell retrieves spelling suggestions. In this example, we use <CODE>Bio.Entrez.espell()</CODE> to obtain the correct spelling of Biopython:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.espell(term="biopythooon", email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["Query"]
'biopythooon'
&gt;&gt;&gt; record["CorrectedQuery"]
'biopython'
</PRE><P>See the <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/espell_help.html">ESpell help page</A> for more information.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc69">7.10</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>
<A NAME="sec:entrez_examples"></A></P><!--TOC subsection Searching and downloading Entrez Nucleotide records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">7.10.1</A>&#XA0;&#XA0;Searching and downloading Entrez Nucleotide records</H3><!--SEC END --><P>
<A NAME="subsec:entrez_example_genbank"></A></P><P>Here we&#X2019;ll show a simple example of performing a remote Entrez query. In section&#XA0;<A HREF="#sec:orchids">2.3</A> of the parsing examples, we talked about using NCBI&#X2019;s Entrez website to search the NCBI nucleotide databases for info on Cypripedioideae, our friends the lady slipper orchids. Now, we&#X2019;ll look at how to automate that process using a Python script. In this example, we&#X2019;ll just show how to connect, get the results, and parse them, with the Entrez module doing all of the work.</P><P>First, we use EGQuery to find out the number of results we will get before actually downloading them:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.egquery(term='Cypripedioideae', email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; for row in record['eGQueryResult']:
...     if row['DbName']=='nuccore':
...         print row['Count']
814
</PRE><P>So, we expect to find 814 Entrez Nucleotide records. If you find some ridiculously high number of hits, you may want to reconsider if you really want to download all of them, which is our next step:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Entrez
&gt;&gt;&gt; handle = Entrez.esearch(db='nucleotide', term='Cypripedioideae', retmax=814,
                            email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
</PRE><P>Here, <CODE>record</CODE> is a Python dictionary containing the search results and some auxiliary information. Just for information, let&#X2019;s look at what is stored in this dictionary:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record.keys()
[u'Count', u'RetMax', u'IdList', u'TranslationSet', u'RetStart', u'QueryTranslation']
</PRE><P>First, let&#X2019;s check how many results were found:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record['Count']
'814'
</PRE><P>which is the number we expected. The 814 results are stored in <CODE>record['IdList']</CODE>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print len(record['IdList'])
814
</PRE><P>Let&#X2019;s look at the first five results:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record['IdList'][:5]
['187237168', '187372713', '187372690', '187372688', '187372686']
</PRE><P><A NAME="sec:entrez-batched-efetch"></A>
We can download these records using <CODE>efetch</CODE>.
While you could download these records one by one, to reduce the load on NCBI&#X2019;s servers, it is better to fetch a bunch of records at the same time, shown below.
However, in this situation you should ideally be using the history feature described later in Section&#XA0;<A HREF="#subsec:entrez-webenv">7.10.3</A>.</P><PRE CLASS="verbatim">&gt;&gt;&gt; idlist = ",".join(record['IdList'][:5])
&gt;&gt;&gt; print idlist
187237168,187372713,187372690,187372688,187372686
&gt;&gt;&gt; handle = Entrez.efetch(db='nucleotide', id=idlist, retmode='xml',
                           email="A.N.Other@example.com")
&gt;&gt;&gt; records = Entrez.read(handle)
&gt;&gt;&gt; print len(records)
5
</PRE><P>Each of these records corresponds to one GenBank record.
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print records[0].keys()
[u'GBSeq_moltype', u'GBSeq_source', u'GBSeq_sequence',
 u'GBSeq_primary-accession', u'GBSeq_definition', u'GBSeq_accession-version',
 u'GBSeq_topology', u'GBSeq_length', u'GBSeq_feature-table',
 u'GBSeq_create-date', u'GBSeq_other-seqids', u'GBSeq_division',
 u'GBSeq_taxonomy', u'GBSeq_references', u'GBSeq_update-date',
 u'GBSeq_organism', u'GBSeq_locus', u'GBSeq_strandedness']

&gt;&gt;&gt; print records[0]['GBSeq_primary-accession']
DQ110336

&gt;&gt;&gt; print records[0]['GBSeq_other-seqids']
['gb|DQ110336.1|', 'gi|187237168']

&gt;&gt;&gt; print records[0]['GBSeq_definition']
Cypripedium calceolus voucher Davis 03-03 A maturase (matR) gene, partial cds;
mitochondrial

&gt;&gt;&gt; print records[0]['GBSeq_organism']
Cypripedium calceolus
</PRE><P>You could use this to quickly set up searches &#X2013; but for heavy usage, see Section&#XA0;<A HREF="#subsec:entrez-webenv">7.10.3</A>.</P><!--TOC subsection Finding the lineage of an organism-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">7.10.2</A>&#XA0;&#XA0;Finding the lineage of an organism</H3><!--SEC END --><P>Staying with the same organism, let&#X2019;s now find its lineage. First, we search the Taxonomy database for Cypripedioideae. We find exactly one accession number:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.esearch(db="Taxonomy", term="Cypripedioideae",
                            email="A.N.Other@example.com")
&gt;&gt;&gt; record = Entrez.read(handle)
&gt;&gt;&gt; record["IdList"]
['158330']
&gt;&gt;&gt; record["IdList"][0]
'158330'
</PRE><P>Now, we use <CODE>efetch</CODE> to download this entry in the Taxonomy database and to parse it:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = Entrez.efetch(db="Taxonomy", id="158330", retmode='xml')
&gt;&gt;&gt; records = Entrez.read(handle)
</PRE><P>Again, this record stores lots of information:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; records[0].keys()
[u'Lineage', u'Division', u'ParentTaxId', u'PubDate', u'LineageEx',
 u'CreateDate', u'TaxId', u'Rank', u'GeneticCode', u'ScientificName',
 u'MitoGeneticCode', u'UpdateDate']
</PRE><P>We can get the lineage directly from this record:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; records[0]['Lineage']
'cellular organisms; Eukaryota; Viridiplantae; Streptophyta; Streptophytina;
 Embryophyta; Tracheophyta; Euphyllophyta; Spermatophyta; Magnoliophyta;
 Liliopsida; Asparagales; Orchidaceae'
</PRE><!--TOC subsection Using the history and WebEnv-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">7.10.3</A>&#XA0;&#XA0;Using the history and WebEnv</H3><!--SEC END --><P>
<A NAME="subsec:entrez-webenv"></A></P><P>Often you will want to make a series of linked queries. Most typically, running a search, perhaps refining the search, and then retrieving detailed search results. You <EM>can</EM> do this by making a series of separate calls to Entrez. However, the NCBI prefer you to take advantage of their history support.</P><P>For example, suppose we want to search and download all Orchid rpl16 nucleotide sequences, and store them in a FASTA file. We could naively combine the example code for <CODE>Bio.Entrez.esearch()</CODE> (Section&#XA0;<A HREF="#sec:entrez-esearch">7.3</A>) to get a list of GI numbers, and then repeatedly call <CODE>Bio.Entrez.efetch()</CODE> (Section&#XA0;<A HREF="#sec:efetch">7.6</A>) to download them all. You could reduce the number of queries by asking for the records in batches (see Section&#XA0;<A HREF="#sec:entrez-batched-efetch">7.10.1</A>). That would probably be better, but is still not what the NCBI encourage.</P><P>The approved approach is to run the search with the history feature. Then, we can fetch the results by reference to the search results - which the NCBI can anticipate and cache.</P><PRE CLASS="verbatim">from Bio import Entrez
search_handle = Entrez.esearch(db="nucleotide",term="Opuntia and rpl16",
                               usehistory="y", email="history.user@example.com")
search_results = Entrez.read(search_handle)
search_handle.close()

gi_list = search_results["IdList"]
count = int(search_results["Count"])
assert count == len(gi_list)

session_cookie = search_results["WebEnv"]
query_key = search_results["QueryKey"] 
</PRE><P>In addition to the GI numbers of the sequences found in the search, because we have asked to use the history feature the XML search results also include <TT>WebEnv</TT> and <TT>QueryKey</TT> values which are used to refer to these search results. Having stored these values in variables <TT>session_cookie</TT> and <TT>query_key</TT> we can use them as parameters to <CODE>Bio.Entrez.efetch()</CODE> instead of giving the GI numbers as identifiers. </P><P>While for small searches you might be OK downloading everything at once, its better download in batches. You use the <TT>retstart</TT> and <TT>retmax</TT> parameters to specify which range of search results you want returned (starting entry using zero-based counting, and maximum number of results to return). For example,</P><PRE CLASS="verbatim">batch_size = 3
out_handle = open("orchid_rpl16.fasta", "w")
for start in range(0,count,batch_size) :
    end = min(count, start+batch_size)
    print "Going to download record %i to %i" % (start+1, end)
    fetch_handle = Entrez.efetch(db="nucleotide", rettype="fasta",
                                 retstart=start, retmax=batch_size,
                                 webenv=session_cookie, query_key=query_key,
                                 email="history.user@example.com")
    data = fetch_handle.read()
    fetch_handle.close()
    out_handle.write(data)
out_handle.close()
</PRE><P>And finally, don&#X2019;t forget to include your <EM>own</EM> email address in the Entrez calls.</P><!--TOC chapter Swiss-Prot, Prosite, Prodoc, and ExPASy-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc73">Chapter&#XA0;8</A>&#XA0;&#XA0;Swiss-Prot, Prosite, Prodoc, and ExPASy</H1><!--SEC END --><P>
<A NAME="chapter:swiss_prot"></A></P><!--TOC section Bio.SwissProt: Parsing Swiss-Prot files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc74">8.1</A>&#XA0;&#XA0;Bio.SwissProt: Parsing Swiss-Prot files</H2><!--SEC END --><!--TOC subsection Parsing Swiss-Prot records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc75">8.1.1</A>&#XA0;&#XA0;Parsing Swiss-Prot records</H3><!--SEC END --><P>Swiss-Prot (<A HREF="http://www.expasy.org/sprot"><TT>http://www.expasy.org/sprot</TT></A>) is a hand-curated database of protein sequences. In Section&#XA0;<A HREF="#sec:SeqIO_ExPASy_and_SwissProt">4.2.2</A>, we described how to extract the sequence of a Swiss-Prot record as a <CODE>SeqRecord</CODE> object. Alternatively, you can store the Swiss-Prot record in a <CODE>Bio.SwissProt.SProt.Record</CODE> object, which in fact stores the complete information contained in the Swiss-Prot record. In this Section, we describe how to extract <CODE>Bio.SwissProt.SProt.Record</CODE> objects from a Swiss-Prot file.</P><P>To parse a Swiss-Prot record, we first get a handle to a Swiss-Prot record. There are several ways to do so, depending on where and how the Swiss-Prot record is stored:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Open a Swiss-Prot file locally:<BR>
<CODE>&gt;&gt;&gt; handle = open("myswissprotfile.dat")</CODE>
</LI><LI CLASS="li-itemize">Open a gzipped Swiss-Prot file:
<PRE CLASS="verbatim">&gt;&gt;&gt; import gzip
&gt;&gt;&gt; handle = gzip.open("myswissprotfile.dat.gz")
</PRE></LI><LI CLASS="li-itemize">Open a Swiss-Prot file over the internet:
<PRE CLASS="verbatim">&gt;&gt;&gt; import urllib
&gt;&gt;&gt; handle = urllib.urlopen("http://www.somelocation.org/data/someswissprotfile.dat")
</PRE></LI><LI CLASS="li-itemize">Open a Swiss-Prot file over the internet from the ExPASy database
(see section <A HREF="#subsec:expasy_swissprot">8.4.1</A>):
<PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; handle = ExPASy.get_sprot_raw(myaccessionnumber)
</PRE></LI></UL><P>
The key point is that for the parser, it doesn&#X2019;t matter how the handle was created, as long as it points to data in the Swiss-Prot format.</P><P>We can use Bio.SeqIO as described in Section&#XA0;<A HREF="#sec:SeqIO_ExPASy_and_SwissProt">4.2.2</A> to get file format agnostic <CODE>SeqRecord</CODE> objects. Alternatively, we can get <CODE>Bio.SwissProt.SProt.Record</CODE> objects which are a much closer match to the underlying file format, using following code.</P><P>To read one Swiss-Prot record from the handle, we use the function <CODE>read()</CODE>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SwissProt
&gt;&gt;&gt; record = SwissProt.read(handle)
</PRE><P>This function should be used if the handle points to exactly one Swiss-Prot record. It raises a <CODE>ValueError</CODE> if no Swiss-Prot record was found, and also if more than one record was found.</P><P>We can now print out some information about this record:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; print record.description
CHALCONE SYNTHASE 3 (EC 2.3.1.74) (NARINGENIN-CHALCONE SYNTHASE 3).
&gt;&gt;&gt; for ref in record.references:
...     print "authors:", ref.authors
...     print "title:", ref.title
...
authors: Liew C.F., Lim S.H., Loh C.S., Goh C.J.;
title: "Molecular cloning and sequence analysis of chalcone synthase cDNAs of
Bromheadia finlaysoniana.";
&gt;&gt;&gt; print record.organism_classification
['Eukaryota', 'Viridiplantae', 'Embryophyta', 'Tracheophyta', 'Spermatophyta',
'Magnoliophyta', 'Liliopsida', 'Asparagales', 'Orchidaceae', 'Bromheadia']
</PRE><P>To parse a file that contains more than one Swiss-Prot record, we use the <CODE>parse</CODE> function instead. This function allows us to iterate over the records in the file. For example, let&#X2019;s parse the full Swiss-Prot database and collect all the descriptions. The full Swiss-Prot database, downloaded from ExPASy on 4 December 2007, contains 290484 Swiss-Prot records in a single gzipped-file <CODE>uniprot_sprot.dat.gz</CODE>.</P><PRE CLASS="verbatim">&gt;&gt;&gt; import gzip
&gt;&gt;&gt; input = gzip.open("uniprot_sprot.dat.gz")
&gt;&gt;&gt; from Bio import SwissProt
&gt;&gt;&gt; records = SwissProt.parse(input)
&gt;&gt;&gt; descriptions = []
&gt;&gt;&gt; for record in records:
...     description = record.description
...     descriptions.append(description)
...
&gt;&gt;&gt; len(descriptions)
290484
&gt;&gt;&gt; descriptions[:3]
['104 kDa microneme/rhoptry antigen precursor (p104).',
 '104 kDa microneme/rhoptry antigen precursor (p104).',
 'Protein 108 precursor.']
</PRE><P>It is equally easy to extract any kind of information you&#X2019;d like from Swiss-Prot records. To see the members of a Swiss-Prot record, use
</P><PRE CLASS="verbatim">&gt;&gt;&gt; dir(record)
['__doc__', '__init__', '__module__', 'accessions', 'annotation_update',
'comments', 'created', 'cross_references', 'data_class', 'description',
'entry_name', 'features', 'gene_name', 'host_organism', 'keywords',
'molecule_type', 'organelle', 'organism', 'organism_classification',
'references', 'seqinfo', 'sequence', 'sequence_length',
'sequence_update', 'taxonomy_id']
</PRE><!--TOC subsection Parsing the Swiss-Prot keyword and category list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc76">8.1.2</A>&#XA0;&#XA0;Parsing the Swiss-Prot keyword and category list</H3><!--SEC END --><P>Swiss-Prot also distributes a file <CODE>keywlist.txt</CODE>, which lists the keywords and categories used in Swiss-Prot. The file contains entries in the following form:</P><PRE CLASS="verbatim">ID   2Fe-2S.
AC   KW-0001
DE   Protein which contains at least one 2Fe-2S iron-sulfur cluster: 2 iron
DE   atoms complexed to 2 inorganic sulfides and 4 sulfur atoms of
DE   cysteines from the protein.
SY   Fe2S2; [2Fe-2S] cluster; [Fe2S2] cluster; Fe2/S2 (inorganic) cluster;
SY   Di-mu-sulfido-diiron; 2 iron, 2 sulfur cluster binding.
GO   GO:0051537; 2 iron, 2 sulfur cluster binding
HI   Ligand: Iron; Iron-sulfur; 2Fe-2S.
HI   Ligand: Metal-binding; 2Fe-2S.
CA   Ligand.
//
ID   3D-structure.
AC   KW-0002
DE   Protein, or part of a protein, whose three-dimensional structure has
DE   been resolved experimentally (for example by X-ray crystallography or
DE   NMR spectroscopy) and whose coordinates are available in the PDB
DE   database. Can also be used for theoretical models.
HI   Technical term: 3D-structure.
CA   Technical term.
//
ID   3Fe-4S.
...
</PRE><P>The entries in this file can be parsed by the <CODE>parse</CODE> function in the <CODE>Bio.SwissProt.KeyWList</CODE> module. Each entry is then stored as a <CODE>Bio.SwissProt.KeyWList.Record</CODE>, which is a Python dictionary.</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.SwissProt import KeyWList
&gt;&gt;&gt; handle = open("keywlist.txt")
&gt;&gt;&gt; records = KeyWList.parse(handle)
&gt;&gt;&gt; for record in records:
...     print record['ID']
...     print record['DE']
</PRE><P>This prints
</P><PRE CLASS="verbatim">2Fe-2S.
Protein which contains at least one 2Fe-2S iron-sulfur cluster: 2 iron atoms
complexed to 2 inorganic sulfides and 4 sulfur atoms of cysteines from the
protein.
...
</PRE><!--TOC section Bio.Prosite: Parsing Prosite records-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc77">8.2</A>&#XA0;&#XA0;Bio.Prosite: Parsing Prosite records</H2><!--SEC END --><P>Prosite is a database containing protein domains, protein families, functional sites, as well as the patterns and profiles to recognize them. Prosite was developed in parallel with Swiss-Prot. In Biopython, a Prosite record is represented by the <CODE>Bio.Prosite.Record</CODE> class, whose members correspond to the different fields in a Prosite record.</P><P>In general, a Prosite file can contain more than one Prosite records. For example, the full set of Prosite records, which can be downloaded as a single file (<CODE>prosite.dat</CODE>) from ExPASy, contains 2073 records in (version 20.24 released on 4 December 2007). To parse such a file, we again make use of an iterator:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Prosite
&gt;&gt;&gt; handle = open("myprositefile.dat")
&gt;&gt;&gt; records = Prosite.parse(handle)
</PRE><P>We can now take the records one at a time and print out some information. For example, using the file containing the complete Prosite database, we&#X2019;d find
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Prosite
&gt;&gt;&gt; handle = open("prosite.dat")
&gt;&gt;&gt; records = Prosite.parse(handle)
&gt;&gt;&gt; record = records.next()
&gt;&gt;&gt; record.accession
'PS00001'
&gt;&gt;&gt; record.name
'ASN_GLYCOSYLATION'
&gt;&gt;&gt; record.pdoc
'PDOC00001'
&gt;&gt;&gt; record = records.next()
&gt;&gt;&gt; record.accession
'PS00004'
&gt;&gt;&gt; record.name
'CAMP_PHOSPHO_SITE'
&gt;&gt;&gt; record.pdoc
'PDOC00004'
&gt;&gt;&gt; record = records.next()
&gt;&gt;&gt; record.accession
'PS00005'
&gt;&gt;&gt; record.name
'PKC_PHOSPHO_SITE'
&gt;&gt;&gt; record.pdoc
'PDOC00005'
</PRE><P>and so on. If you&#X2019;re interested in how many Prosite records there are, you could use
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Prosite
&gt;&gt;&gt; handle = open("prosite.dat")
&gt;&gt;&gt; records = Prosite.parse(handle)
&gt;&gt;&gt; n = 0
&gt;&gt;&gt; for record in records: n+=1
...
&gt;&gt;&gt; print n
2073
</PRE><P>To read exactly one Prosite from the handle, you can use the <CODE>read</CODE> function:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import Prosite
&gt;&gt;&gt; handle = open("mysingleprositerecord.dat")
&gt;&gt;&gt; record = Prosite.read(handle)
</PRE><P>This function raises a ValueError if no Prosite record is found, and also if more than one Prosite record is found.</P><!--TOC section Bio.Prosite.Prodoc: Parsing Prodoc records-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc78">8.3</A>&#XA0;&#XA0;Bio.Prosite.Prodoc: Parsing Prodoc records</H2><!--SEC END --><P>In the Prosite example above, the <CODE>record.pdoc</CODE> accession numbers <CODE>'PDOC00001'</CODE>, <CODE>'PDOC00004'</CODE>, <CODE>'PDOC00005'</CODE> and so on refer to Prodoc records, which contain the Prosite Documentation. The Prodoc records are available from ExPASy as individual files, and as one file (<CODE>prosite.doc</CODE>) containing all Prodoc records.</P><P>We use the parser in <CODE>Bio.Prosite.Prodoc</CODE> to parse Prodoc records. For example, to create a list of all Prodoc accession numbers, you can use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Prosite import Prodoc
&gt;&gt;&gt; handle = open("prosite.doc")
&gt;&gt;&gt; records = Prodoc.parse(handle)
&gt;&gt;&gt; accessions = [record.accession for record in records]
</PRE><P>Again a <CODE>read()</CODE> function is provided to read exactly one Prodoc record from the handle.</P><!--TOC section Bio.ExPASy: Accessing the ExPASy server-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc79">8.4</A>&#XA0;&#XA0;Bio.ExPASy: Accessing the ExPASy server</H2><!--SEC END --><P>Swiss-Prot, Prosite, and Prodoc records can be downloaded from the ExPASy web server at <A HREF="http://www.expasy.org"><TT>http://www.expasy.org</TT></A>. Six kinds of queries are available from ExPASy:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>get_prodoc_entry</B></DT><DD CLASS="dd-description">To download a Prodoc record in HTML format
</DD><DT CLASS="dt-description"><B>get_prosite_entry</B></DT><DD CLASS="dd-description">To download a Prosite record in HTML format
</DD><DT CLASS="dt-description"><B>get_prosite_raw</B></DT><DD CLASS="dd-description">To download a Prosite or Prodoc record in raw format
</DD><DT CLASS="dt-description"><B>get_sprot_raw</B></DT><DD CLASS="dd-description">To download a Swiss-Prot record in raw format
</DD><DT CLASS="dt-description"><B>sprot_search_ful</B></DT><DD CLASS="dd-description">To search for a Swiss-Prot record
</DD><DT CLASS="dt-description"><B>sprot_search_de</B></DT><DD CLASS="dd-description">To search for a Swiss-Prot record
</DD></DL><P>
To access this web server from a Python script, we use the <CODE>Bio.ExPASy</CODE> module.</P><!--TOC subsection Retrieving a Swiss-Prot record-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc80">8.4.1</A>&#XA0;&#XA0;Retrieving a Swiss-Prot record</H3><!--SEC END --><P>
<A NAME="subsec:expasy_swissprot"></A></P><P>Let&#X2019;s say we are looking at chalcone synthases for Orchids (see section&#XA0;<A HREF="#sec:orchids">2.3</A> for some justification for looking for interesting things about orchids). Chalcone synthase is involved in flavanoid biosynthesis in plants, and flavanoids make lots of cool things like pigment colors and UV protectants. </P><P>If you do a search on Swiss-Prot, you can find three orchid proteins for Chalcone Synthase, id numbers O23729, O23730, O23731. Now, let&#X2019;s write a script which grabs these, and parses out some interesting information.</P><P>First, we grab the records, using the <CODE>get_sprot_raw()</CODE> function of <CODE>Bio.ExPASy</CODE>. This function is very nice since you can feed it an id and get back a handle to a raw text record (no html to mess with!). We can the use <CODE>Bio.SwissProt.read</CODE> to pull out the Swiss-Prot record, or <CODE>Bio.SeqIO.read</CODE> to get a SeqRecord. The following code accomplishes what I just wrote:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; from Bio import SwissProt

&gt;&gt;&gt; accessions = ["O23729", "O23730", "O23731"]
&gt;&gt;&gt; records = []

&gt;&gt;&gt; for accession in accessions:
...     handle = ExPASy.get_sprot_raw(accession)
...     record = SwissProt.read(handle)
...     records.append(record)
</PRE><P>If the accession number you provided to <CODE>ExPASy.get_sprot_raw</CODE> does not exist, then <CODE>SwissProt.read(handle)</CODE> will raise a <CODE>ValueError</CODE>. You can catch <CODE>ValueException</CODE> exceptions to detect invalid accession numbers:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for accession in accessions:
...     handle = ExPASy.get_sprot_raw(accession)
...     try:
...         record = SwissProt.read(handle)
...     except ValueException:
...         print "WARNING: Accession %s not found" % accession
...     records.append(record)
</PRE><!--TOC subsection Searching Swiss-Prot-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">8.4.2</A>&#XA0;&#XA0;Searching Swiss-Prot</H3><!--SEC END --><P>Now, you may remark that I knew the records&#X2019; accession numbers
beforehand. Indeed, <CODE>get_sprot_raw()</CODE> needs either the entry name
or an accession number. When you don&#X2019;t have them handy, you can use
one of the <CODE>sprot_search_de()</CODE> or <CODE>sprot_search_ful()</CODE>
functions.</P><P><CODE>sprot_search_de()</CODE> searches in the ID, DE, GN, OS and OG lines;
<CODE>sprot_search_ful()</CODE> searches in (nearly) all the fields. They
are detailed on
<A HREF="http://www.expasy.org/cgi-bin/sprot-search-de"><TT>http://www.expasy.org/cgi-bin/sprot-search-de</TT></A> and
<A HREF="http://www.expasy.org/cgi-bin/sprot-search-ful"><TT>http://www.expasy.org/cgi-bin/sprot-search-ful</TT></A>
respectively. Note that they don&#X2019;t search in TrEMBL by default
(argument <CODE>trembl</CODE>). Note also that they return html pages;
however, accession numbers are quite easily extractable:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; import re

&gt;&gt;&gt; handle = ExPASy.sprot_search_de("Orchid Chalcone Synthase")
&gt;&gt;&gt; # or:
&gt;&gt;&gt; # handle = ExPASy.sprot_search_ful("Orchid and {Chalcone Synthase}")
&gt;&gt;&gt; html_results = handle.read()
&gt;&gt;&gt; if "Number of sequences found" in html_results:
...     ids = re.findall(r'HREF="/uniprot/(\w+)"', html_results)
... else:
...     ids = re.findall(r'href="/cgi-bin/niceprot\.pl\?(\w+)"', html_results)
</PRE><!--TOC subsection Retrieving Prosite and Prodoc records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc82">8.4.3</A>&#XA0;&#XA0;Retrieving Prosite and Prodoc records</H3><!--SEC END --><P>Prosite and Prodoc records can be retrieved either in HTML format, or in raw format. To parse Prosite and Prodoc records with Biopython, you should retrieve the records in raw format. For other purposes, however, you may be interested in these records in HTML format.</P><P>To retrieve a Prosite or Prodoc record in raw format, use <CODE>get_prosite_raw()</CODE>. Although this function has <CODE>prosite</CODE> in the name, it can be used for Prodoc records as well. For example, to download a Prosite record and print it out in raw text format, use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; handle = ExPASy.get_prosite_raw('PS00001')
&gt;&gt;&gt; text = handle.read()
&gt;&gt;&gt; print text
</PRE><P>To retrieve a Prosite record and parse it into a <CODE>Bio.Prosite.Record</CODE> object, use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; from Bio import Prosite
&gt;&gt;&gt; handle = ExPASy.get_prosite_raw('PS00001')
&gt;&gt;&gt; record = Prosite.read(handle)
</PRE><P>Finally, to retrieve a Prodoc record and parse it into a <CODE>Bio.Prosite.Prodoc.Record</CODE> object, use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; from Bio.Prosite import Prodoc
&gt;&gt;&gt; handle = ExPASy.get_prosite_raw('PDOC00001')
&gt;&gt;&gt; record = Prodoc.read(handle)
</PRE><P>For non-existing accession numbers, <CODE>ExPASy.get_prosite_raw</CODE> returns a handle to an emptry string. When faced with an empty string, <CODE>Prosite.read</CODE> and <CODE>Prodoc.read</CODE> will raise a ValueError. You can catch these exceptions to detect invalid accession numbers.</P><P>The functions <CODE>get_prosite_entry()</CODE> and <CODE>get_prodoc_entry()</CODE> are used to download Prosite and Prodoc records in HTML format. To create a web page showing one Prosite record, you can use</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; handle = ExPASy.get_prosite_entry('PS00001')
&gt;&gt;&gt; html = handle.read()
&gt;&gt;&gt; output = open("myprositerecord.html", "w")
&gt;&gt;&gt; output.write(html)
&gt;&gt;&gt; output.close()
</PRE><P>and similarly for a Prodoc record:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import ExPASy
&gt;&gt;&gt; handle = ExPASy.get_prodoc_entry('PDOC00001')
&gt;&gt;&gt; html = handle.read()
&gt;&gt;&gt; output = open("myprodocrecord.html", "w")
&gt;&gt;&gt; output.write(html)
&gt;&gt;&gt; output.close()
</PRE><P>For these functions, an invalid accession number returns an error message in HTML format.</P><!--TOC chapter Cookbook &#X2013; Cool things to do with it-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc83">Chapter&#XA0;9</A>&#XA0;&#XA0;Cookbook &#X2013; Cool things to do with it</H1><!--SEC END --><P>
<A NAME="chapter:cookbook"></A></P><!--TOC section PubMed-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc84">9.1</A>&#XA0;&#XA0;PubMed</H2><!--SEC END --><P>
<A NAME="sec:pub_med"></A></P><P>The <CODE>Bio.PubMed</CODE> module uses <CODE>Bio.Entrez</CODE> internally to access the NCBI.
<EM>Please</EM> remember to read and observe the NCBI&#X2019;s guidelines on using their Entrez online facilities responsibly. If you are found to be abusing their servers, they can and will block your access! See Section&#XA0;<A HREF="#sec:entrez-guidelines">7.1</A>.</P><!--TOC subsection Sending a query to PubMed-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">9.1.1</A>&#XA0;&#XA0;Sending a query to PubMed</H3><!--SEC END --><P>If you are in the Medical field or interested in human issues (and many times even if you are not!), PubMed (<A HREF="http://www.ncbi.nlm.nih.gov/PubMed/"><TT>http://www.ncbi.nlm.nih.gov/PubMed/</TT></A>) is an excellent source of all kinds of goodies. So like other things, we&#X2019;d like to be able to grab information from it and use it in python scripts.</P><P>Querying PubMed using Biopython is extremely painless. To get all of the article ids for articles having to do with orchids (see section&#XA0;<A HREF="#sec:orchids">2.3</A> for our motivation), we only need the following three lines of code:</P><PRE CLASS="verbatim">from Bio import PubMed

search_term = 'orchid'
orchid_ids = PubMed.search_for(search_term)
</PRE><P>This returns a python list containing all of the orchid ids</P><PRE CLASS="verbatim">['11070358', '11064040', '11028023', '10947239', '10938351', '10936520',
'10905611', '10899814', '10856762', '10854740', '10758893', '10716342',
...
</PRE><P>With this list of ids we are ready to start retrieving the records, so follow on ahead to the next section.</P><!--TOC subsection Retrieving a PubMed record-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc86">9.1.2</A>&#XA0;&#XA0;Retrieving a PubMed record</H3><!--SEC END --><P>The previous section described how to get a bunch of article ids. Now that we&#X2019;ve got them, we obviously want to get the corresponding Medline records and extract the information from them.</P><P>The interface for retrieving records from PubMed should be very intuitive to python programmers &#X2013; it models a python dictionary. To set up this interface, we need to set up a parser that will parse the results that we retrieve. The following lines of code get everything set up:</P><PRE CLASS="verbatim">from Bio import PubMed
from Bio import Medline

rec_parser = Medline.RecordParser()
medline_dict = PubMed.Dictionary(parser = rec_parser)
</PRE><P>What we&#X2019;ve done is create a dictionary like object <CODE>medline_dict</CODE>. To get an article we access it like <CODE>medline_dict[id_to_get]</CODE>. What this does is connect with PubMed, get the article you ask for, parse it into a record object, and return it. Very cool!</P><P>Now let&#X2019;s look at how to use this nice dictionary to print out some information about some ids. We just need to loop through our ids (<CODE>orchid_ids</CODE> from the previous section) and print out the information we are interested in:</P><PRE CLASS="verbatim">for oid in orchid_ids[0:5]:
    cur_record = medline_dict[oid]
    print 'title:', cur_record.title.rstrip()
    print 'authors:', cur_record.authors
    print 'source:', cur_record.source.strip()
    print
</PRE><P>The output for this looks like:</P><PRE CLASS="verbatim">title: Sex pheromone mimicry in the early spider orchid (ophrys sphegodes):
patterns of hydrocarbons as the key mechanism for pollination by sexual
deception [In Process Citation]
authors: ['Schiestl FP', 'Ayasse M', 'Paulus HF', 'Lofstedt C', 'Hansson BS',
'Ibarra F', 'Francke W']
source: J Comp Physiol [A] 2000 Jun;186(6):567-74
</PRE><P>Especially interesting to note is the list of authors, which is returned as a standard python list. This makes it easy to manipulate and search using standard python tools. For instance, we could loop through a whole bunch of entries searching for a particular author with code like the following:</P><PRE CLASS="verbatim">search_author = 'Waits T'

for our_id in our_id_list:
    cur_record = medline_dict[our_id]
   
    if search_author in cur_record.authors:
        print "Author %s found: %s" % (search_author,
                                       cur_record.source.strip())
</PRE><P>The PubMed and Medline interfaces are very mature and nice to work with &#X2013; hopefully this section gave you an idea of the power of the interfaces and how they can be used.</P><!--TOC section GenBank-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc87">9.2</A>&#XA0;&#XA0;GenBank</H2><!--SEC END --><P>The GenBank record format is a very popular method of holding information about sequences, sequence features, and other associated sequence information. The format is a good way to get information from the NCBI databases at <A HREF="http://www.ncbi.nlm.nih.gov/"><TT>http://www.ncbi.nlm.nih.gov/</TT></A>.</P><P>The <CODE>Bio.GenBank</CODE> module uses the NCBI&#X2019;s Entrez interface to run searches and fetch data.
<EM>Please</EM> remember to read and observe the NCBI&#X2019;s guidelines on using their Entrez online facilities responsibly. If you are found to be abusing their servers, they can and will block your access! See Section&#XA0;<A HREF="#sec:entrez-guidelines">7.1</A>.</P><!--TOC subsection Retrieving GenBank entries from NCBI-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">9.2.1</A>&#XA0;&#XA0;Retrieving GenBank entries from NCBI</H3><!--SEC END --><P>
<A NAME="genbank-retrieval"></A></P><P>One very nice feature of the GenBank libraries is the ability to automate retrieval of entries from GenBank. This is very convenient for creating scripts that automate a lot of your daily work. In this example we&#X2019;ll show how to query the NCBI databases, and to retrieve the records from the query - something touched on in Section&#XA0;<A HREF="#sec:SeqIO_GenBank_Online">4.2.1</A>.</P><P>First, we want to make a query and find out the ids of the records to retrieve. Here we&#X2019;ll do a quick search for our favorite organism, <EM>Opuntia</EM>. We can do quick search and get back the GIs (GenBank identifiers) for all of the corresponding records:</P><PRE CLASS="verbatim">from Bio import GenBank

gi_list = GenBank.search_for("Opuntia AND rpl16")
</PRE><P><CODE>gi_list</CODE> will be a list of all of the GenBank identifiers that match our query:</P><PRE CLASS="verbatim">["6273291", "6273290", "6273289", "6273287", "6273286", "6273285", "6273284"]
</PRE><P>Now that we&#X2019;ve got the GIs, we can use these to access the NCBI database through a dictionary interface. For instance, to retrieve the information for the first GI, we&#X2019;ll first have to create a dictionary that accesses NCBI:</P><PRE CLASS="verbatim">ncbi_dict = GenBank.NCBIDictionary("nucleotide", "genbank")
</PRE><P>Now that we&#X2019;ve got this, we do the retrieval:</P><PRE CLASS="verbatim">gb_record = ncbi_dict[gi_list[0]]
</PRE><P>In this case, <CODE>gb_record</CODE> will be GenBank formatted record:</P><PRE CLASS="verbatim">LOCUS       AF191665      902 bp    DNA             PLN       07-NOV-1999
DEFINITION  Opuntia marenae rpl16 gene; chloroplast gene for chloroplast
            product, partial intron sequence.
ACCESSION   AF191665
VERSION     AF191665.1  GI:6273291
...
</PRE><P>In this case, we are just getting the raw records. We can also pass these records directly into a parser and return the parsed record. For instance, if we wanted to get back SeqRecord objects with the GenBank file parsed into SeqFeature objects we would need to create the dictionary with the GenBank FeatureParser:</P><PRE CLASS="verbatim">record_parser = GenBank.FeatureParser()
ncbi_dict = GenBank.NCBIDictionary("nucleotide", "genbank",
                                   parser = record_parser)
</PRE><P>Now retrieving a record will give you a SeqRecord object instead of the raw record:</P><PRE CLASS="verbatim">&gt;&gt;&gt; gb_seqrecord = ncbi_dict[gi_list[0]]
&gt;&gt;&gt; print gb_seqrecord
&lt;Bio.SeqRecord.SeqRecord instance at 0x102f9404&gt;
</PRE><P>Using these automated query retrieval functionality is a big plus over doing things by hand. Although the module should obey the NCBI&#X2019;s three-second rule, the NCBI have other recommendations like avoiding peak hours. See Section&#XA0;<A HREF="#sec:entrez-guidelines">7.1</A>.</P><P>For more information of formats you can parse GenBank records into, please see section&#XA0;<A HREF="#sec:gb-parsing">9.2.2</A>.</P><!--TOC subsection Parsing GenBank records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">9.2.2</A>&#XA0;&#XA0;Parsing GenBank records</H3><!--SEC END --><P>
<A NAME="sec:gb-parsing"></A></P><P>While GenBank files are nice and have lots of information, at the same time you probably only want to extract a small amount of that information at a time. The key to doing this is parsing out the information. Biopython provides GenBank parsers which help you accomplish this task. Right now the GenBank module provides the following parsers:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
RecordParser &#X2013; This parses the raw record into a GenBank specific Record object. This object models the information in a raw record very closely, so this is good to use if you are just interested in GenBank records themselves.</LI><LI CLASS="li-enumerate">FeatureParser &#X2013; This parses the raw record in a SeqRecord object with all of the feature table information represented in SeqFeatures (see section&#XA0;<A HREF="#sec:advanced-seq">10.1</A> for more info on these objects). This is best to use if you are interested in getting things in a more standard format. If you use <CODE>Bio.SeqIO</CODE> (Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>) to read a GenBank file, it will call this FeatureParser for you.
</LI></OL><P>Depending on the type of GenBank files you are interested in, they will either contain a single record, or multiple records. Each record will start with a <TT>LOCUS</TT> line, various other header lines, a list of features, and finally the sequence data, ending with a <TT>//</TT> line.</P><P>Dealing with a GenBank file containing a single record is very easy. For example, let&#X2019;s use a small bacterial genome, <EM>Nanoarchaeum equitans Kin4-M</EM> (RefSeq NC_005213, GenBank AE017199) which can be downloaded from the NCBI here <A HREF="ftp://ftp.ncbi.nlm.nih.gov/genbank/genomes/Bacteria/Nanoarchaeum_equitans/AE017199.gbk">(</A>only 1.15 MB):</P><PRE CLASS="verbatim">from Bio import GenBank
feature_parser = GenBank.FeatureParser()
gb_record = feature_parser.parse(open("AE017199.gbk"))
# now do something with the record
print "Name %s, %i features" % (gb_record.name, len(gb_record.features))
print repr(gb_record.seq)
</PRE><P>Or, using <CODE>Bio.SeqIO</CODE> instead (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>):</P><PRE CLASS="verbatim">from Bio import SeqIO
gb_record = SeqIO.read(open("AE017199.gbk"), "genbank")
print "Name %s, %i features" % (gb_record.name, len(gb_record.features))
print repr(gb_record.seq)
</PRE><P>Either should give the following output:</P><PRE CLASS="verbatim">Name AE017199, 1107 features
Seq('TCTCGCAGAGTTCTTTTTTGTATTAACAAACCCAAAACCCATAGAATTTAATGA...TTA', IUPACAmbiguousDNA())
</PRE><!--TOC subsection Iterating over GenBank records-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">9.2.3</A>&#XA0;&#XA0;Iterating over GenBank records</H3><!--SEC END --><P>
<A NAME="sec:gb-parsing-iterator"></A></P><P>For multi-record GenBank files, the most common usage will be creating an iterator, and parsing through the file record by record. Doing this is very similar to how things are done in other formats, as the following code demonstrates, using an example file <A HREF="http://biopython.org/SRC/biopython/Tests/GenBank/cor6_6.gb">cor6_6.gb</A> which is included in the BioPython source code under the Tests/GenBank/ directory:</P><PRE CLASS="verbatim">from Bio import GenBank
feature_parser = GenBank.FeatureParser()
gb_iterator = GenBank.Iterator(open("cor6_6.gb"), feature_parser)
for cur_record in gb_iterator :
   print "Name %s, %i features" % (cur_record.name, len(cur_record.features))
   print repr(cur_record.seq)
</PRE><P>Or, using <CODE>Bio.SeqIO</CODE> instead (see Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>):</P><PRE CLASS="verbatim">from Bio import SeqIO
for cur_record in SeqIO.parse(open("cor6_6.gb"), "genbank") :
   print "Name %s, %i features" % (cur_record.name, len(cur_record.features))
   print repr(cur_record.seq)
</PRE><P>This just iterates over a GenBank file, parsing it into SeqRecord and SeqFeature objects, and prints out the Seq objects representing the sequences in the record.</P><P>As with other formats, you have lots of tools for dealing with GenBank records. This should make it possible to do whatever you need to with GenBank.</P><!--TOC section Dealing with alignments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">9.3</A>&#XA0;&#XA0;Dealing with alignments</H2><!--SEC END --><P>It is often very useful to be able to align particular sequences. I do this quite often to get a quick and dirty idea of relationships between sequences. Consequently, it is very nice to be able to quickly write up a python script that does an alignment and gives you back objects that are easy to work with. The alignment related code in Biopython is meant to allow python-level access to alignment programs so that you can run alignments quickly from within scripts.</P><!--TOC subsection Clustalw-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc92">9.3.1</A>&#XA0;&#XA0;Clustalw</H3><!--SEC END --><P>
<A NAME="sec:align_clustal"></A></P><P>Clustalx (<A HREF="http://www-igbmc.u-strasbg.fr/BioInfo/ClustalX/Top.html"><TT>http://www-igbmc.u-strasbg.fr/BioInfo/ClustalX/Top.html</TT></A>) is a very nice program for doing multiple alignments. Biopython offers access to alignments in clustal format (these normally have a <CODE>*.aln</CODE> extension) that are produced by Clustalx. It also offers access to clustalw, which the is command line version of clustalx.</P><P>We&#X2019;ll need some sequences to align, such as <A HREF="examples/opuntia.fasta">opuntia.fasta</A> (also available online <A HREF="http://biopython.org/DIST/docs/tutorial/examples/opuntia.fasta">here</A>) which is a small FASTA file containing seven orchid gene DNA sequences, which you can also from <CODE>Doc/examples/</CODE> in the Biopython source distribution.</P><P>The first step in interacting with clustalw is to set up a command line you want to pass to the program. Clustalw has a ton of command line options, and if you set a lot of parameters, you can end up typing in a huge ol&#X2019; command line quite a bit. This command line class models the command line by making all of the options be attributes of the class that can be set. A few convenience functions also exist to set certain parameters, so that some error checking on the parameters can be done.</P><P>To create a command line object to do a clustalw multiple alignment we do the following:</P><PRE CLASS="verbatim">import os
from Bio.Clustalw import MultipleAlignCL

cline = MultipleAlignCL(os.path.join(os.curdir, "opuntia.fasta"))
cline.set_output("test.aln")
</PRE><P>First we import the <CODE>MultipleAlignCL</CODE> object, which models running a multiple alignment from clustalw. We then initialize the command line, with a single argument of the fasta file that we are going to be using for the alignment. The initialization function also takes an optional second argument which specifies the location of the <CODE>clustalw</CODE> executable. By default, the commandline will just be invoked with &#X2019;clustalw,&#X2019; assuming that you&#X2019;ve got it somewhere on your <CODE>PATH</CODE>.</P><P>The second argument sets the output to go to the file <CODE>test.aln</CODE>. The <CODE>MultipleAlignCL</CODE> object also has numerous other parameters to specify things like output format, gap costs, etc.</P><P>We can look at the command line we have generated by invoking the <CODE>__str__</CODE> member attribute of the <CODE>MultipleAlignCL</CODE> class. This is done by calling <CODE>str(cline)</CODE> or simple by printing out the command line with <CODE>print cline</CODE>. In this case, doing this would give the following output:</P><PRE CLASS="verbatim">clustalw ./opuntia.fasta -OUTFILE=test.aln
</PRE><P>Now that we&#X2019;ve set up a simple command line, we now want to run the commandline and collect the results so we can deal with them. This can be done using the <CODE>do_alignment</CODE> function of <CODE>Clustalw</CODE> as follows:</P><PRE CLASS="verbatim">from Bio import Clustalw

alignment = Clustalw.do_alignment(cline)
</PRE><P>What happens when you run this if that Biopython executes your command line and runs clustalw with the given parameters. It then grabs the output, and if it is in a format that Biopython can parse (currently only clustal format), then it will parse the results and return them as an alignment object of the appropriate type. So in this case since we are getting results in the default clustal format, the returned <CODE>alignment</CODE> object will be a <CODE>ClustalAlignment</CODE> type.</P><P>Once we&#X2019;ve got this alignment, we can do some interesting things with it such as get <CODE>seq_record</CODE> objects for all of the sequences involved in the alignment:</P><PRE CLASS="verbatim">all_records = alignment.get_all_seqs()

print "description:", all_records[0].description
print "sequence:", all_records[0].seq
</PRE><P>This prints out the description and sequence object for the first sequence in the alignment:</P><PRE CLASS="verbatim">description: gi|6273285|gb|AF191659.1|AF191
sequence: Seq('TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
...', IUPACAmbiguousDNA())
</PRE><P>You can also calculate the maximum length of the alignment with:</P><PRE CLASS="verbatim">length = alignment.get_alignment_length()
</PRE><P>Finally, to write out the alignment object in the original format, we just need to access the <CODE>__str__</CODE> function. So doing a <CODE>print alignment</CODE> gives:</P><PRE CLASS="verbatim">CLUSTAL X (1.81) multiple sequence alignment


gi|6273285|gb|AF191659.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
gi|6273284|gb|AF191658.1|AF191      TATACATTAAAGAAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAA
...
</PRE><P>This makes it easy to write your alignment back into a file with all of the original info intact.</P><P>If you want to do more interesting things with an alignment, the best thing to do is to pass the alignment to an alignment information generating object, such as the SummaryInfo object, described in section&#XA0;<A HREF="#sec:summary_info">9.3.2</A>.</P><!--TOC subsection Calculating summary information-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">9.3.2</A>&#XA0;&#XA0;Calculating summary information</H3><!--SEC END --><P>
<A NAME="sec:summary_info"></A></P><P>Once you have an alignment, you are very likely going to want to find out information about it. Instead of trying to have all of the functions that can generate information about an alignment in the alignment object itself, we&#X2019;ve tried to separate out the functionality into separate classes, which act on the alignment.</P><P>Getting ready to calculate summary information about an object is quick to do. Let&#X2019;s say we&#X2019;ve got an alignment object called <CODE>alignment</CODE>. All we need to do to get an object that will calculate summary information is:</P><PRE CLASS="verbatim">from Bio.Align import AlignInfo
summary_align = AlignInfo.SummaryInfo(alignment)
</PRE><P>The <CODE>summary_align</CODE> object is very useful, and will do the following neat things for you:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Calculate a quick consensus sequence &#X2013; see section&#XA0;<A HREF="#sec:consensus">9.3.3</A>
</LI><LI CLASS="li-enumerate">Get a position specific score matrix for the alignment &#X2013; see section&#XA0;<A HREF="#sec:pssm">9.3.4</A>
</LI><LI CLASS="li-enumerate">Calculate the information content for the alignment &#X2013; see section&#XA0;<A HREF="#sec:getting_info_content">9.3.5</A>
</LI><LI CLASS="li-enumerate">Generate information on substitutions in the alignment &#X2013; section&#XA0;<A HREF="#sec:sub_matrix">9.4</A> details using this to generate a substitution matrix.
</LI></OL><!--TOC subsection Calculating a quick consensus sequence-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">9.3.3</A>&#XA0;&#XA0;Calculating a quick consensus sequence</H3><!--SEC END --><P>
<A NAME="sec:consensus"></A></P><P>The <CODE>SummaryInfo</CODE> object, described in section&#XA0;<A HREF="#sec:summary_info">9.3.2</A>, provides functionality to calculate a quick consensus of an alignment. Assuming we&#X2019;ve got a <CODE>SummaryInfo</CODE> object called <CODE>summary_align</CODE> we can calculate a consensus by doing:</P><PRE CLASS="verbatim">consensus = summary_align.dumb_consensus()
</PRE><P>As the name suggests, this is a really simple consensus calculator, and will just add up all of the residues at each point in the consensus, and if the most common value is higher than some threshold value (the default is .3) will add the common residue to the consensus. If it doesn&#X2019;t reach the threshold, it adds an ambiguity character to the consensus. The returned consensus object is Seq object whose alphabet is inferred from the alphabets of the sequences making up the consensus. So doing a <CODE>print consensus</CODE> would give:</P><PRE CLASS="verbatim">consensus Seq('TATACATNAAAGNAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAAT
...', IUPACAmbiguousDNA())
</PRE><P>You can adjust how <CODE>dumb_consensus</CODE> works by passing optional parameters:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>the threshold</B></DT><DD CLASS="dd-description"> This is the threshold specifying how common a particular residue has to be at a position before it is added. The default is .7.</DD><DT CLASS="dt-description"><B>the ambiguous character</B></DT><DD CLASS="dd-description"> This is the ambiguity character to use. The default is &#X2019;N&#X2019;.</DD><DT CLASS="dt-description"><B>the consensus alphabet</B></DT><DD CLASS="dd-description"> This is the alphabet to use for the consensus sequence. If an alphabet is not specified than we will try to guess the alphabet based on the alphabets of the sequences in the alignment.
</DD></DL><!--TOC subsection Position Specific Score Matrices-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc95">9.3.4</A>&#XA0;&#XA0;Position Specific Score Matrices</H3><!--SEC END --><P>
<A NAME="sec:pssm"></A></P><P>Position specific score matrices (PSSMs) summarize the alignment information in a different way than a consensus, and may be useful for different tasks. Basically, a PSSM is a count matrix. For each column in the alignment, the number of each alphabet letters is counted and totaled. The totals are displayed relative to some representative sequence along the left axis. This sequence may be the consesus sequence, but can also be any sequence in the alignment. For instance for the alignment,</P><PRE CLASS="verbatim">GTATC
AT--C
CTGTC
</PRE><P>the PSSM is:</P><PRE CLASS="verbatim">      G A T C
    G 1 1 0 1
    T 0 0 3 0
    A 1 1 0 0
    T 0 0 2 0
    C 0 0 0 3
</PRE><P>Let&#X2019;s assume we&#X2019;ve got an alignment object called <CODE>c_align</CODE>. To get a PSSM with the consensus sequence along the side we first get a summary object and calculate the consensus sequence:</P><PRE CLASS="verbatim">summary_align = AlignInfo.SummaryInfo(c_align)
consensus = summary_align.dumb_consensus()
</PRE><P>Now, we want to make the PSSM, but ignore any <CODE>N</CODE> ambiguity residues when calculating this:</P><PRE CLASS="verbatim">my_pssm = summary_align.pos_specific_score_matrix(consensus,
                                                  chars_to_ignore = ['N'])
</PRE><P>Two notes should be made about this:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
To maintain strictness with the alphabets, you can only include characters along the top of the PSSM that are in the alphabet of the alignment object. Gaps are not included along the top axis of the PSSM.</LI><LI CLASS="li-enumerate">The sequence passed to be displayed along the left side of the axis does not need to be the consensus. For instance, if you wanted to display the second sequence in the alignment along this axis, you would need to do:<PRE CLASS="verbatim">second_seq = alignment.get_seq_by_num(1)
my_pssm = summary_align.pos_specific_score_matrix(second_seq
                                                  chars_to_ignore = ['N'])
</PRE></LI></OL><P>The command above returns a <CODE>PSSM</CODE> object. To print out the PSSM as we showed above, we simply need to do a <CODE>print my_pssm</CODE>, which gives:</P><PRE CLASS="verbatim">    A   C   G   T
T  0.0 0.0 0.0 7.0
A  7.0 0.0 0.0 0.0
T  0.0 0.0 0.0 7.0
A  7.0 0.0 0.0 0.0
C  0.0 7.0 0.0 0.0
A  7.0 0.0 0.0 0.0
T  0.0 0.0 0.0 7.0
T  1.0 0.0 0.0 6.0
...
</PRE><P>You can access any element of the PSSM by subscripting like <CODE>your_pssm[sequence_number][residue_count_name]</CODE>. For instance, to get the counts for the &#X2019;A&#X2019; residue in the second element of the above PSSM you would do:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print my_pssm[1]["A"]
7.0
</PRE><P>The structure of the PSSM class hopefully makes it easy both to access elements and to pretty print the matrix.</P><!--TOC subsection Information Content-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc96">9.3.5</A>&#XA0;&#XA0;Information Content</H3><!--SEC END --><P>
<A NAME="sec:getting_info_content"></A></P><P>A potentially useful measure of evolutionary conservation is the information content of a sequence.</P><P>A useful introduction to information theory targetted towards molecular biologists can be found at <A HREF="http://www.lecb.ncifcrf.gov/~toms/paper/primer/"><TT>http://www.lecb.ncifcrf.gov/~toms/paper/primer/</TT></A>. For our purposes, we will be looking at the information content of a consesus sequence, or a portion of a consensus sequence. We calculate information content at a particular column in a multiple sequence alignment using the following formula:</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>IC</I><SUB><I>j</I></SUB>&#XA0;=&#XA0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>a</I></SUB></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#XA0;<I>P</I><SUB><I>ij</I></SUB>&#XA0;<I>log</I></TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>ij</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Q</I><SUB><I>i</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>where:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>IC</I><SUB><I>j</I></SUB> &#X2013; The information content for the <I>j</I>-th column in an alignment.
</LI><LI CLASS="li-itemize"><I>N</I><SUB><I>a</I></SUB> &#X2013; The number of letters in the alphabet.
</LI><LI CLASS="li-itemize"><I>P</I><SUB><I>ij</I></SUB> &#X2013; The frequency of a particular letter <I>i</I> in the <I>j</I>-th column (i.&#XA0;e.&#XA0;if G occured 3 out of 6 times in an aligment column, this would be 0.5)
</LI><LI CLASS="li-itemize"><I>Q</I><SUB><I>i</I></SUB> &#X2013; The expected frequency of a letter <I>i</I>. This is an
optional argument, usage of which is left at the user&#X2019;s
discretion. By default, it is automatically assigned to 0.05 = 1/20 for a
protein alphabet, and 0.25 = 1/4 for a nucleic acid alphabet. This is for
geting the information content without any assumption of prior
distribtions. When assuming priors, or when using a non-standard
alphabet, you should supply the values for <I>Q</I><SUB><I>i</I></SUB>.
</LI></UL><P>Well, now that we have an idea what information content is being calculated in Biopython, let&#X2019;s look at how to get it for a particular region of the alignment.</P><P>First, we need to use our alignment to get a alignment summary object, which we&#X2019;ll assume is called <CODE>summary_align</CODE> (see section&#XA0;<A HREF="#sec:summary_info">9.3.2</A>) for instructions on how to get this. Once we&#X2019;ve got this object, calculating the information content for a region is as easy as:</P><PRE CLASS="verbatim">info_content = summary_align.information_content(5, 30,
                                                 chars_to_ignore = ['N'])
</PRE><P>Wow, that was much easier then the formula above made it look! The variable <CODE>info_content</CODE> now contains a float value specifying the information content over the specified region (from 5 to 30 of the alignment). We specifically ignore the ambiguity residue &#X2019;N&#X2019; when calculating the information content, since this value is not included in our alphabet (so we shouldn&#X2019;t be interested in looking at it!).</P><P>As mentioned above, we can also calculate relative information content by supplying the expected frequencies:</P><PRE CLASS="verbatim">expect_freq = {
    'A' : .3,
    'G' : .2,
    'T' : .3,
    'C' : .2}
</PRE><P>The expected should not be passed as a raw dictionary, but instead by passed as a <CODE>SubsMat.FreqTable</CODE> object (see section&#XA0;<A HREF="#sec:freq_table">10.4.2</A> for more information about FreqTables). The FreqTable object provides a standard for associating the dictionary with an Alphabet, similar to how the Biopython Seq class works.</P><P>To create a FreqTable object, from the frequency dictionary you just need to do:</P><PRE CLASS="verbatim">from Bio.Alphabet import IUPAC
from Bio.SubsMat import FreqTable

e_freq_table = FreqTable.FreqTable(expect_freq, FreqTable.FREQ,
                                   IUPAC.unambiguous_dna)
</PRE><P>Now that we&#X2019;ve got that, calculating the relative information content for our region of the alignment is as simple as:</P><PRE CLASS="verbatim">info_content = summary_align.information_content(5, 30,
                                                 e_freq_table = e_freq_table,
                                                 chars_to_ignore = ['N'])
</PRE><P>Now, <CODE>info_content</CODE> will contain the relative information content over the region in relation to the expected frequencies.</P><P>The value return is calculated using base 2 as the logarithm base in the formula above. You can modify this by passing the parameter <CODE>log_base</CODE> as the base you want:</P><PRE CLASS="verbatim">info_content = summary_align.information_content(5, 30, log_base = 10
                                                 chars_to_ignore = ['N'])
</PRE><P>Well, now you are ready to calculate information content. If you want to try applying this to some real life problems, it would probably be best to dig into the literature on information content to get an idea of how it is used. Hopefully your digging won&#X2019;t reveal any mistakes made in coding this function!</P><!--TOC subsection Translating between Alignment formats-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc97">9.3.6</A>&#XA0;&#XA0;Translating between Alignment formats</H3><!--SEC END --><P>One thing that you always end up having to do is convert between different formats.
You can do this using the <CODE>Bio.AlignIO</CODE> module, see Section&#XA0;<A HREF="#sec:converting-alignments">5.2.1</A>.</P><!--TOC section Substitution Matrices-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc98">9.4</A>&#XA0;&#XA0;Substitution Matrices</H2><!--SEC END --><P>
<A NAME="sec:sub_matrix"></A></P><P>Substitution matrices are an extremely important part of everyday bioinformatics work. They provide the scoring terms for classifying how likely two different residues are to substitute for each other. This is essential in doing sequence comparisons. The book &#X201C;Biological Sequence Analysis&#X201D; by Durbin et al. provides a really nice introduction to Substitution Matrices and their uses. Some famous substitution matrices are the PAM and BLOSUM series of matrices.</P><P>Biopython provides a ton of common substitution matrices, and also provides functionality for creating your own substitution matrices.</P><!--TOC subsection Using common substitution matrices-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc99">9.4.1</A>&#XA0;&#XA0;Using common substitution matrices</H3><!--SEC END --><!--TOC subsection Creating your own substitution matrix from an alignment-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc100">9.4.2</A>&#XA0;&#XA0;Creating your own substitution matrix from an alignment</H3><!--SEC END --><P>
<A NAME="sec:subs_mat_ex"></A></P><P>A very cool thing that you can do easily with the substitution matrix
classes is to create your own substitution matrix from an
alignment. In practice, this is normally done with protein
alignments. In this example, we&#X2019;ll first get a biopython alignment
object and then get a summary object to calculate info about the
alignment. The file containing <A HREF="examples/protein.aln">protein.aln</A>
(also available online
<A HREF="http://biopython.org/DIST/docs/tutorial/examples/protein.aln">here</A>)
contains the Clustalw alignment output.</P><PRE CLASS="verbatim">from Bio import Clustalw
from Bio.Alphabet import IUPAC
from Bio.Align import AlignInfo

# get an alignment object from a Clustalw alignment output
c_align = Clustalw.parse_file("protein.aln", IUPAC.protein)
summary_align = AlignInfo.SummaryInfo(c_align)
</PRE><P>Sections&#XA0;<A HREF="#sec:align_clustal">9.3.1</A> and&#XA0;<A HREF="#sec:summary_info">9.3.2</A> contain
more information on doing this.</P><P>Now that we&#X2019;ve got our <CODE>summary_align</CODE> object, we want to use it
to find out the number of times different residues substitute for each
other. To make the example more readable, we&#X2019;ll focus on only amino
acids with polar charged side chains. Luckily, this can be done easily
when generating a replacement dictionary, by passing in all of the
characters that should be ignored. Thus we&#X2019;ll create a dictionary of
replacements for only charged polar amino acids using:</P><PRE CLASS="verbatim">replace_info = summary_align.replacement_dictionary(["G", "A", "V", "L", "I",
                                                     "M", "P", "F", "W", "S",
                                                     "T", "N", "Q", "Y", "C"])
</PRE><P>This information about amino acid replacements is represented as a
python dictionary which will look something like:</P><PRE CLASS="verbatim">{('R', 'R'): 2079.0, ('R', 'H'): 17.0, ('R', 'K'): 103.0, ('R', 'E'): 2.0,
('R', 'D'): 2.0, ('H', 'R'): 0, ('D', 'H'): 15.0, ('K', 'K'): 3218.0,
('K', 'H'): 24.0, ('H', 'K'): 8.0, ('E', 'H'): 15.0, ('H', 'H'): 1235.0,
('H', 'E'): 18.0, ('H', 'D'): 0, ('K', 'D'): 0, ('K', 'E'): 9.0,
('D', 'R'): 48.0, ('E', 'R'): 2.0, ('D', 'K'): 1.0, ('E', 'K'): 45.0,
('K', 'R'): 130.0, ('E', 'D'): 241.0, ('E', 'E'): 3305.0,
('D', 'E'): 270.0, ('D', 'D'): 2360.0}
</PRE><P>This information gives us our accepted number of replacements, or how
often we expect different things to substitute for each other. It
turns out, amazingly enough, that this is all of the information we
need to go ahead and create a substitution matrix. First, we use the
replacement dictionary information to create an Accepted Replacement
Matrix (ARM):</P><PRE CLASS="verbatim">from Bio import SubsMat
my_arm = SubsMat.SeqMat(replace_info)
</PRE><P>With this accepted replacement matrix, we can go right ahead and
create our log odds matrix (i.&#XA0;e.&#XA0;a standard type Substitution Matrix):</P><PRE CLASS="verbatim">my_lom = SubsMat.make_log_odds_matrix(my_arm)
</PRE><P>The log odds matrix you create is customizable with the following
optional arguments:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>exp_freq_table</CODE> &#X2013; You can pass a table of expected
frequencies for each alphabet. If supplied, this will be used
instead of the passed accepted replacement matrix when calculate
expected replacments.</LI><LI CLASS="li-itemize"><CODE>logbase</CODE> - The base of the logarithm taken to create the
log odd matrix. Defaults to base 10.</LI><LI CLASS="li-itemize"><CODE>factor</CODE> - The factor to multiply each matrix entry
by. This defaults to 10, which normally makes the matrix numbers
easy to work with.</LI><LI CLASS="li-itemize"><CODE>round_digit</CODE> - The digit to round to in the matrix. This
defaults to 0 (i.&#XA0;e.&#XA0;no digits).</LI></UL><P>Once you&#X2019;ve got your log odds matrix, you can display it prettily
using the function <CODE>print_mat</CODE>. Doing this on our created matrix
gives:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_lom.print_mat()
D   6
E  -5   5
H -15 -13  10
K -31 -15 -13   6
R -13 -25 -14  -7   7
   D   E   H   K   R
</PRE><P>Very nice. Now we&#X2019;ve got our very own substitution matrix to play with!</P><!--TOC section BioSQL &#X2013; storing sequences in a relational database-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc101">9.5</A>&#XA0;&#XA0;BioSQL &#X2013; storing sequences in a relational database</H2><!--SEC END --><P>
<A NAME="sec:BioSQL"></A>
<A HREF="http://www.biosql.org/">BioSQL</A> is a joint effort between the
<A HREF="http://open-bio.org/">OBF</A> projects (BioPerl, BioJava etc) to support a
shared database schema for storing sequence data. In theory, you could load a
GenBank file into the database with BioPerl, then using Biopython extract this
from the database as a record object with featues - and get more or less the same
thing as if you had loaded the GenBank file directly as a SeqRecord using
<CODE>Bio.SeqIO</CODE> (Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>).</P><P>Biopython&#X2019;s BioSQL module is currently documented at
<A HREF="http://biopython.org/wiki/BioSQL"><TT>http://biopython.org/wiki/BioSQL</TT></A> which is part of our wiki pages.</P><!--TOC section BioCorba-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc102">9.6</A>&#XA0;&#XA0;BioCorba</H2><!--SEC END --><P>Biocorba does some cool stuff with CORBA. Basically, it allows you to easily interact with code written in other languages, including Perl and Java. This is all done through an interface which is very similar to the standard biopython interface. Much work has been done to make it easy to use knowing only very little about CORBA. You should check out the biocorba specific documentation, which describes in detail how to use it.</P><!--TOC section Going 3D: The PDB module-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc103">9.7</A>&#XA0;&#XA0;Going 3D: The PDB module</H2><!--SEC END --><P>Biopython also allows you to explore the extensive realm of macromolecular structure.
Biopython comes with a PDBParser class that produces a Structure object. The Structure object
can be used to access the atomic data in the file in a convenient manner.</P><!--TOC subsection Structure representation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc104">9.7.1</A>&#XA0;&#XA0;Structure representation</H3><!--SEC END --><P>A macromolecular structure is represented using a structure, model chain,
residue, atom (or SMCRA) hierarchy. Fig. <A HREF="#fig:smcra">9.7.1</A> shows a UML
class diagram of the SMCRA data structure. Such a data structure is not
necessarily best suited for the representation of the macromolecular content of
a structure, but it is absolutely necessary for a good interpretation of the
data present in a file that describes the structure (typically a PDB or MMCIF
file). If this hierarchy cannot represent the contents of a structure file, it
is fairly certain that the file contains an error or at least does not describe
the structure unambiguously. If a SMCRA data structure cannot be generated,
there is reason to suspect a problem. Parsing a PDB file can thus be used to
detect likely problems. We will give several examples of this in section
<A HREF="#problem structures">9.7.5.1</A>.</P><P>
<A NAME="fig:smcra"></A>
<IMG SRC="images/smcra.png" width=650, height=750>
</P><P>Structure, Model, Chain and Residue are all subclasses of the Entity base class.
The Atom class only (partly) implements the Entity interface (because an Atom
does not have children).</P><P>For each Entity subclass, you can extract a child by using a unique id for that
child as a key (e.g. you can extract an Atom object from a Residue object by
using an atom name string as a key, you can extract a Chain object from a Model
object by using its chain identifier as a key).</P><P>Disordered atoms and residues are represented by DisorderedAtom and DisorderedResidue
classes, which are both subclasses of the DisorderedEntityWrapper base class.
They hide the complexity associated with disorder and behave exactly as Atom
and Residue objects.</P><P>In general, a child Entity object (i.e. Atom, Residue, Chain, Model) can be
extracted from its parent (i.e. Residue, Chain, Model, Structure, respectively)
by using an id as a key.</P><PRE CLASS="verbatim">child_entity=parent_entity[child_id]
</PRE><P>You can also get a list of all child Entities of a parent Entity object. Note
that this list is sorted in a specific way (e.g. according to chain identifier
for Chain objects in a Model object).</P><PRE CLASS="verbatim">child_list=parent_entity.get_list()
</PRE><P>You can also get the parent from a child.</P><PRE CLASS="verbatim">parent_entity=child_entity.get_parent()
</PRE><P>At all levels of the SMCRA hierarchy, you can also extract a <EM>full id</EM>.
The full id is a tuple containing all id&#X2019;s starting from the top object (Structure)
down to the current object. A full id for a Residue object e.g. is something
like:</P><PRE CLASS="verbatim">full_id=residue.get_full_id()

print full_id

("1abc", 0, "A", ("", 10, "A"))
</PRE><P>This corresponds to:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The Structure with id "1abc"
</LI><LI CLASS="li-itemize">The Model with id 0
</LI><LI CLASS="li-itemize">The Chain with id "A"
</LI><LI CLASS="li-itemize">The Residue with id (" ", 10, "A").
</LI></UL><P>
The Residue id indicates that the residue is not a hetero-residue (nor a water)
because it has a blanc hetero field, that its sequence identifier is 10 and
that its insertion code is "A".</P><P>Some other useful methods:</P><PRE CLASS="verbatim"># get the entity's id

entity.get_id()

# check if there is a child with a given id

entity.has_id(entity_id)

# get number of children

nr_children=len(entity)
</PRE><P>It is possible to delete, rename, add, etc. child entities from a parent entity,
but this does not include any sanity checks (e.g. it is possible to add two
residues with the same id to one chain). This really should be done via a nice
Decorator class that includes integrity checking, but you can take a look at
the code (Entity.py) if you want to use the raw interface.</P><!--TOC subsubsection Structure-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.1.1&#XA0;&#XA0;Structure</H4><!--SEC END --><P>The Structure object is at the top of the hierarchy. Its id is a user given
string. The Structure contains a number of Model children. Most crystal structures
(but not all) contain a single model, while NMR structures typically consist
of several models. Disorder in crystal structures of large parts of molecules
can also result in several models.</P><!--TOC paragraph Constructing a Structure object-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.1.1.1&#XA0;&#XA0;Constructing a Structure object</H5><!--SEC END --><P>A Structure object is produced by a PDBParser object:</P><PRE CLASS="verbatim">from Bio.PDB.PDBParser import PDBParser

p=PDBParser(PERMISSIVE=1)

structure_id="1fat"

filename="pdb1fat.ent"

s=p.get_structure(structure_id, filename)
</PRE><P>The <TT>PERMISSIVE</TT> flag indicates that a number of common problems (see <A HREF="#problem structures">9.7.5.1</A>)
associated with PDB files will be ignored (but note that some atoms and/or residues
will be missing). If the flag is not present a <TT>PDBConstructionException</TT>
will be generated during the parse operation.</P><!--TOC paragraph Header and trailer-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.1.1.2&#XA0;&#XA0;Header and trailer</H5><!--SEC END --><P>You can extract the header and trailer (simple lists of strings) of the PDB
file from the PDBParser object with the <TT>get_header</TT> and <TT>get_trailer</TT>
methods.</P><!--TOC subsubsection Model-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.1.2&#XA0;&#XA0;Model</H4><!--SEC END --><P>The id of the Model object is an integer, which is derived from the position
of the model in the parsed file (they are automatically numbered starting from
0). The Model object stores a list of Chain children.</P><!--TOC paragraph Example-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.1.2.1&#XA0;&#XA0;Example</H5><!--SEC END --><P>Get the first model from a Structure object.</P><PRE CLASS="verbatim">first_model=structure[0]
</PRE><!--TOC subsubsection Chain-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.1.3&#XA0;&#XA0;Chain</H4><!--SEC END --><P>The id of a Chain object is derived from the chain identifier in the structure
file, and can be any string. Each Chain in a Model object has a unique id. The
Chain object stores a list of Residue children.</P><!--TOC paragraph Example-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.1.3.1&#XA0;&#XA0;Example</H5><!--SEC END --><P>Get the Chain object with identifier &#X201C;A&#X201D; from a Model object.</P><PRE CLASS="verbatim">chain_A=model["A"]
</PRE><!--TOC subsubsection Residue-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.1.4&#XA0;&#XA0;Residue</H4><!--SEC END --><P>Unsurprisingly, a Residue object stores a set of Atom children. In addition,
it also contains a string that specifies the residue name (e.g. &#X201C;ASN&#X201D;)
and the segment identifier of the residue (well known to X-PLOR users, but not
used in the construction of the SMCRA data structure).</P><P>The id of a Residue object is composed of three parts: the hetero field (hetfield),
the sequence identifier (resseq) and the insertion code (icode).</P><P>The hetero field is a string : it is &#X201C;W&#X201D; for waters, &#X201C;H_&#X201D; followed
by the residue name (e.g. &#X201C;H_FUC&#X201D;) for other hetero residues and blank
for standard amino and nucleic acids. This scheme is adopted for reasons described
in section <A HREF="#hetero probems">9.7.3.1</A>.</P><P>The second field in the Residue id is the sequence identifier, an integer describing
the position of the residue in the chain.</P><P>The third field is a string, consisting of the insertion code. The insertion
code is sometimes used to preserve a certain desirable residue numbering scheme.
A Ser 80 insertion mutant (inserted e.g. between a Thr 80 and an Asn 81 residue)
could e.g. have sequence identifiers and insertion codes as followed: Thr 80
A, Ser 80 B, Asn 81. In this way the residue numbering scheme stays in tune
with that of the wild type structure.</P><P>Let&#X2019;s give some examples. Asn 10 with a blank insertion code would have residue
id <TT>(&#X2019;&#X2019; &#X2019;&#X2019;, 10, &#X2019;&#X2019; &#X2019;&#X2019;)</TT>. Water 10 would have residue id <TT>(&#X2018;&#X2018;W&#X2018;&#X2018;, 10, &#X2018;&#X2018; &#X2018;&#X2018;)</TT>.
A glucose molecule (a hetero residue with residue name GLC) with sequence identifier
10 would have residue id <TT>(&#X2019;&#X2019;H_GLC&#X2019;&#X2019;, 10, &#X2019;&#X2019; &#X2019;&#X2019;)</TT>. In this way, the three
residues (with the same insertion code and sequence identifier) can be part
of the same chain because their residue id&#X2019;s are distinct.</P><P>In most cases, the hetflag and insertion code fields will be blank, e.g. <TT>(&#X2019;&#X2019; &#X2019;&#X2019;, 10, &#X2019;&#X2019; &#X2019;&#X2019;)</TT>.
In these cases, the sequence identifier can be used as a shortcut for the full
id:</P><PRE CLASS="verbatim"># use full id

res10=chain[("", 10, "")]

# use shortcut

res10=chain[10]
</PRE><P>Each Residue object in a Chain object should have a unique id. However, disordered
residues are dealt with in a special way, as described in section <A HREF="#point mutations">9.7.2.3.2</A>.</P><P>A Residue object has a number of additional methods:</P><PRE CLASS="verbatim">r.get_resname()  # return residue name, e.g. "ASN"
r.get_segid()  # return the SEGID, e.g. "CHN1"
</PRE><!--TOC subsubsection Atom-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.1.5&#XA0;&#XA0;Atom</H4><!--SEC END --><P>The Atom object stores the data associated with an atom, and has no children.
The id of an atom is its atom name (e.g. &#X201C;OG&#X201D; for the side chain oxygen
of a Ser residue). An Atom id needs to be unique in a Residue. Again, an exception
is made for disordered atoms, as described in section <A HREF="#disordered atoms">9.7.2.2</A>.</P><P>In a PDB file, an atom name consists of 4 chars, typically with leading and
trailing spaces. Often these spaces can be removed for ease of use (e.g. an
amino acid C &#X3B1;  atom is labeled &#X201C;.CA.&#X201D; in a PDB file, where
the dots represent spaces). To generate an atom name (and thus an atom id) the
spaces are removed, unless this would result in a name collision in a Residue
(i.e. two Atom objects with the same atom name and id). In the latter case,
the atom name including spaces is tried. This situation can e.g. happen when
one residue contains atoms with names &#X201C;.CA.&#X201D; and &#X201C;CA..&#X201D;, although
this is not very likely.</P><P>The atomic data stored includes the atom name, the atomic coordinates (including
standard deviation if present), the B factor (including anisotropic B factors
and standard deviation if present), the altloc specifier and the full atom name
including spaces. Less used items like the atom element number or the atomic
charge sometimes specified in a PDB file are not stored.</P><P>An Atom object has the following additional methods:</P><PRE CLASS="verbatim">a.get_name()       # atom name (spaces stripped, e.g. "CA")
a.get_id()         # id (equals atom name)
a.get_coord()      # atomic coordinates
a.get_bfactor()    # B factor
a.get_occupancy()  # occupancy
a.get_altloc()     # alternative location specifie
a.get_sigatm()     # std. dev. of atomic parameters
a.get_siguij()     # std. dev. of anisotropic B factor
a.get_anisou()     # anisotropic B factor
a.get_fullname()   # atom name (with spaces, e.g. ".CA.")
</PRE><P>To represent the atom coordinates, siguij, anisotropic B factor and sigatm Numpy
arrays are used.</P><!--TOC subsection Disorder-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc105">9.7.2</A>&#XA0;&#XA0;Disorder</H3><!--SEC END --><!--TOC subsubsection General approach-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.2.1&#XA0;&#XA0;General approach<A NAME="disorder problems"></A></H4><!--SEC END --><P>Disorder should be dealt with from two points of view: the atom and the residue
points of view. In general, we have tried to encapsulate all the complexity that
arises from disorder. If you just want to loop over all C &#X3B1;  atoms,
you do not care that some residues have a disordered side chain. On the other
hand it should also be possible to represent disorder completely in the data
structure. Therefore, disordered atoms or residues are stored in special objects
that behave as if there is no disorder. This is done by only representing a
subset of the disordered atoms or residues. Which subset is picked (e.g. which
of the two disordered OG side chain atom positions of a Ser residue is used)
can be specified by the user.</P><!--TOC subsubsection Disordered atoms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.2.2&#XA0;&#XA0;Disordered atoms<A NAME="disordered atoms"></A></H4><!--SEC END --><P>Disordered atoms are represented by ordinary Atom objects, but all Atom objects
that represent the same physical atom are stored in a DisorderedAtom object.
Each Atom object in a DisorderedAtom object can be uniquely indexed using its
altloc specifier. The DisorderedAtom object forwards all uncaught method calls
to the selected Atom object, by default the one that represents the atom with
with the highest occupancy. The user can of course change the selected Atom
object, making use of its altloc specifier. In this way atom disorder is represented
correctly without much additional complexity. In other words, if you are not
interested in atom disorder, you will not be bothered by it.</P><P>Each disordered atom has a characteristic altloc identifier. You can specify
that a DisorderedAtom object should behave like the Atom object associated with
a specific altloc identifier:</P><PRE CLASS="verbatim">atom.disordered\_select("A")  # select altloc A atom

print atom.get_altloc()
"A"

atom.disordered_select("B")     # select altloc B atom
print atom.get_altloc()
"B"
</PRE><!--TOC subsubsection Disordered residues-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.2.3&#XA0;&#XA0;Disordered residues</H4><!--SEC END --><!--TOC paragraph Common case-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.2.3.1&#XA0;&#XA0;Common case</H5><!--SEC END --><P>The most common case is a residue that contains one or more disordered atoms.
This is evidently solved by using DisorderedAtom objects to represent the disordered
atoms, and storing the DisorderedAtom object in a Residue object just like ordinary
Atom objects. The DisorderedAtom will behave exactly like an ordinary atom (in
fact the atom with the highest occupancy) by forwarding all uncaught method
calls to one of the Atom objects (the selected Atom object) it contains.</P><!--TOC paragraph Point mutations-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.2.3.2&#XA0;&#XA0;Point mutations<A NAME="point mutations"></A></H5><!--SEC END --><P>A special case arises when disorder is due to a point mutation, i.e. when two
or more point mutants of a polypeptide are present in the crystal. An example
of this can be found in PDB structure 1EN2.</P><P>Since these residues belong to a different residue type (e.g. let&#X2019;s say Ser
60 and Cys 60) they should not be stored in a single Residue object as in the
common case. In this case, each residue is represented by one Residue object,
and both Residue objects are stored in a DisorderedResidue object.</P><P>The DisorderedResidue object forwards all uncaught methods to the selected Residue
object (by default the last Residue object added), and thus behaves like an
ordinary residue. Each Residue object in a DisorderedResidue object can be uniquely
identified by its residue name. In the above example, residue Ser 60 would have
id &#X201C;SER&#X201D; in the DisorderedResidue object, while residue Cys 60 would
have id &#X201C;CYS&#X201D;. The user can select the active Residue object in a DisorderedResidue
object via this id.</P><!--TOC subsection Hetero residues-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc106">9.7.3</A>&#XA0;&#XA0;Hetero residues</H3><!--SEC END --><!--TOC subsubsection Associated problems-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.3.1&#XA0;&#XA0;Associated problems<A NAME="hetero probems"></A></H4><!--SEC END --><P>A common problem with hetero residues is that several hetero and non-hetero
residues present in the same chain share the same sequence identifier (and insertion
code). Therefore, to generate a unique id for each hetero residue, waters and
other hetero residues are treated in a different way.</P><P>Remember that Residue object have the tuple (hetfield, resseq, icode) as id.
The hetfield is blank (&#X201C; &#X201C;) for amino and nucleic acids, and a string
for waters and other hetero residues. The content of the hetfield is explained
below.</P><!--TOC subsubsection Water residues-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.3.2&#XA0;&#XA0;Water residues</H4><!--SEC END --><P>The hetfield string of a water residue consists of the letter &#X201C;W&#X201D;. So
a typical residue id for a water is (&#X201C;W&#X201D;, 1, &#X201C; &#X201C;).</P><!--TOC subsubsection Other hetero residues-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.3.3&#XA0;&#XA0;Other hetero residues</H4><!--SEC END --><P>The hetfield string for other hetero residues starts with &#X201C;H_&#X201D; followed
by the residue name. A glucose molecule e.g. with residue name &#X201C;GLC&#X201D;
would have hetfield &#X201C;H_GLC&#X201D;. It&#X2019;s residue id could e.g. be (&#X201C;H_GLC&#X201D;,
1, &#X201C; &#X201C;).</P><!--TOC subsection Some random usage examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc107">9.7.4</A>&#XA0;&#XA0;Some random usage examples</H3><!--SEC END --><P>Parse a PDB file, and extract some Model, Chain, Residue and Atom objects.</P><PRE CLASS="verbatim">from PDBParser import PDBParser

parser=PDBParser()

structure=parser.get_structure("test", "1fat.pdb")
model=structure[0]
chain=model["A"]
residue=chain[1]
atom=residue["CA"]
</PRE><P>Extract a hetero residue from a chain (e.g. a glucose (GLC) moiety with resseq
10).</P><PRE CLASS="verbatim">residue_id=("H_GLC", 10, " ")
residue=chain[residue_id]
</PRE><P>Print all hetero residues in chain.</P><PRE CLASS="verbatim">for residue in chain.get_list():
 residue_id=residue.get_id()
 hetfield=residue_id[0]
 if hetfield[0]=="H":
  print residue_id
</PRE><P>Print out the coordinates of all CA atoms in a structure with B factor greater
than 50.</P><PRE CLASS="verbatim">for model in structure.get_list():
  for chain in model.get_list():
    for residue in chain.get_list():
      if residue.has_id("CA"):
        ca=residue["CA"]
        if ca.get_bfactor()&gt;50.0:
          print ca.get_coord()
</PRE><P>Print out all the residues that contain disordered atoms.</P><PRE CLASS="verbatim">for model in structure.get_list()
  for chain in model.get_list():
    for residue in chain.get_list():
      if residue.is_disordered():
        resseq=residue.get_id()[1]
        resname=residue.get_resname()
        model_id=model.get_id()
        chain_id=chain.get_id()
        print model_id, chain_id, resname, resseq
</PRE><P>Loop over all disordered atoms, and select all atoms with altloc A (if present).
This will make sure that the SMCRA data structure will behave as if only the
atoms with altloc A are present.</P><PRE CLASS="verbatim">for model in structure.get_list()
  for chain in model.get_list():
    for residue in chain.get_list():
      if residue.is_disordered():
        for atom in residue.get_list():
          if atom.is_disordered():
            if atom.disordered_has_id("A"):
              atom.disordered_select("A")
</PRE><P>Suppose that a chain has a point mutation at position 10, consisting of a Ser
and a Cys residue. Make sure that residue 10 of this chain behaves as the Cys
residue.</P><PRE CLASS="verbatim">residue=chain[10]
residue.disordered_select("CYS")
</PRE><!--TOC subsection Common problems in PDB files-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc108">9.7.5</A>&#XA0;&#XA0;Common problems in PDB files</H3><!--SEC END --><!--TOC subsubsection Examples-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.5.1&#XA0;&#XA0;Examples<A NAME="problem structures"></A></H4><!--SEC END --><P>The PDBParser/Structure class was tested on about 800 structures (each belonging
to a unique SCOP superfamily). This takes about 20 minutes, or on average 1.5
seconds per structure. Parsing the structure of the large ribosomal subunit
(1FKK), which contains about 64000 atoms, takes 10 seconds on a 1000 MHz PC.</P><P>Three exceptions were generated in cases where an unambiguous data structure
could not be built. In all three cases, the likely cause is an error in the
PDB file that should be corrected. Generating an exception in these cases
is much better than running the chance of incorrectly describing
the structure in a data structure.</P><!--TOC paragraph Duplicate residues-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.5.1.1&#XA0;&#XA0;Duplicate residues</H5><!--SEC END --><P>One structure contains two amino acid residues in one chain with the same sequence
identifier (resseq 3) and icode. Upon inspection it was found that this chain
contains the residues Thr A3, &#X2026;, Gly A202, Leu A3, Glu A204. Clearly,
Leu A3 should be Leu A203. A couple of similar situations exist for structure
1FFK (which e.g. contains Gly B64, Met B65, Glu B65, Thr B67, i.e. residue Glu
B65 should be Glu B66).</P><!--TOC paragraph Duplicate atoms-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.5.1.2&#XA0;&#XA0;Duplicate atoms</H5><!--SEC END --><P>Structure 1EJG contains a Ser/Pro point mutation in chain A at position 22.
In turn, Ser 22 contains some disordered atoms. As expected, all atoms belonging
to Ser 22 have a non-blank altloc specifier (B or C). All atoms of Pro 22 have
altloc A, except the N atom which has a blank altloc. This generates an exception,
because all atoms belonging to two residues at a point mutation should have
non-blank altloc. It turns out that this atom is probably shared by Ser and
Pro 22, as Ser 22 misses the N atom. Again, this points to a problem in the
file: the N atom should be present in both the Ser and the Pro residue, in both
cases associated with a suitable altloc identifier.</P><!--TOC subsubsection Automatic correction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.5.2&#XA0;&#XA0;Automatic correction</H4><!--SEC END --><P>Some errors are quite common and can be easily corrected without much risk of
making a wrong interpretation. These cases are listed below.</P><!--TOC paragraph A blank altloc for a disordered atom-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.5.2.1&#XA0;&#XA0;A blank altloc for a disordered atom</H5><!--SEC END --><P>Normally each disordered atom should have a non-blanc altloc identifier. However,
there are many structures that do not follow this convention, and have a blank
and a non-blank identifier for two disordered positions of the same atom. This
is automatically interpreted in the right way.</P><!--TOC paragraph Broken chains-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.5.2.2&#XA0;&#XA0;Broken chains</H5><!--SEC END --><P>Sometimes a structure contains a list of residues belonging to chain A, followed
by residues belonging to chain B, and again followed by residues belonging to
chain A, i.e. the chains are &#X201C;broken&#X201D;. This is correctly interpreted.</P><!--TOC subsubsection Fatal errors-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.7.5.3&#XA0;&#XA0;Fatal errors</H4><!--SEC END --><P>Sometimes a PDB file cannot be unambiguously interpreted. Rather than guessing
and risking a mistake, an exception is generated, and the user is expected to
correct the PDB file. These cases are listed below.</P><!--TOC paragraph Duplicate residues-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.5.3.1&#XA0;&#XA0;Duplicate residues</H5><!--SEC END --><P>All residues in a chain should have a unique id. This id is generated based
on:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The sequence identifier (resseq).
</LI><LI CLASS="li-itemize">The insertion code (icode).
</LI><LI CLASS="li-itemize">The hetfield string (&#X201C;W&#X201D; for waters and &#X201C;H_&#X201D; followed by the
residue name for other hetero residues)
</LI><LI CLASS="li-itemize">The residue names of the residues in the case of point mutations (to store the
Residue objects in a DisorderedResidue object).
</LI></UL><P>
If this does not lead to a unique id something is quite likely wrong, and an
exception is generated.</P><!--TOC paragraph Duplicate atoms-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.7.5.3.2&#XA0;&#XA0;Duplicate atoms</H5><!--SEC END --><P>All atoms in a residue should have a unique id. This id is generated based on:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The atom name (without spaces, or with spaces if a problem arises).
</LI><LI CLASS="li-itemize">The altloc specifier.
</LI></UL><P>
If this does not lead to a unique id something is quite likely wrong, and an
exception is generated.</P><!--TOC subsection Other features-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc109">9.7.6</A>&#XA0;&#XA0;Other features</H3><!--SEC END --><P>There are also some tools to analyze a crystal structure. Tools
exist to superimpose two coordinate sets (SVDSuperimposer), to extract
polypeptides from a structure (Polypeptide), to perform neighbor lookup
(NeighborSearch) and to write out PDB files (PDBIO). The neighbor lookup
is done using a KD tree module written in C++. It is very fast and also
includes a fast method to find all point pairs within a certain distance
of each other.</P><P>A Polypeptide object is simply a UserList of Residue objects. You can
construct a list of Polypeptide objects from a Structure object as follows:</P><PRE CLASS="verbatim">model_nr=1
polypeptide_list=build_peptides(structure, model_nr)

for polypeptide in polypeptide_list:
    print polypeptide
</PRE><P>The Polypeptide objects are always created from a single
Model (in this case model 1).</P><!--TOC section Bio.PopGen: Population genetics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc110">9.8</A>&#XA0;&#XA0;Bio.PopGen: Population genetics</H2><!--SEC END --><P>Bio.PopGen is a new Biopython module supporting population genetics,
available in Biopython 1.44 onwards.</P><P>The medium term objective for the module is to support widely used data
formats, applications and databases. This module is currently under intense
development and support for new features should appear at a rather fast pace.
Unfortunately this might also entail some instability on the API, especially
if you are using a CVS version. APIs that are made available on public
versions should be much stabler.</P><!--TOC subsection GenePop-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc111">9.8.1</A>&#XA0;&#XA0;GenePop</H3><!--SEC END --><P>GenePop (<A HREF="http://genepop.curtin.edu.au/"><TT>http://genepop.curtin.edu.au/</TT></A>) is a popular population
genetics software package supporting Hardy-Weinberg tests, linkage
desiquilibrium, population diferentiation, basic statistics, <I>F</I><SUB><I>st</I></SUB> and
migration estimates, among others. GenePop does not supply sequence
based statistics as it doesn&#X2019;t handle sequence data.
The GenePop file format is supported by a wide range of other population
genetic software applications, thus making it a relevant format in the
population genetics field.</P><P>Bio.PopGen provides a parser and generator of GenePop file format.
Utilities to manipulate the content of a record are also provided.
Here is an example on how to read a GenePop file (you can find
example GenePop data files in the Test/PopGen directory of Biopython):</P><PRE CLASS="verbatim">from Bio.PopGen import GenePop

handle = open("example.gen")
rec = GenePop.parse(handle)
handle.close()
</PRE><P>This will read a file called example.gen and parse it. If you
do print rec, the record will be output again, in GenePop format.</P><P>The most important information in rec will be the loci names and
population information (but there is more &#X2013; use help(GenePop.Record)
to check the API documentation). Loci names can be found on rec.loci_list.
Population information can be found on rec.populations.
Populations is a list with one element per population. Each element is itself
a list of individuals, each individual is a pair composed by individual
name and a list of alleles (2 per marker), here is an example for
rec.populations:</P><PRE CLASS="verbatim">[
    [
        ('Ind1', [(1, 2),    (3, 3), (200, 201)],
        ('Ind2', [(2, None), (3, 3), (None, None)],
    ],
    [
        ('Other1', [(1, 1),  (4, 3), (200, 200)],
    ]
]
</PRE><P>So we have two populations, the first with two individuals, the
second with only one. The first individual of the first
population is called Ind1, allelic information for each of
the 3 loci follows. Please note that for any locus, information
might be missing (see as an example, Ind2 above).</P><P>A few utility functions to manipulate GenePop records are made
available, here is an example:</P><PRE CLASS="verbatim">from Bio.PopGen import GenePop

#Imagine that you have loaded rec, as per the code snippet above...

rec.remove_population(pos)
#Removes a population from a record, pos is the population position in
#  rec.populations, remember that it starts on position 0.
#  rec is altered.

rec.remove_locus_by_position(pos)
#Removes a locus by its position, pos is the locus position in
#  rec.loci_list, remember that it starts on position 0.
#  rec is altered.

rec.remove_locus_by_name(name)
#Removes a locus by its name, name is the locus name as in
#  rec.loci_list. If the name doesn't exist the function fails
#  silently.
#  rec is altered.

rec_loci = rec.split_in_loci()
#Splits a record in loci, that is, for each loci, it creates a new
#  record, with a single loci and all populations.
#  The result is returned in a dictionary, being each key the locus name.
#  The value is the GenePop record.
#  rec is not altered.

rec_pops =  rec.split_in_pops(pop_names)
#Splits a record in populations, that is, for each population, it creates
#  a new record, with a single population and all loci.
#  The result is returned in a dictionary, being each key
#  the population name. As population names are not available in GenePop,
#  they are passed in array (pop_names).
#  The value of each dictionary entry is the GenePop record.
#  rec is not altered.
</PRE><P>GenePop does not support population names, a limitation which can be
cumbersome at times. Functionality to enable population names is currently
being planned for Biopython. These extensions won&#X2019;t break compatibility in
any way with the standard format. In the medium term, we would also like to
support the GenePop web service.</P><!--TOC subsection Coalescent simulation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc112">9.8.2</A>&#XA0;&#XA0;Coalescent simulation</H3><!--SEC END --><P>A coalescent simulation is a backward model of population genetics with relation to
time. A simulation of ancestry is done until the Most Recent Common Ancestor (MRCA) is found.
This ancestry relationship starting on the MRCA and ending on the current generation
sample is sometimes called a genealogy. Simple cases assume a population of constant
size in time, haploidy, no population structure, and simulate the alleles of a single
locus under no selection pressure.</P><P>Coalescent theory is used in many fields like selection detection, estimation of
demographic parameters of real populations or disease gene mapping.</P><P>The strategy followed in the Biopython implementation of the coalescent was not
to create a new, built-in, simulator from scratch but to use an existing one,
SIMCOAL2 (<A HREF="http://cmpg.unibe.ch/software/simcoal2/"><TT>http://cmpg.unibe.ch/software/simcoal2/</TT></A>). SIMCOAL2 allows for,
among others, population structure, multiple demographic events, simulation
of multiple types of loci (SNPs, sequences, STRs/microsatellites and RFLPs)
with recombination, diploidy multiple chromosomes or ascertainment bias. Notably
SIMCOAL2 doesn&#X2019;t support any selection model. We recommend reading SIMCOAL2&#X2019;s
documentation, available in the link above.</P><P>The input for SIMCOAL2 is a file specifying the desired demography and genome,
the output is a set of files (typically around 1000) with the simulated genomes
of a sample of individuals per subpopulation. This set of files can be used
in many ways, like to compute confidence intervals where which certain
statistics (e.g., <I>F</I><SUB><I>st</I></SUB> or Tajima D) are expected to lie. Real population
genetics datasets statistics can then be compared to those confidence intervals.</P><P>Biopython coalescent code allows to create demographic scenarios and genomes and
to run SIMCOAL2.</P><!--TOC subsubsection Creating scenarios-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.8.2.1&#XA0;&#XA0;Creating scenarios</H4><!--SEC END --><P>Creating a scenario involves both creating a demography and a chromosome structure.
In many cases (e.g. when doing Approximate Bayesian Computations &#X2013; ABC) it is
important to test many parameter variations (e.g. vary the effective population size,
<I>N</I><SUB><I>e</I></SUB>, between 10, 50, 500 and 1000 individuals). The code provided allows for
the simulation of scenarios with different demographic parameters very easily.</P><P>Below we see how we can create scenarios and then how simulate them.</P><!--TOC paragraph Demography-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.8.2.1.1&#XA0;&#XA0;Demography</H5><!--SEC END --><P>A few predefined demographies are built-in, all have two shared parameters: sample size
(called sample_size on the template, see below for its use) per deme and deme size, i.e.
subpopulation size (pop_size). All demographies are available as templates where all
parameters can be varied, each template has a system name. The prefedined
demographies/templates are:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Single population, constant size</B></DT><DD CLASS="dd-description"> The standard parameters are enough to specifity
it. Template name: simple.
</DD><DT CLASS="dt-description"><B>Single population, bottleneck</B></DT><DD CLASS="dd-description"> As seen on figure <A HREF="#fig:bottle">9.8.2.1.1</A>. The parameters
are current population size (pop_size on template ne3 on figure), time of expansion,
given as the generation in the past when it occured (expand_gen), 
effective population size during bottleneck (ne2), time of contraction
(contract_gen) and original size in the remote past (ne3). Template name: bottle.
</DD><DT CLASS="dt-description"><B>Island model</B></DT><DD CLASS="dd-description"> The typical island model. The total number of demes is specified
by total_demes and the migration rate by mig. Template name island.
</DD><DT CLASS="dt-description"><B>Stepping stone model - 1 dimension</B></DT><DD CLASS="dd-description"> The stepping stone model in 1 dimension,
extremes disconnected. The total number of demes is total_demes, migration rate
is mig. Template name is ssm_1d.
</DD><DT CLASS="dt-description"><B>Stepping stone model - 2 dimensions</B></DT><DD CLASS="dd-description"> The stepping stone model in 2 dimensions,
extremes disconnected. The parameters are x for the horizontal dimension and y
for the vertical (being the total number of demes x times y), migration rate is mig.
Template name is ssm_2d.
</DD></DL><P>
<A NAME="fig:bottle"></A>
<IMG SRC="images/bottle.png">
</P><P>In our first example, we will generate a template for a single population, constant size
model with a sample size of 30 and a deme size of 500. The code for this is:</P><PRE CLASS="verbatim">from Bio.PopGen.SimCoal.Template import generate_simcoal_from_template

generate_simcoal_from_template('simple',
    [(1, [('SNP', [24, 0.0005, 0.0])])],
    [('sample_size', [30]),
    ('pop_size', [100])])
</PRE><P>Executing this code snippet will generate a file on the current directory called
simple_100_300.par this file can be given as input to SIMCOAL2 to simulate the
demography (below we will see how Biopython can take care of calling SIMCOAL2).</P><P>This code consists of a single function call, lets discuss it paramter by parameter.</P><P>The first parameter is the template id (from the list above). We are using the id
&#X2019;simple&#X2019; which is the template for a single population of constant size along time.</P><P>The second parameter is the chromosome structure. Please ignore it for now, it will be
explained in the next section.</P><P>The third parameter is a list of all required parameters (recall that the simple model
only needs sample_size and pop_size) and possible values (in this case each
parameter only has a possible value).</P><P>Now, lets consider an example where we want to generate several island models, and we
are interested in varying the number of demes: 10, 50 and 100 with a migration
rate of 1%. Sample size and deme
size will be the same as before. Here is the code:</P><PRE CLASS="verbatim">from Bio.PopGen.SimCoal.Template import generate_simcoal_from_template

generate_simcoal_from_template('island',
    [(1, [('SNP', [24, 0.0005, 0.0])])],
    [('sample_size', [30]),
    ('pop_size', [100]),
    ('mig', [0.01]),
    ('total_demes', [10, 50, 100])])
</PRE><P>In this case, 3 files will be generated: island_100_0.01_100_30.par,
island_10_0.01_100_30.par and island_50_0.01_100_30.par. Notice the
rule to make file names: template name, followed by parameter values in
reverse order.</P><P>A few, arguably more esoteric template demographies exist (please check the
Bio/PopGen/SimCoal/data directory on Biopython source tree). Furthermore it is possible
for the user to create new templates. That functionality will be discussed in a future
version of this document.</P><!--TOC paragraph Chromosome structure-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.8.2.1.2&#XA0;&#XA0;Chromosome structure</H5><!--SEC END --><P>We strongly recommend reading SIMCOAL2 documentation to understand the full potential
available in modeling chromosome structures. In this subsection we only discuss how
to implement chromosome structures using the Biopython interface, not the underlying
SIMCOAL2 capabilities.</P><P>We will start by implementing a single chromosome, with 24 SNPs with
a recombination rate immediately on the right of each locus of 0.0005 and a
minimum frequency of the minor allele of 0. This will be specified by the
following list (to be passed as second parameter to the function
generate_simcoal_from_template):</P><PRE CLASS="verbatim">[(1, [('SNP', [24, 0.0005, 0.0])])]
</PRE><P>This is actually the chromosome structure used in the above examples.</P><P>The chromosome structure is represented by a list of chromosomes,
each chromosome (i.e., each element in the list)
is composed by a tuple (a pair): the first element
is the number of times the chromosome is to be repeated (as there
might be interest in repeating the same chromosome many times).
The second element is a list of the actual components of the chromosome.
Each element is again a pair, the first member is the locus type and
the second element the parameters for that locus type. Confused?
Before showing more examples lets review the example above: We have
a list with one element (thus one chromosome), the chromosome is
a single instance (therefore not to be repeated), it is composed
of 24 SNPs, with a recombination rate of 0.0005 between each
consecutive SNP, the minimum frequency of the minor allele is
0.0 (i.e, it can be absent from a certain population).</P><P>Lets see a more complicated example:</P><PRE CLASS="verbatim">[
  (5, [
       ('SNP', [24, 0.0005, 0.0])
      ]
  ),
  (2, [
       ('DNA', [10, 0.0, 0.00005, 0.33]),
       ('RFLP', [1, 0.0, 0.0001]),
       ('MICROSAT', [1, 0.0, 0.001, 0.0, 0.0])
      ]
  )
]
</PRE><P>We start by having 5 chromosomes with the same structure as
above (i.e., 24 SNPs). We then have 2 chromosomes which
have a DNA sequence with 10 nucleotides, 0.0 recombination rate,
0.0005 mutation rate, and a transition rate of 0.33. Then we
have an RFLP with 0.0 recombination rate to the next locus and
a 0.0001 mutation rate. Finally we have a microsatellite (or STR),
with 0.0 recombination rate to the next locus (note, that as this
is a single microsatellite which has no loci following, this
recombination rate here is irrelevant), with a mutation rate
of 0.001, geometric paramater of 0.0 and a range constraint
of 0.0 (for information about this parameters please consult
the SIMCOAL2 documentation, you can use them to simulate
various mutation models, including the typical &#X2013; for microsatellites &#X2013;
stepwise mutation model among others).</P><!--TOC subsubsection Running SIMCOAL2-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.8.2.2&#XA0;&#XA0;Running SIMCOAL2</H4><!--SEC END --><P>We now discuss how to run SIMCOAL2 from inside Biopython. It is required
that the binary for SIMCOAL2 is called simcoal2 (or simcoal2.exe on Windows
based platforms), please note that the typical name when downloading the
program is in the format simcoal2_x_y. As such renaming of the binary
after download is needed.</P><P>It is possible to run SIMCOAL2 on files that were not generated using the method
above (e.g., writing a parameter file by hand), but we will show an
example by creating a model using the framework presented above.</P><PRE CLASS="verbatim">from Bio.PopGen.SimCoal.Template import generate_simcoal_from_template
from Bio.PopGen.SimCoal.Controller import SimCoalController


generate_simcoal_from_template('simple',
    [
      (5, [
           ('SNP', [24, 0.0005, 0.0])
          ]
      ),
      (2, [
           ('DNA', [10, 0.0, 0.00005, 0.33]),
           ('RFLP', [1, 0.0, 0.0001]),
           ('MICROSAT', [1, 0.0, 0.001, 0.0, 0.0])
          ]
      )
    ],
    [('sample_size', [30]),
    ('pop_size', [100])])

ctrl = SimCoalController('.')
ctrl.run_simcoal('simple_100_30.par', 50)
</PRE><P>The lines of interest are the last two (plus the new import).
Firstly a controller for the
application is created. The directory where the binary is located has
to be specified.</P><P>The simulator is then run on the last line: we know, from the rules explained
above, that the input file name is simple_100_30.par for the
simulation parameter file created. We then specify
that we want to run 50 independent simulations, by default Biopython
requests a simulation of diploid data, but a third parameter can
be added to simulate haploid data (adding as a parameter the
string &#X2019;0&#X2019;). SIMCOAL2 will now run (please
note that this can take quite a lot of time) and will create a directory
with the simulation results. The results can now be analysed (typically
studying the data with Arlequin3). In the future Biopython might support
reading the Arlequin3 format and thus allowing for the analysis of SIMCOAL2
data inside Biopython.</P><!--TOC subsection Other applications-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">9.8.3</A>&#XA0;&#XA0;Other applications</H3><!--SEC END --><P>Here we discuss interfaces and utilities to deal with population genetics&#X2019;
applications which arguably have a smaller user base.</P><!--TOC subsubsection FDist: Detecting selection and molecular adaptation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->9.8.3.1&#XA0;&#XA0;FDist: Detecting selection and molecular adaptation</H4><!--SEC END --><P>FDist is a selection detection application suite based on computing
(i.e. simulating) a &#X201C;neutral&#X201D; confidence interval based on <I>F</I><SUB><I>st</I></SUB> and
heterozygosity. Markers (which can be SNPs, microsatellites, AFLPs
among others) which lie outside the &#X201C;neutral&#X201D; interval are to be
considered as possible candidates for being under selection.</P><P>FDist is mainly used when the number of markers is considered enough
to estimate an average <I>F</I><SUB><I>st</I></SUB>, but not enough to either have outliers
calculated from the dataset directly or, with even more markers for
which the relative positions in the genome are known, to use
approaches based on, e.g., Extended Haplotype Heterozygosity (EHH).</P><P>The typical usage pattern for FDist is as follows:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Import a dataset from an external format into FDist format.
</LI><LI CLASS="li-enumerate">Compute average <I>F</I><SUB><I>st</I></SUB>. This is done by datacal inside FDist.
</LI><LI CLASS="li-enumerate">Simulate &#X201C;neutral&#X201D; markers based on the
average <I>F</I><SUB><I>st</I></SUB> and expected number of total populations.
This is the core operation, done by fdist inside FDist.
</LI><LI CLASS="li-enumerate">Calculate the confidence interval, based on the desired
confidence boundaries (typically 95% or 99%). This is done by
cplot and is mainly used to plot the interval.
</LI><LI CLASS="li-enumerate">Assess each marker status against the simulation &#X201C;neutral&#X201D;
confidence interval. Done
by pv. This is used to detect the outlier status of each marker
against the simulation.
</LI></OL><P>We will now discuss each step with illustrating example code
(for this example to work FDist binaries have to be on the
executable PATH).</P><P>The FDist data format is application specific and is not used at
all by other applications, as such you will probably have to convert
your data for use with FDist. Biopython can help you do this.
Here is an example converting from GenePop format to FDist format
(along with imports that will be needed on examples further below):</P><PRE CLASS="verbatim">from Bio.PopGen import GenePop
from Bio.PopGen import FDist
from Bio.PopGen.FDist import Controller
from Bio.PopGen.FDist.Utils import convert_genepop_to_fdist

gp_rec = GenePop.parse(open("example.gen"))
fd_rec = convert_genepop_to_fdist(gp_rec)
in_file = open("infile", "w")
in_file.write(str(fd_rec))
in_file.close()
</PRE><P>In this code we simply parse a GenePop file and convert it to a FDist
record.</P><P>Printing an FDist record will generate
a string that can be directly saved to a file and supplied to FDist. FDist
requires the input file to be called infile, therefore we save the record on
a file with that name.</P><P>The most important fields on a FDist record are: num_pops, the number of
populations; num_loci, the number of loci and loci_data with the marker
data itself. Most probably the details of the record are of no interest
to the user, as the record only purpose is to be passed to FDist.</P><P>The next step is to calculate the average <I>F</I><SUB><I>st</I></SUB> of the dataset (along
with the sample size):</P><PRE CLASS="verbatim">ctrl = Controller.FDistController()
fst, samp_size = ctrl.run_datacal()
</PRE><P>On the first line we create an object to control the call of FDist
suite, this object will be used further on in order to call other
suite applications.</P><P>On the second line we call the datacal application which computes the
average <I>F</I><SUB><I>st</I></SUB>
and the sample size. It is worth noting that the <I>F</I><SUB><I>st</I></SUB> computed by
datacal is a <EM>variation</EM> of Weir and Cockerham&#X2019;s &#X3B8;.</P><P>We can now call the main fdist application in order to simulate neutral
markers.</P><PRE CLASS="verbatim">sim_fst = ctrl.run_fdist(npops = 15, nsamples = fd_rec.num_pops, fst = fst,
    sample_size = samp_size, mut = 0, num_sims = 40000)
</PRE><DL CLASS="description"><DT CLASS="dt-description">
<B>npops</B></DT><DD CLASS="dd-description"> Number of populations existing in nature. This is really a
&#X201C;guestimate&#X201D;. Has to be lower than 100.
</DD><DT CLASS="dt-description"><B>nsamples</B></DT><DD CLASS="dd-description"> Number of populations sampled, has to be lower than npops.
</DD><DT CLASS="dt-description"><B>fst</B></DT><DD CLASS="dd-description"> Average <I>F</I><SUB><I>st</I></SUB>.
</DD><DT CLASS="dt-description"><B>sample_size</B></DT><DD CLASS="dd-description"> Average number of individuals sampled on each population.
</DD><DT CLASS="dt-description"><B>mut</B></DT><DD CLASS="dd-description"> Mutation model: 0 - Infinite alleles; 1 - Stepwise mutations
</DD><DT CLASS="dt-description"><B>num_sims</B></DT><DD CLASS="dd-description"> Number of simulations to perform. Typically a number around
40000 will be OK, but if you get a confidence interval that looks sharp
(this can be detected when plotting the confidence interval computed
below) the value can be increased (a suggestion would be steps of 10000
simulations).
</DD></DL><P>The confusion in wording between number of samples and sample size
stems from the original application.</P><P>A file named out.dat will be created with the simulated heterozygosities
and <I>F</I><SUB><I>st</I></SUB>s, it will have as many lines as the number of simulations
requested.</P><P>Note that fdist returns the average <I>F</I><SUB><I>st</I></SUB> that it was <EM>capable</EM> of
simulating, for more details about this issue please read below the paragraph
on approximating the desired average <I>F</I><SUB><I>st</I></SUB>.</P><P>The next (optional) step is to calculate the confidence interval:</P><PRE CLASS="verbatim">cpl_interval = ctrl.run_cplot(ci=0.99)
</PRE><P>You can only call cplot after having run fdist.</P><P>This will calculate the confidence intervals (99% in this case)
for a previous fdist run. A list of quadruples is returned. The
first element represents the heterozygosity, the second the lower
bound of <I>F</I><SUB><I>st</I></SUB> confidence interval for that heterozygosity,
the third the average and the fourth the upper bound. This can
be used to trace the confidence interval contour. This list
is also written to a file, out.cpl.</P><P>The main purpose of this step is return a set of points which can
be easily used to plot a confidence interval. It can be skipped
if the objective is only to assess the status of each marker against
the simulation, which is the next step...</P><PRE CLASS="verbatim">pv_data = ctrl.run_pv()
</PRE><P>You can only call cplot after having run datacal and fdist.</P><P>This will use the simulated markers to assess the status of each
individual real marker. A list, in the same order than the loci_list
that is on the FDist record (which is in the same order that the GenePop
record) is returned. Each element in the list is a quadruple, the
fundamental member of each quadruple is the last element (regarding the
other elements, please refer to the pv documentation &#X2013; for the
sake of simplicity we will not discuss them here) which returns the
probability of the simulated <I>F</I><SUB><I>st</I></SUB> being lower than the marker <I>F</I><SUB><I>st</I></SUB>.
Higher values would indicate a stronger candidate for positive selection,
lower values a candidate for balancing selection, and intermediate values
a possible neutral marker. What is &#X201C;higher&#X201D;, &#X201C;lower&#X201D; or &#X201C;intermediate&#X201D;
is really a subjective issue, but taking a &#X201C;confidence interval&#X201D; approach
and considering a 95% confidence interval, &#X201C;higher&#X201D; would be between 0.95
and 1.0, &#X201C;lower&#X201D; between 0.0 and 0.05 and &#X201C;intermediate&#X201D; between 0.05 and
0.95.</P><!--TOC paragraph Approximating the desired average <I>F</I><SUB><I>st</I></SUB>-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.8.3.1.1&#XA0;&#XA0;Approximating the desired average <I>F</I><SUB><I>st</I></SUB></H5><!--SEC END --><P>Fdist tries to approximate the desired average <I>F</I><SUB><I>st</I></SUB> by doing a
coalescent simulation using migration rates based on the formula</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>m</I></SUB>&#XA0;=&#XA0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1&#XA0;&#X2212;&#XA0;<I>F</I><SUB><I>st</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4<I>F</I><SUB><I>st</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#XA0;</TD></TR>
</TABLE><P>This formula assumes a few premises like an infinite number of populations.</P><P>In practice, when the number of populations is low, the mutation model
is stepwise and the sample size increases, fdist will not be able to
simulate an acceptable approximate average <I>F</I><SUB><I>st</I></SUB>.</P><P>To address that, a function is provided to iteratively approach the desired
value by running several fdists in sequence. This approach is computationally
more intensive than running a single fdist run, but yields good results.
The following code runs fdist approximating the desired <I>F</I><SUB><I>st</I></SUB>:</P><PRE CLASS="verbatim">sim_fst = ctrl.run_fdist_force_fst(npops = 15, nsamples = fd_rec.num_pops,
    fst = fst, sample_size = samp_size, mut = 0, num_sims = 40000,
    limit = 0.05)
</PRE><P>The only new optional parameter, when comparing with run_fdist, is limit
which is the desired maximum error. run_fdist can (and probably should)
be safely replaced with run_fdist_force_fst.</P><!--TOC paragraph Final notes-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->9.8.3.1.2&#XA0;&#XA0;Final notes</H5><!--SEC END --><P>The process to determine the average <I>F</I><SUB><I>st</I></SUB> can be more sophisticated than
the one presented here. For more information we refer you to the FDist
README file. Biopython&#X2019;s code can be used to implement more sophisticated
approaches.</P><!--TOC subsection Future Developments-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc114">9.8.4</A>&#XA0;&#XA0;Future Developments</H3><!--SEC END --><P>The most desired future developments would be the ones you add yourself ;) .</P><P>That being said, already existing fully functional code is currently being
incorporated in Bio.PopGen, that code covers the applications FDist and
SimCoal2, the HapMap and UCSC Table Browser databases and some simple statistics
like <I>F</I><SUB><I>st</I></SUB>, or allele counts.</P><!--TOC section InterPro-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc115">9.9</A>&#XA0;&#XA0;InterPro</H2><!--SEC END --><P>The <CODE>Bio.InterPro</CODE> module works with files from the
InterPro database, which can be obtained from the InterPro project:
<A HREF="http://www.ebi.ac.uk/interpro/"><TT>http://www.ebi.ac.uk/interpro/</TT></A>.</P><P>The <CODE>Bio.InterPro.Record</CODE> contains all the information stored in
an InterPro record. Its string representation also is a valid InterPro
record, but it is NOT guaranteed to be equivalent to the record
from which it was produced.</P><P>The <CODE>Bio.InterPro.Record</CODE> contains:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>Database</CODE>
</LI><LI CLASS="li-itemize"><CODE>Accession</CODE>
</LI><LI CLASS="li-itemize"><CODE>Name</CODE>
</LI><LI CLASS="li-itemize"><CODE>Dates</CODE>
</LI><LI CLASS="li-itemize"><CODE>Type</CODE>
</LI><LI CLASS="li-itemize"><CODE>Parent</CODE>
</LI><LI CLASS="li-itemize"><CODE>Process</CODE>
</LI><LI CLASS="li-itemize"><CODE>Function</CODE>
</LI><LI CLASS="li-itemize"><CODE>Component</CODE>
</LI><LI CLASS="li-itemize"><CODE>Signatures</CODE>
</LI><LI CLASS="li-itemize"><CODE>Abstract</CODE>
</LI><LI CLASS="li-itemize"><CODE>Examples</CODE>
</LI><LI CLASS="li-itemize"><CODE>References</CODE>
</LI><LI CLASS="li-itemize"><CODE>Database links</CODE>
</LI></UL><!--TOC chapter Advanced-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc116">Chapter&#XA0;10</A>&#XA0;&#XA0;Advanced</H1><!--SEC END --><P>
<A NAME="chapter:advanced"></A></P><!--TOC section The SeqRecord and SeqFeature classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc117">10.1</A>&#XA0;&#XA0;The SeqRecord and SeqFeature classes</H2><!--SEC END --><P>
<A NAME="sec:advanced-seq"></A></P><P>You read all about the basic Biopython sequence class in Chapter&#XA0;<A HREF="#chapter:Bio.Seq">3</A>, which described how to do many useful things with just the sequence. However, many times sequences have important additional properties associated with them &#X2013; as you will have seen with the <CODE>SeqRecord</CODE> object in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>.
This section described how Biopython handles these higher level descriptions of a sequence.</P><!--TOC subsection Sequence ids and Descriptions &#X2013; dealing with SeqRecords-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc118">10.1.1</A>&#XA0;&#XA0;Sequence ids and Descriptions &#X2013; dealing with SeqRecords</H3><!--SEC END --><P>Immediately above the Sequence class is the Sequence Record class, defined in the <CODE>Bio.SeqRecord</CODE> module. This class allows higher level features such as ids and features to be associated with the sequence, and is used thoughout the sequence input/output interface <CODE>Bio.SeqIO</CODE>, described in Chapter&#XA0;<A HREF="#chapter:Bio.SeqIO">4</A>. The <CODE>SeqRecord</CODE>class itself is very simple, and offers the following information as attributes:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>seq</B></DT><DD CLASS="dd-description"> &#X2013; The sequence itself &#X2013; A <CODE>Seq</CODE> object</DD><DT CLASS="dt-description"><B>id</B></DT><DD CLASS="dd-description"> &#X2013; The primary id used to identify the sequence. In most cases this is something like an accession number.</DD><DT CLASS="dt-description"><B>name</B></DT><DD CLASS="dd-description"> &#X2013; A &#X201C;common&#X201D; name/id for the sequence. In some cases this will be the same as the accession number, but it could also be a clone name. I think of this as being analagous to the LOCUS id in a GenBank record.</DD><DT CLASS="dt-description"><B>description</B></DT><DD CLASS="dd-description"> &#X2013; A human readible description or expressive name for the sequence. This is similar to what follows the id information in a FASTA formatted entry.</DD><DT CLASS="dt-description"><B>annotations</B></DT><DD CLASS="dd-description"> &#X2013; A dictionary of additional information about the sequence. The keys are the name of the information, and the information is contained in the value. This allows the addition of more &#X201C;unstructed&#X201D; information to the sequence.</DD><DT CLASS="dt-description"><B>features</B></DT><DD CLASS="dd-description"> &#X2013; A list of <CODE>SeqFeature</CODE> objects with more structured information about the features on a sequence. The structure of sequence features is described below in Section&#XA0;<A HREF="#sec:seq_features">10.1.2</A>.
</DD></DL><P>Using a <CODE>SeqRecord</CODE> class is not very complicated, since all of the information is stored as attributes of the class. Initializing the class just involves passing a <CODE>Seq</CODE> object to the <CODE>SeqRecord</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; simple_seq = Seq("GATC")
&gt;&gt;&gt; from Bio.SeqRecord import SeqRecord
&gt;&gt;&gt; simple_seq_r = SeqRecord(simple_seq)
</PRE><P>Additionally, you can also pass the id, name and description to the initialization function, but if not they will be set as strings indicating they are unknown, and can be modified subsequently:</P><PRE CLASS="verbatim">&gt;&gt;&gt; simple_seq_r.id
'&lt;unknown id&gt;'
&gt;&gt;&gt; simple_seq_r.id = 'AC12345'
&gt;&gt;&gt; simple_seq_r.description = 'My little made up sequence I wish I could
write a paper about and submit to GenBank'
&gt;&gt;&gt; print simple_seq_r.description
My little made up sequence I wish I could write a paper about and submit
to GenBank
&gt;&gt;&gt; simple_seq_r.seq
Seq('GATC', Alphabet())
</PRE><P>Adding annotations is almost as easy, and just involves dealing directly with the annotation dictionary:</P><PRE CLASS="verbatim">&gt;&gt;&gt; simple_seq_r.annotations['evidence'] = 'None. I just made it up.'
&gt;&gt;&gt; print simple_seq_r.annotations
{'evidence': 'None. I just made it up.'}
</PRE><P>That&#X2019;s just about all there is to it! Next, you may want to learn about SeqFeatures, which offer an additional structured way to represent information about a sequence.</P><!--TOC subsection Features and Annotations &#X2013; SeqFeatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc119">10.1.2</A>&#XA0;&#XA0;Features and Annotations &#X2013; SeqFeatures</H3><!--SEC END --><P>
<A NAME="sec:seq_features"></A></P><P>Sequence features are an essential part of describing a sequence. Once you get beyond the sequence itself, you need some way to organize and easily get at the more &#X201C;abstract&#X201D; information that is known about the sequence. While it is probably impossible to develop a general sequence feature class that will cover everything, the Biopython <CODE>SeqFeature</CODE> class attempts to encapsulate as much of the information about the sequence as possible. The design is heavily based on the GenBank/EMBL feature tables, so if you understand how they look, you&#X2019;ll probably have an easier time grasping the structure of the Biopython classes.</P><!--TOC subsubsection SeqFeatures themselves-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.1.2.1&#XA0;&#XA0;SeqFeatures themselves</H4><!--SEC END --><P>The first level of dealing with Sequence features is the <CODE>SeqFeature</CODE> class itself. This class has a number of attributes, so first we&#X2019;ll list them and there general features, and then work through an example to show how this applies to a real life example, a GenBank feature table. The attributes of a SeqFeature are:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>location</B></DT><DD CLASS="dd-description"> &#X2013; The location of the <CODE>SeqFeature</CODE> on the sequence that you are dealing with. The locations end-points may be fuzzy &#X2013; section&#XA0;<A HREF="#sec:locations">10.1.2.2</A> has a lot more description on how to deal with descriptions.</DD><DT CLASS="dt-description"><B>type</B></DT><DD CLASS="dd-description"> &#X2013; This is a textual description of the type of feature (for instance, this will be something like &#X2019;CDS&#X2019; or &#X2019;gene&#X2019;).</DD><DT CLASS="dt-description"><B>ref</B></DT><DD CLASS="dd-description"> &#X2013; A reference to a different sequence. Some times features may be &#X201C;on&#X201D; a particular sequence, but may need to refer to a different sequence, and this provides the reference (normally an accession number). A good example of this is a genomic sequence that has most of a coding sequence, but one of the exons is on a different accession. In this case, the feature would need to refer to this different accession for this missing exon.</DD><DT CLASS="dt-description"><B>ref_db</B></DT><DD CLASS="dd-description"> &#X2013; This works along with <CODE>ref</CODE> to provide a cross sequence reference. If there is a reference, <CODE>ref_db</CODE> will be set as None if the reference is in the same database, and will be set to the name of the database otherwise.</DD><DT CLASS="dt-description"><B>strand</B></DT><DD CLASS="dd-description"> &#X2013; The strand on the sequence that the feature is located on. This may either be &#X2019;1&#X2019; for the top strand, &#X2019;-1&#X2019; for the bottom strand, or &#X2019;0&#X2019; for both strands (or if it doesn&#X2019;t matter). Keep in mind that this only really makes sense for double stranded DNA, and not for proteins or RNA.</DD><DT CLASS="dt-description"><B>qualifiers</B></DT><DD CLASS="dd-description"> &#X2013; This is a python dictionary of additional information about the feature. The key is some kind of terse one-word description of what the information contained in the value is about, and the value is the actual information. For example, a common key for a qualifier might be &#X201C;evidence&#X201D; and the value might be &#X201C;computational (non-experimental).&#X201D; This is just a way to let the person who is looking at the feature know that it has not be experimentally (i.&#XA0;e.&#XA0;in a wet lab) confirmed.</DD><DT CLASS="dt-description"><B>sub_features</B></DT><DD CLASS="dd-description"> &#X2013; A very important feature of a feature is that it can have additional <CODE>sub_features</CODE> underneath it. This allows nesting of features, and helps us to deal with things such as the GenBank/EMBL feature lines in a (we hope) intuitive way.
</DD></DL><P>To show an example of SeqFeatures in action, let&#X2019;s take a look at the following feature from a GenBank feature table:</P><PRE CLASS="verbatim">     mRNA            complement(join(&lt;49223..49300,49780..&gt;50208))
                     /gene="F28B23.12"
</PRE><P>To look at the easiest attributes of the SeqFeature first, if you got a SeqFeature object for this it would have it <CODE>type</CODE> of &#X2019;mRNA&#X2019;, a <CODE>strand</CODE> of -1 (due to the &#X2019;complement&#X2019;), and would have None for the <CODE>ref</CODE> and <CODE>ref_db</CODE> since there are no references to external databases. The <CODE>qualifiers</CODE> for this SeqFeature would be a python dictionarary that looked like <CODE>{'gene' : 'F28B23.12'}</CODE>.</P><P>Now let&#X2019;s look at the more tricky part, how the &#X2019;join&#X2019; in the location
line is handled. First, the location for the top level SeqFeature (the
one we are dealing with right now) is set as going from
<CODE>'&lt;49223' to '&gt;50208'</CODE> (see section&#XA0;<A HREF="#sec:locations">10.1.2.2</A> for
the nitty gritty on how fuzzy locations like this are handled).
So the location of the top level object is the entire span of the
feature. So, how do you get at the information in the &#X2019;join?&#X2019;
Well, that&#X2019;s where the <CODE>sub_features</CODE> go in.</P><P>The <CODE>sub_features</CODE> attribute will have a list with two SeqFeature
objects in it, and these contain the information in the join. Let&#X2019;s
look at <CODE>top_level_feature.sub_features[0]</CODE>; the first
<CODE>sub_feature</CODE>). This object is a SeqFeature object with a
<CODE>type</CODE> of &#X2019;<CODE>mRNA_join</CODE>,&#X2019; a <CODE>strand</CODE> of -1 (inherited
from the parent SeqFeature) and a location going from
<CODE>'&lt;49223' to '49300'</CODE>.</P><P>So, the <CODE>sub_features</CODE> allow you to get at the internal information if you want it (i.&#XA0;e.&#XA0;if you were trying to get only the exons out of a genomic sequence), or just to deal with the broad picture (i.&#XA0;e.&#XA0;you just want to know that the coding sequence for a gene lies in a region). Hopefully this structuring makes it easy and intuitive to get at the sometimes complex information that can be contained in a SeqFeature.</P><!--TOC subsubsection Locations-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.1.2.2&#XA0;&#XA0;Locations</H4><!--SEC END --><P>
<A NAME="sec:locations"></A></P><P>In the section on SeqFeatures above, we skipped over one of the more difficult parts of Features, dealing with the locations. The reason this can be difficult is because of fuzziness of the positions in locations. Before we get into all of this, let&#X2019;s just define the vocabulary we&#X2019;ll use to talk about this. Basically there are two terms we&#X2019;ll use:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>position</B></DT><DD CLASS="dd-description"> &#X2013; This refers to a single position on a sequence,
which may be fuzzy or not. For instance, 5, 20, <CODE>&lt;100</CODE> and
<CODE>3^5</CODE> are all positions.</DD><DT CLASS="dt-description"><B>location</B></DT><DD CLASS="dd-description"> &#X2013; A location is two positions that defines a region of a sequence. For instance 5..20 (i.&#XA0;e.&#XA0;5 to 20) is a location.
</DD></DL><P>I just mention this because sometimes I get confused between the two.</P><P>The complication in dealing with locations comes in the positions themselves. In biology many times things aren&#X2019;t entirely certain (as much as us wet lab biologists try to make them certain!). For instance, you might do a dinucleotide priming experiment and discover that the start of mRNA transcript starts at one of two sites. This is very useful information, but the complication comes in how to represent this as a position. To help us deal with this, we have the concept of fuzzy positions. Basically there are five types of fuzzy positions, so we have five classes do deal with them:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>ExactPosition</B></DT><DD CLASS="dd-description"> &#X2013; As its name suggests, this class represents a position which is specified as exact along the sequence. This is represented as just a a number, and you can get the position by looking at the <CODE>position</CODE> attribute of the object.</DD><DT CLASS="dt-description"><B>BeforePosition</B></DT><DD CLASS="dd-description"> &#X2013; This class represents a fuzzy position
that occurs prior to some specified site. In GenBank/EMBL notation,
this is represented as something like <CODE>'&lt;13'</CODE>, signifying that
the real position is located somewhere less then 13. To get
the specified upper boundary, look at the <CODE>position</CODE>
attribute of the object.</DD><DT CLASS="dt-description"><B>AfterPosition</B></DT><DD CLASS="dd-description"> &#X2013; Contrary to <CODE>BeforePosition</CODE>, this
class represents a position that occurs after some specified site.
This is represented in GenBank as <CODE>'&gt;13'</CODE>, and like
<CODE>BeforePosition</CODE>, you get the boundary number by looking
at the <CODE>position</CODE> attribute of the object.</DD><DT CLASS="dt-description"><B>WithinPosition</B></DT><DD CLASS="dd-description"> &#X2013; This class models a position which occurs somewhere between two specified nucleotides. In GenBank/EMBL notation, this would be represented as &#X2019;(1.5)&#X2019;, to represent that the position is somewhere within the range 1 to 5. To get the information in this class you have to look at two attributes. The <CODE>position</CODE> attribute specifies the lower boundary of the range we are looking at, so in our example case this would be one. The <CODE>extension</CODE> attribute specifies the range to the higher boundary, so in this case it would be 4. So <CODE>object.position</CODE> is the lower boundary and <CODE>object.position + object.extension</CODE> is the upper boundary.</DD><DT CLASS="dt-description"><B>BetweenPosition</B></DT><DD CLASS="dd-description"> &#X2013; This class deals with a position that
occurs between two coordinates. For instance, you might have a
protein binding site that occurs between two nucleotides on a
sequence. This is represented as <CODE>'2^3'</CODE>, which indicates that
the real position happens between position 2 and 3. Getting
this information from the object is very similar to
<CODE>WithinPosition</CODE>, the <CODE>position</CODE> attribute specifies
the lower boundary (2, in this case) and the <CODE>extension</CODE>
indicates the range to the higher boundary (1 in this case).
</DD></DL><P>Now that we&#X2019;ve got all of the types of fuzzy positions we can have taken care of, we are ready to actually specify a location on a sequence. This is handled by the <CODE>FeatureLocation</CODE> class. An object of this type basically just holds the potentially fuzzy start and end positions of a feature. You can create a <CODE>FeatureLocation</CODE> object by creating the positions and passing them in:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqFeature
&gt;&gt;&gt; start_pos = SeqFeature.AfterPosition(5)
&gt;&gt;&gt; end_pos = SeqFeature.BetweenPosition(8, 1)
&gt;&gt;&gt; my_location = SeqFeature.FeatureLocation(start_pos, end_pos)
</PRE><P>If you print out a <CODE>FeatureLocation</CODE> object, you can get a nice representation of the information:</P><PRE CLASS="verbatim">&gt;&gt;&gt; print my_location
[&gt;5:(8^9)]
</PRE><P>We can access the fuzzy start and end positions using the start and end attributes of the location:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_location.start
&lt;Bio.SeqFeature.AfterPosition instance at 0x101d7164&gt;
&gt;&gt;&gt; print my_location.start
&gt;5
&gt;&gt;&gt; print my_location.end
(8^9)
</PRE><P>If you don&#X2019;t want to deal with fuzzy positions and just want numbers, you just need to ask for the <CODE>nofuzzy_start</CODE> and <CODE>nofuzzy_end</CODE> attributes of the location:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_location.nofuzzy_start
5
&gt;&gt;&gt; my_location.nofuzzy_end
8
</PRE><P>Notice that this just gives you back the position attributes of the fuzzy locations.</P><P>Similary, to make it easy to create a position without worrying about fuzzy positions, you can just pass in numbers to the <CODE>FeaturePosition</CODE> constructors, and you&#X2019;ll get back out <CODE>ExactPosition</CODE> objects:</P><PRE CLASS="verbatim">&gt;&gt;&gt; exact_location = SeqFeature.FeatureLocation(5, 8)
&gt;&gt;&gt; print exact_location
[5:8]
&gt;&gt;&gt; exact_location.start
&lt;Bio.SeqFeature.ExactPosition instance at 0x101dcab4&gt;
</PRE><P>That is all of the nitty gritty about dealing with fuzzy positions in Biopython. It has been designed so that dealing with fuzziness is not that much more complicated than dealing with exact positions, and hopefully you find that true!</P><!--TOC subsubsection References-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->10.1.2.3&#XA0;&#XA0;References</H4><!--SEC END --><P>Another common annotation related to a sequence is a reference to a journal or other published work dealing with the sequence. We have a fairly simple way of representing a Reference in Biopython &#X2013; we have a <CODE>Bio.SeqFeature.Reference</CODE> class that stores the relevant information about a reference as attributes of an object.</P><P>The attributes include things that you would expect to see in a reference like <CODE>journal</CODE>, <CODE>title</CODE> and <CODE>authors</CODE>. Additionally, it also can hold the <CODE>medline_id</CODE> and <CODE>pubmed_id</CODE> and a <CODE>comment</CODE> about the reference. These are all accessed simply as attributes of the object.</P><P>A reference also has a <CODE>location</CODE> object so that it can specify a particular location on the sequence that the reference refers to. For instance, you might have a journal that is dealing with a particular gene located on a BAC, and want to specify that it only refers to this position exactly. The <CODE>location</CODE> is a potentially fuzzy location, as described in section&#XA0;<A HREF="#sec:locations">10.1.2.2</A>.</P><P>That&#X2019;s all there is too it. References are meant to be easy to deal with, and hopefully general enough to cover lots of usage cases.</P><!--TOC section Regression Testing Framework-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc120">10.2</A>&#XA0;&#XA0;Regression Testing Framework</H2><!--SEC END --><P>
<A NAME="sec:regr_test"></A></P><P>Biopython has a regression testing framework originally written by Andrew Dalke and ported to PyUnit by Brad Chapman which helps us make sure the code is as bug-free as possible before going out.</P><!--TOC subsection Writing a Regression Test-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc121">10.2.1</A>&#XA0;&#XA0;Writing a Regression Test</H3><!--SEC END --><P>Every module that goes into Biopython should have a test (and should also have documentation!). Let&#X2019;s say you&#X2019;ve written a new module called Biospam &#X2013; here is what you should do to make a regression test:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Write a script called <CODE>test_Biospam.py</CODE><UL CLASS="itemize"><LI CLASS="li-itemize">This script should live in the Tests directory</LI><LI CLASS="li-itemize">The script should test all of the important functionality of the module (the more you test the better your test is, of course!).</LI><LI CLASS="li-itemize">Try to avoid anything which might be platform specific, such as printing floating point numbers without using an explicit formatting string.
</LI></UL></LI><LI CLASS="li-enumerate">If the script requires files to do the testing, these should go in
the directory Tests/Biospam.</LI><LI CLASS="li-enumerate">Write out the test output and verify the output to be correct.
There are two ways to do this:<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
The long way:<UL CLASS="itemize"><LI CLASS="li-itemize">Run the script and write its output to a file. On UNIX machines,
you would do something like: <CODE>python test_Biospam.py &gt; test_Biospam</CODE> which would write the output to the file <CODE>test_Biospam</CODE>.</LI><LI CLASS="li-itemize">Manually look at the file <CODE>test_Biospam</CODE> to make sure the output is correct. When you are sure it is all right and there are no bugs, you need to quickly edit the <CODE>test_Biospam</CODE> file so that the first line is: &#X2018;<CODE>test_Biospam</CODE>&#X2019; (no quotes).</LI><LI CLASS="li-itemize">copy the <CODE>test_Biospam</CODE> file to the directory Tests/output</LI></UL></LI><LI CLASS="li-enumerate">The quick way:<UL CLASS="itemize"><LI CLASS="li-itemize">
Run <CODE>python run_tests.py -g test_Biospam.py</CODE>. The
regression testing framework is nifty enough that it&#X2019;ll put
the output in the right place in just the way it likes it. </LI><LI CLASS="li-itemize">Go to the output (which should be in <CODE>Tests/output/test_Biospam</CODE>) and double check the output to make sure it is all correct.</LI></UL></LI></OL></LI><LI CLASS="li-enumerate">Now change to the Tests directory and run the regression tests
with <CODE>python run_tests.py</CODE>. This will run all of the tests, and
you should see your test run (and pass!).</LI><LI CLASS="li-enumerate">That&#X2019;s it! Now you&#X2019;ve got a nice test for your module ready to check into CVS.
Congratulations!
</LI></OL><!--TOC section Parser Design-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc122">10.3</A>&#XA0;&#XA0;Parser Design</H2><!--SEC END --><P>Many of the older Biopython parsers were built around an event-oriented
design that includes Scanner and Consumer objects.</P><P>Scanners take input from a data source and analyze it line by line,
sending off an event whenever it recognizes some information in the
data. For example, if the data includes information about an organism
name, the scanner may generate an <CODE>organism_name</CODE> event whenever it
encounters a line containing the name.</P><P>Consumers are objects that receive the events generated by Scanners.
Following the previous example, the consumer receives the
<CODE>organism_name</CODE> event, and the processes it in whatever manner
necessary in the current application.</P><P>This is a very flexible framework, which is advantageous if you want to
be able to parse a file format into more than one representation. For
example, both the <CODE>Bio.GenBank</CODE> and <CODE>Bio.SwissProt</CODE> modules
use this to read their file formats as both generic <CODE>SeqRecord</CODE> objects
and file-format-specific record objects.</P><P>More recently, many of the parsers added for <CODE>Bio.SeqIO</CODE> and
<CODE>Bio.AlignIO</CODE> take a much simpler approach, but only generate a
single object representation (<CODE>SeqRecord</CODE> and <CODE>Alignment</CODE> objects
respectively).</P><!--TOC section Substitution Matrices-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc123">10.4</A>&#XA0;&#XA0;Substitution Matrices</H2><!--SEC END --><!--TOC subsection SubsMat-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc124">10.4.1</A>&#XA0;&#XA0;SubsMat</H3><!--SEC END --><P>This module provides a class and a few routines for generating substitution matrices, similar to BLOSUM or PAM matrices, but based on user-provided data.</P><P>Additionally, you may select a matrix from MatrixInfo.py, a collection of established substitution matrices.</P><PRE CLASS="verbatim">class SeqMat(UserDict.UserDict)
</PRE><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Attributes<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<CODE>self.data</CODE>: a dictionary in the form of <CODE>{(i1,j1):n1, (i1,j2):n2,...,(ik,jk):nk}</CODE> where i, j are alphabet letters, and n is a value.</LI><LI CLASS="li-enumerate"><CODE>self.alphabet</CODE>: a class as defined in Bio.Alphabet</LI><LI CLASS="li-enumerate"><CODE>self.ab_list</CODE>: a list of the alphabet&#X2019;s letters, sorted. Needed mainly for internal purposes</LI><LI CLASS="li-enumerate"><CODE>self.sum_letters</CODE>: a dictionary. <CODE>{i1: s1, i2: s2,...,in:sn}</CODE> where:
<OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
i: an alphabet letter;
</LI><LI CLASS="li-enumerate">s: sum of all values in a half-matrix for that letter;
</LI><LI CLASS="li-enumerate">n: number of letters in alphabet.
</LI></OL>
</LI></OL></LI><LI CLASS="li-enumerate">Methods<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate"><PRE CLASS="verbatim">__init__(self,data=None,alphabet=None,
         mat_type=NOTYPE,mat_name='',build_later=0):
</PRE><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate"><CODE>data</CODE>: can be either a dictionary, or another SeqMat instance.
</LI><LI CLASS="li-enumerate"><CODE>alphabet</CODE>: a Bio.Alphabet instance. If not provided, construct an alphabet from data.</LI><LI CLASS="li-enumerate"><CODE>mat_type</CODE>: type of matrix generated. One of the following:<DL CLASS="description"><DT CLASS="dt-description">
<B>NOTYPE</B></DT><DD CLASS="dd-description"> No type defined
</DD><DT CLASS="dt-description"><B>ACCREP</B></DT><DD CLASS="dd-description"> Accepted Replacements Matrix
</DD><DT CLASS="dt-description"><B>OBSFREQ</B></DT><DD CLASS="dd-description"> Observed Frequency Matrix
</DD><DT CLASS="dt-description"><B>EXPFREQ</B></DT><DD CLASS="dd-description"> Expsected Frequency Matrix
</DD><DT CLASS="dt-description"><B>SUBS</B></DT><DD CLASS="dd-description"> Substitution Matrix 
</DD><DT CLASS="dt-description"><B>LO</B></DT><DD CLASS="dd-description"> Log Odds Matrix
</DD></DL><P><CODE>mat_type</CODE> is provided automatically by some of SubsMat&#X2019;s functions.</P></LI><LI CLASS="li-enumerate"><CODE>mat_name</CODE>: matrix name, such as "BLOSUM62" or "PAM250"</LI><LI CLASS="li-enumerate"><CODE>build_later</CODE>: default false. If true, user may supply only alphabet and empty dictionary, if intending to build the matrix later. this skips the sanity check of alphabet size vs. matrix size.</LI></OL></LI><LI CLASS="li-enumerate"><PRE CLASS="verbatim">entropy(self,obs_freq_mat)
</PRE><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
<CODE>obs_freq_mat</CODE>: an observed frequency matrix. Returns the matrix&#X2019;s entropy, based on the frequency in <CODE>obs_freq_mat</CODE>. The matrix instance should be LO or SUBS.
</LI></OL></LI><LI CLASS="li-enumerate"><PRE CLASS="verbatim">letter_sum(self,letter)
</PRE><P>Returns the sum of all values in the matrix, for the provided <CODE>letter</CODE></P></LI><LI CLASS="li-enumerate"><PRE CLASS="verbatim">all_letters_sum(self)
</PRE><P>Fills the dictionary attribute <CODE>self.sum_letters</CODE> with the sum of values for each letter in the matrix&#X2019;s alphabet.</P></LI><LI CLASS="li-enumerate"><PRE CLASS="verbatim">print_mat(self,f,format="%4d",bottomformat="%4s",alphabet=None)
</PRE><P>prints the matrix to file handle f. <CODE>format</CODE> is the format field for the matrix values; <CODE>bottomformat</CODE> is the format field for the bottom row, containing matrix letters. Example output for a 3-letter alphabet matrix:</P><PRE CLASS="verbatim">A 23
B 12 34
C 7  22  27
  A   B   C
</PRE><P>The <CODE>alphabet</CODE> optional argument is a string of all characters in the alphabet. If supplied, the order of letters along the axes is taken from the string, rather than by alphabetical order.</P></LI></OL></LI><LI CLASS="li-enumerate">Usage<P>The following section is layed out in the order by which most people wish to generate a log-odds matrix. Of course, interim matrices can be generated and
investigated. Most people just want a log-odds matrix, that&#X2019;s all.</P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">Generating an Accepted Replacement Matrix<P>Initially, you should generate an accepted replacement matrix (ARM) from your data. The values in ARM are the counted number of replacements according to your data. The data could be a set of pairs or multiple alignments. So for instance if Alanine was replaced by Cysteine 10 times, and Cysteine by Alanine 12 times, the corresponding ARM entries would be:</P><PRE CLASS="verbatim">('A','C'): 10, ('C','A'): 12
</PRE><P>as order doesn&#X2019;t matter, user can already provide only one entry:</P><PRE CLASS="verbatim">('A','C'): 22
</PRE><P>A SeqMat instance may be initialized with either a full (first method of counting: 10, 12) or half (the latter method, 22) matrices. A full protein
alphabet matrix would be of the size 20x20 = 400. A half matrix of that alphabet would be 20x20/2 + 20/2 = 210. That is because same-letter entries don&#X2019;t
change. (The matrix diagonal). Given an alphabet size of N:</P><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
Full matrix size:N*N</LI><LI CLASS="li-enumerate">Half matrix size: N(N+1)/2
</LI></OL><P>The SeqMat constructor automatically generates a half-matrix, if a full matrix is passed. If a half matrix is passed, letters in the key should be provided in alphabetical order: (&#X2019;A&#X2019;,&#X2019;C&#X2019;) and not (&#X2019;C&#X2019;,A&#X2019;).</P><P>At this point, if all you wish to do is generate a log-odds matrix, please go to the section titled Example of Use. The following text describes the nitty-gritty of internal functions, to be used by people who wish to investigate their nucleotide/amino-acid frequency data more thoroughly.</P></LI><LI CLASS="li-enumerate">Generating the observed frequency matrix (OFM)<P>Use:
</P><PRE CLASS="verbatim">OFM = SubsMat._build_obs_freq_mat(ARM)
</PRE><P>The OFM is generated from the ARM, only instead of replacement counts, it contains replacement frequencies.</P></LI><LI CLASS="li-enumerate">Generating an expected frequency matrix (EFM)<P>Use:</P><PRE CLASS="verbatim">EFM = SubsMat._build_exp_freq_mat(OFM,exp_freq_table)
</PRE><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
<CODE>exp_freq_table</CODE>: should be a FreqTable instance. See section&#XA0;<A HREF="#sec:freq_table">10.4.2</A> for detailed information on FreqTable. Briefly, the expected frequency table has the frequencies of appearance for each member of the alphabet. It is
implemented as a dictionary with the alphabet letters as keys, and each letter&#X2019;s frequency as a value. Values sum to 1.
</LI></OL><P>The expected frequency table can (and generally should) be generated from the observed frequency matrix. So in most cases you will generate <CODE>exp_freq_table</CODE> using:</P><PRE CLASS="verbatim">&gt;&gt;&gt; exp_freq_table = SubsMat._exp_freq_table_from_obs_freq(OFM)
&gt;&gt;&gt; EFM = SubsMat._build_exp_freq_mat(OFM,exp_freq_table)
</PRE><P>But you can supply your own <CODE>exp_freq_table</CODE>, if you wish</P></LI><LI CLASS="li-enumerate">Generating a substitution frequency matrix (SFM)<P>Use:</P><PRE CLASS="verbatim">SFM = SubsMat._build_subs_mat(OFM,EFM)
</PRE><P>Accepts an OFM, EFM. Provides the division product of the corresponding values.</P></LI><LI CLASS="li-enumerate">Generating a log-odds matrix (LOM)<P>Use:
</P><PRE CLASS="verbatim">LOM=SubsMat._build_log_odds_mat(SFM[,logbase=10,factor=10.0,round_digit=1])
</PRE><OL CLASS="enumerate" type=i><LI CLASS="li-enumerate">
Accepts an SFM.</LI><LI CLASS="li-enumerate"><CODE>logbase</CODE>: base of the logarithm used to generate the log-odds values.</LI><LI CLASS="li-enumerate"><CODE>factor</CODE>: factor used to multiply the log-odds values. Each entry is generated by log(LOM[key])*factor And rounded to the <CODE>round_digit</CODE> place after the decimal point, if required.</LI></OL></LI></OL></LI><LI CLASS="li-enumerate">Example of use<P>As most people would want to generate a log-odds matrix, with minimum hassle, SubsMat provides one function which does it all:</P><PRE CLASS="verbatim">make_log_odds_matrix(acc_rep_mat,exp_freq_table=None,logbase=10,
                      factor=10.0,round_digit=0):
</PRE><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<CODE>acc_rep_mat</CODE>: user provided accepted replacements matrix
</LI><LI CLASS="li-enumerate"><CODE>exp_freq_table</CODE>: expected frequencies table. Used if provided, if not, generated from the <CODE>acc_rep_mat</CODE>.
</LI><LI CLASS="li-enumerate"><CODE>logbase</CODE>: base of logarithm for the log-odds matrix. Default base 10.
</LI><LI CLASS="li-enumerate"><CODE>round_digit</CODE>: number after decimal digit to which result should be rounded. Default zero.
</LI></OL></LI></OL><!--TOC subsection FreqTable-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc125">10.4.2</A>&#XA0;&#XA0;FreqTable</H3><!--SEC END --><P>
<A NAME="sec:freq_table"></A></P><PRE CLASS="verbatim">FreqTable.FreqTable(UserDict.UserDict)
</PRE><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Attributes:<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<CODE>alphabet</CODE>: A Bio.Alphabet instance.
</LI><LI CLASS="li-enumerate"><CODE>data</CODE>: frequency dictionary
</LI><LI CLASS="li-enumerate"><CODE>count</CODE>: count dictionary (in case counts are provided).
</LI></OL></LI><LI CLASS="li-enumerate">Functions:
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<CODE>read_count(f)</CODE>: read a count file from stream f. Then convert to frequencies
</LI><LI CLASS="li-enumerate"><CODE>read_freq(f)</CODE>: read a frequency data file from stream f. Of course, we then don&#X2019;t have the counts, but it is usually the letter frquencies which are interesting.
</LI></OL></LI><LI CLASS="li-enumerate">Example of use:
The expected count of the residues in the database is sitting in a file, whitespace delimited, in the following format (example given for a 3-letter alphabet):<PRE CLASS="verbatim">A   35
B   65
C   100
</PRE><P>And will be read using the <CODE>FreqTable.read_count(file_handle)</CODE> function.</P><P>An equivalent frequency file:</P><PRE CLASS="verbatim">A  0.175
B  0.325
C  0.5
</PRE><P>Conversely, the residue frequencies or counts can be passed as a dictionary.
Example of a count dictionary (3-letter alphabet):</P><PRE CLASS="verbatim">{'A': 35, 'B': 65, 'C': 100}
</PRE><P>Which means that an expected data count would give a 0.5 frequency
for &#X2019;C&#X2019;, a 0.325 probability of &#X2019;B&#X2019; and a 0.175 probability of &#X2019;A&#X2019;
out of 200 total, sum of A, B and C)</P><P>A frequency dictionary for the same data would be:</P><PRE CLASS="verbatim">{'A': 0.175, 'B': 0.325, 'C': 0.5}
</PRE><P>Summing up to 1.</P><P>When passing a dictionary as an argument, you should indicate whether it is a count or a frequency dictionary. Therefore the FreqTable class constructor requires two arguments: the dictionary itself, and FreqTable.COUNT or FreqTable.FREQ indicating counts or frequencies, respectively.</P><P>Read expected counts. readCount will already generate the frequencies
Any one of the following may be done to geerate the frequency table (ftab):</P><PRE CLASS="verbatim">&gt;&gt;&gt; from SubsMat import *
&gt;&gt;&gt; ftab = FreqTable.FreqTable(my_frequency_dictionary,FreqTable.FREQ)
&gt;&gt;&gt; ftab = FreqTable.FreqTable(my_count_dictionary,FreqTable.COUNT)
&gt;&gt;&gt; ftab = FreqTable.read_count(open('myCountFile'))
&gt;&gt;&gt; ftab = FreqTable.read_frequency(open('myFrequencyFile'))
</PRE></LI></OL><!--TOC chapter Where to go from here &#X2013; contributing to Biopython-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc126">Chapter&#XA0;11</A>&#XA0;&#XA0;Where to go from here &#X2013; contributing to Biopython</H1><!--SEC END --><!--TOC section Maintaining a distribution for a platform-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc127">11.1</A>&#XA0;&#XA0;Maintaining a distribution for a platform</H2><!--SEC END --><P>
<A NAME="sec:maintain_dist"></A></P><P>We try to release Biopython to make it as easy to install as possible for users. Thus, we try to provide the Biopython libraries in as many install formats as we can. Doing this from release to release can be a lot of work for developers, and sometimes requires them to maintain packages they are not all that familiar with. This section is meant to provide tips to encourage other people besides developers to maintain platform builds.</P><P>In general, this is fairly easy &#X2013; all you would need to do is produce the system specific package whenever we make a release. You should then check the package (of course!) to make sure it installs everything properly. Then you just send it to one of the main developers, they stick the package on the web site and just like that, you&#X2019;ve contributed to Biopython! Snazzy.</P><P>Below are some tips for certain platforms to maybe get people started with helping out:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>RPMs</B></DT><DD CLASS="dd-description"> &#X2013; RPMs are pretty popular package systems on some platforms. There is lots of documentation on RPMs available at <A HREF="http://www.rpm.org"><TT>http://www.rpm.org</TT></A> to help you get started with them. To create an RPM for your platform is really easy. You just need to be able to build the package from source (having a C compiler that works is thus essential) &#X2013; see the Biopython installation instructions for more info on this.<P>To make the RPM, you just need to do:</P><PRE CLASS="verbatim">python setup.py bdist_rpm
</PRE><P>This will create an RPM for your specific platform and a source RPM in the directory <CODE>dist</CODE>. This RPM should be good and ready to go, so this is all you need to do! Nice and easy.</P></DD><DT CLASS="dt-description"><B>Windows</B></DT><DD CLASS="dd-description"> &#X2013; Windows products typically have a nice graphical installer that installs all of the essential components in the right place. We can use Distutils to create a installer of this type fairly easily.<P>You must first make sure you have a C compiler on your Windows computer, and that you can compile and install things (see the Biopython installation instructions for info on how to do this).</P><P>Once you are setup with a C compiler, making the installer just requires doing:</P><PRE CLASS="verbatim">python setup.py bdist_wininst
</PRE><P>Now you&#X2019;ve got a Windows installer. Congrats!</P></DD><DT CLASS="dt-description"><B>Macintosh</B></DT><DD CLASS="dd-description"> &#X2013; We would love to find someone who wants to maintain a Macintosh distribution, and make it available in a Macintosh friendly format like bin-hex. This would basically include finding a way to compile everything on the Mac, making sure all of the code written by us UNIX-based developers works well on the Mac, and providing any Mac-friendly hints for us.</DD></DL><P>Once you&#X2019;ve got a package, please test it on your system to make sure it installs everything in a good way and seems to work properly. Once you feel good about it, send it off to one of the biopython developers (write to our main list serve at biopython@biopython.org if you&#X2019;re not sure who to send it to) and you&#X2019;ve done it. Thanks!</P><!--TOC section Bug Reports + Feature Requests-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc128">11.2</A>&#XA0;&#XA0;Bug Reports + Feature Requests</H2><!--SEC END --><P>Getting feedback on the Biopython modules is very important to us. Open-source projects like this benefit greatly from feedback, bug-reports (and patches!) from a wide variety of contributors.</P><P>The main forums for discussing feature requests and potential bugs are the biopython development lists:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="mailto:biopython@biopython.org">biopython@biopython.org</A> &#X2013; An unmoderated list for discussion of anything to do with biopython.</LI><LI CLASS="li-itemize"><A HREF="mailto:biopython-dev@biopython.org">biopython-dev@biopython.org</A> &#X2013; A more development oriented list that is mainly used by developers (but anyone is free to contribute!).
</LI></UL><P>Additionally, if you think you&#X2019;ve found a bug, you can submit it to our
bug-tracking page at <A HREF="http://bugzilla.open-bio.org/"><TT>http://bugzilla.open-bio.org/</TT></A>. This
way, it won&#X2019;t get buried in anyone&#X2019;s Inbox and forgotten about.</P><!--TOC section Contributing Code-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc129">11.3</A>&#XA0;&#XA0;Contributing Code</H2><!--SEC END --><P>There are no barriers to joining biopython code development other than an interest in creating biology-related code in python. The best place to express an interest is on the biopython mailing lists &#X2013; just let us know you are interested in coding and what kind of stuff you want to work on. Normally, we try to have some discussion on modules before coding them, since that helps generate good ideas &#X2013; then just feel free to jump right in and start coding!</P><P>The main biopython release tries to be fairly uniform and interworkable,
to make it easier for users. You can read about some of (fairly
informal) coding style guidelines we try to use in biopython in the
contributing documentation at
<A HREF="http://biopython.org/wiki/Contributing"><TT>http://biopython.org/wiki/Contributing</TT></A>. We also try to add code to the distribution along with tests (see section&#XA0;<A HREF="#sec:regr_test">10.2</A> for more info on the regression testing framework) and documentation, so that everything can stay as workable and well documented as possible. This is, of course, the most ideal situation, under many situations you&#X2019;ll be able to find other people on the list who will be willing to help add documentation or more tests for your code once you make it available. So, to end this paragraph like the last, feel free to start working!</P><P>Additionally, if you have code that you don&#X2019;t think fits in the
distribution, but that you want to make available, we maintain Script
Central (<A HREF="http://biopython.org/wiki/Scriptcentral"><TT>http://biopython.org/wiki/Scriptcentral</TT></A>)
which has pointers to freely available code in python for bioinformatics.</P><P>Hopefully this documentation has got you excited enough about
biopython to try it out (and most importantly, contribute!). Thanks
for reading all the way through!</P><!--TOC chapter Appendix: Useful stuff about Python-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc130">Chapter&#XA0;12</A>&#XA0;&#XA0;Appendix: Useful stuff about Python</H1><!--SEC END --><P>
<A NAME="sec:appendix"></A></P><P>If you haven&#X2019;t spent a lot of time programming in python, many
questions and problems that come up in using Biopython are often
related to python itself. This section tries to present some ideas and
code that come up often (at least for us!) while using the Biopython
libraries. If you have any suggestions for useful pointers that could
go here, please contribute!</P><!--TOC section What the heck is a handle?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc131">12.1</A>&#XA0;&#XA0;What the heck is a handle?</H2><!--SEC END --><P>
<A NAME="sec:appendix-handles"></A></P><P>Handles are mentioned quite frequently throughout this documentation,
and are also fairly confusing (at least to me!). Basically, you can
think of a handle as being a &#X201C;wrapper&#X201D; around text information.</P><P>Handles provide (at least) two benefits over plain text information:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
They provide a standard way to deal with information stored in
different ways. The text information can be in a file, or in a
string stored in memory, or the output from a command line program,
or at some remote website, but the handle provides a common way of
dealing with information in all of these formats.</LI><LI CLASS="li-enumerate">They allow text information to be read incrementally, instead
of all at once. This is really important when you are dealing with
huge text files which would use up all of your memory if you had to
load them all.
</LI></OL><P>Handles can deal with text information that is being read (e.&#XA0;g.&#XA0;reading
from a file) or written (e.&#XA0;g.&#XA0;writing information to a file). In the
case of a &#X201C;read&#X201D; handle, commonly used functions are <CODE>read()</CODE>,
which reads the entire text information from the handle, and
<CODE>readline()</CODE>, which reads information one line at a time. For
&#X201C;write&#X201D; handles, the function <CODE>write()</CODE> is regularly used.</P><P>The most common usage for handles is reading information from a file,
which is done using the built-in python function <CODE>open</CODE>. Here, we open a
handle to the file <A HREF="examples/m_cold.fasta">m_cold.fasta</A>
(also available online
<A HREF="http://biopython.org/DIST/docs/tutorial/examples/m_cold.fasta">here</A>):</P><PRE CLASS="verbatim">&gt;&gt;&gt; handle = open("m_cold.fasta", "r")
&gt;&gt;&gt; handle.readline()
"&gt;gi|8332116|gb|BE037100.1|BE037100 MP14H09 MP Mesembryanthemum ...\n"
</PRE><P>Handles are regularly used in Biopython for passing information to parsers.</P><!--TOC subsection Creating a handle from a string-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc132">12.1.1</A>&#XA0;&#XA0;Creating a handle from a string</H3><!--SEC END --><P>One useful thing is to be able to turn information contained in a
string into a handle. The following example shows how to do this using
<CODE>cStringIO</CODE> from the Python standard library:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_info = 'A string\n with multiple lines.'
&gt;&gt;&gt; print my_info
A string
 with multiple lines.
&gt;&gt;&gt; import cStringIO
&gt;&gt;&gt; my_info_handle = cStringIO.StringIO(my_info)
&gt;&gt;&gt; first_line = my_info_handle.readline()
&gt;&gt;&gt; print first_line
A string

&gt;&gt;&gt; second_line = my_info_handle.readline()
&gt;&gt;&gt; print second_line
 with multiple lines.
</PRE><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
